<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VGAP Saved Turn Viewer</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: #ffffff;
            min-height: 100vh;
            padding: 0; /* Remove all padding */
        }

        .container {
            max-width: 100%; /* Use full screen width */
            margin: 0;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 0; /* Remove border radius */
            padding: 0; /* Remove all padding */
            box-shadow: none; /* Remove shadow */
        }

        h1 {
            text-align: center;
            margin-bottom: 15px;
            color: #00d4ff;
            text-shadow: 0 0 10px rgba(0, 212, 255, 0.5);
        }

        .upload-section {
            background: rgba(255, 255, 255, 0.1);
            padding: 25px;
            border-radius: 10px;
            margin-bottom: 20px;
            backdrop-filter: blur(10px);
            text-align: center;
        }

        .file-input-wrapper {
            position: relative;
            display: inline-block;
            margin-bottom: 15px;
        }

        .file-input {
            position: absolute;
            width: 0.1px;
            height: 0.1px;
            opacity: 0;
            overflow: hidden;
            z-index: -1;
        }

        .file-input-label {
            display: inline-block;
            padding: 15px 30px;
            background: linear-gradient(45deg, #00d4ff, #0099cc);
            border: none;
            border-radius: 8px;
            color: white;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            -webkit-appearance: none;
            appearance: none;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }

        .file-input-label:hover, .file-input-label:focus {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 212, 255, 0.4);
            outline: none;
        }

        .file-input-label:active {
            transform: translateY(0);
            background: linear-gradient(45deg, #0099cc, #007399);
        }

        .drop-zone {
            border: 3px dashed rgba(0, 212, 255, 0.5);
            border-radius: 10px;
            padding: 40px;
            margin: 20px 0;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .drop-zone.dragover {
            border-color: #00d4ff;
            background: rgba(0, 212, 255, 0.1);
            transform: scale(1.02);
        }

        .drop-zone-text {
            font-size: 18px;
            margin-bottom: 10px;
        }

        .drop-zone-subtext {
            font-size: 14px;
            color: rgba(255, 255, 255, 0.7);
        }

        .file-info {
            background: rgba(0, 212, 255, 0.1);
            border: 1px solid rgba(0, 212, 255, 0.3);
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            text-align: left;
        }

        .file-info h3 {
            color: #00d4ff;
            margin-bottom: 10px;
        }

        button {
            padding: 12px 24px;
            background: linear-gradient(45deg, #00d4ff, #0099cc);
            border: none;
            border-radius: 8px;
            color: white;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            margin: 5px;
            -webkit-appearance: none;
            appearance: none;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }

        button:hover, button:focus {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 212, 255, 0.4);
            outline: none;
        }

        button:active {
            transform: translateY(0);
            background: linear-gradient(45deg, #0099cc, #007399);
        }

        button:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .status {
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            font-weight: 600;
            text-align: center;
        }

        .status.loading {
            background: rgba(255, 193, 7, 0.2);
            border: 2px solid #ffc107;
            color: #ffc107;
        }

        .status.success {
            background: rgba(40, 167, 69, 0.2);
            border: 2px solid #28a745;
            color: #28a745;
        }

        .status.error {
            background: rgba(220, 53, 69, 0.2);
            border: 2px solid #dc3545;
            color: #dc3545;
        }

        .hidden {
            display: none;
        }

        .game-info {
            background: rgba(0, 212, 255, 0.1);
            border: 1px solid rgba(0, 212, 255, 0.3);
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }

        .game-info h3 {
            color: #00d4ff;
            margin-bottom: 10px;
        }

        .game-details {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            font-size: 14px;
        }

        .detail-item {
            background: rgba(255, 255, 255, 0.05);
            padding: 8px 12px;
            border-radius: 5px;
        }

        .detail-label {
            font-weight: 600;
            color: #00d4ff;
        }

        .data-sections {
            display: flex;
            gap: 0; /* Remove gap for full width utilization */
            margin: 0; /* Remove all margins */
            height: 100vh; /* Use full viewport height */
            min-height: 100vh;
            width: 100%; /* Ensure full width */
        }

        .tables-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: transparent; /* Remove background */
            border-radius: 0; /* Remove border radius */
            padding: 0; /* Remove all padding */
            border: none; /* Remove border */
            overflow: visible; /* Allow sticky elements to work properly */
            width: 100%; /* Ensure full width */
        }

        .starmap-panel {
            width: 100%;
            display: none; /* Hidden by default */
            flex-direction: column;
            background: transparent; /* Remove background */
            border-radius: 0; /* Remove border radius */
            padding: 0; /* Remove all padding */
            border: none; /* Remove border */
            position: relative;
            margin: 0; /* Remove all margins */
            height: 60vh; /* Define height for flex child to work */
            min-height: 400px; /* Minimum height for usability */
        }

        .starmap-panel.visible {
            display: flex;
        }

        .starmap-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .starmap-header h4 {
            color: #00d4ff;
            margin: 0;
        }

        .starmap-close-btn {
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 12px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .starmap-close-btn:hover {
            background: #c82333;
        }

        .starmap-controls {
            margin: 0; /* Remove all margins */
            padding: 0; /* Remove all padding */
            background: transparent; /* Remove background */
            border-radius: 0; /* Remove border radius */
        }

        .control-group {
            display: flex;
            flex-wrap: wrap;
            gap: 2px; /* Reduced gap for tighter controls */
            align-items: center;
            margin: 0; /* Remove all margins */
        }

        .control-group:last-child {
            margin-bottom: 0;
        }

        .control-group h4 {
            margin: 0 2px 0 0; /* Reduced right margin */
            font-size: 12px;
        }

        .control-group label {
            color: #e0e0e0;
            font-weight: 600;
            font-size: 10px;
            min-width: auto;
            margin-right: 4px;
        }

        .checkbox-rows {
            display: flex;
            flex-direction: column;
            gap: 0px; /* Remove gap between checkbox rows */
        }

        .checkbox-group {
            display: flex;
            flex-wrap: nowrap;
            gap: 4px; /* Reduced gap between checkboxes */
        }

        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 1px; /* Reduced gap between checkbox and label */
            font-size: 12px; /* Slightly larger for better icon visibility */
        }

        .checkbox-item label {
            cursor: pointer;
            user-select: none;
        }

        .checkbox-item input[type="checkbox"] {
            margin: 0;
            transform: scale(0.7);
        }

        .checkbox-item label {
            font-size: 9px;
            margin: 0;
        }

        .zoom-controls {
            display: flex;
            gap: 2px; /* Reduced gap between zoom controls */
            align-items: center;
            flex-wrap: nowrap;
        }

        .zoom-controls button {
            font-size: 9px;
            padding: 1px 3px; /* Reduced padding for more compact buttons */
            min-width: 16px; /* Slightly smaller minimum width */
            height: 16px; /* Slightly smaller height */
        }

        .zoom-indicator {
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #00d4ff;
            border-radius: 2px;
            padding: 1px 3px;
            color: #00d4ff;
            font-family: monospace;
            font-size: 8px;
            font-weight: bold;
            min-width: 28px;
            text-align: center;
        }

        .starmap-close-btn {
            background: #dc3545;
            color: white;
            border: none;
            padding: 2px 6px;
            font-size: 9px;
            border-radius: 3px;
            cursor: pointer;
            margin-left: auto;
            height: 18px;
        }

        #integratedStarmap {
            background: #000011;
            border: 1px solid #333;
            cursor: move;
            border-radius: 4px;
            display: block;
            margin: 0 auto;
            max-width: calc(100vw - 40px);
            width: 100%;
            height: 100%;
            min-height: 400px;
            max-height: calc(100vh - 200px);
        }

        .starmap-container {
            flex: 1;
            background: transparent; /* Remove background */
            border-radius: 0; /* Remove border radius */
            padding: 0; /* Remove all padding */
            border: none; /* Remove border */
            overflow: auto;
            max-height: 100%; /* Use full height of parent */
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 300px; /* Ensure minimum height for SVG */
        }

        /* ===== CENTRALIZED TABLE FRAMEWORK ===== */
        .vgap-table {
            width: 100%;
            border-collapse: collapse;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #444;
            margin: 4px 0;
            font-size: 12px; /* Match existing planets-table */
            position: relative;
            overflow: hidden;
            /* Remove contain that can interfere with sticky positioning */
            /* contain: layout style paint; */
        }
        
        /* Create a sticky column overlay approach */
        .vgap-table-with-sticky {
            position: relative;
            overflow: hidden;
        }
        
        .sticky-column-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 60px;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            border-right: 2px solid #00d4ff;
            box-shadow: 2px 0 8px rgba(0, 212, 255, 0.3);
            z-index: 100;
            pointer-events: none;
            display: none; /* Hidden until we implement it */
        }

        .vgap-table-header {
            background: rgba(0, 212, 255, 0.2); /* Match existing cyan theme */
            border-bottom: 2px solid #444;
            font-weight: bold;
            color: #00d4ff; /* Match existing cyan color */
            padding: 0;
            position: relative;
            z-index: 2;
        }

        .vgap-table-header-row {
            display: flex;
            min-height: 35px;
            position: relative;
            overflow-x: auto;
            overflow-y: hidden;
            scrollbar-width: none; /* Hide scrollbar on Firefox */
            -ms-overflow-style: none; /* Hide scrollbar on IE/Edge */
            /* Ensure header row extends full width when scrolling */
            min-width: 100%;
            width: max-content;
        }

        .vgap-table-header-row::-webkit-scrollbar {
            display: none; /* Hide scrollbar on Webkit browsers */
        }

        .vgap-table-body {
            /* Remove max-height to show all rows without scrolling */
            /* max-height: 400px; */
            overflow-y: visible;
            overflow-x: auto;
            position: relative;
            /* Ensure container allows rows to extend full width */
            min-width: 100%;
            /* Remove transform that breaks sticky positioning */
            /* transform: translateZ(0); */
            /* -webkit-transform: translateZ(0); */
            /* Force hardware acceleration without breaking sticky */
            will-change: scroll-position;
        }

        .vgap-table-row {
            display: flex;
            min-height: 30px;
            border-bottom: 1px solid #333;
            cursor: pointer;
            transition: background-color 0.2s ease;
            /* Ensure row background extends full width when scrolling */
            min-width: 100%;
            width: max-content;
            /* Remove position: relative that might interfere with sticky positioning */
            /* position: relative; */
        }

        .vgap-table-row:hover {
            background: rgba(255, 255, 255, 0.1); /* Match existing hover effect */
        }

        .vgap-table-row.selected {
            background: rgba(0, 212, 255, 0.3) !important; /* Cyan selection theme */
            border-left: 4px solid #00d4ff;
        }

        .vgap-table-row.hover-highlight {
            background: rgba(255, 255, 0, 0.2) !important; /* Yellow hover highlight */
            border-left: 4px solid #ffff00;
        }

        /* Resource-rich starbase candidate highlighting */
        .vgap-table-row.resource-rich-highlight {
            background: rgba(160, 120, 255, 0.15) !important; /* Light purple background */
            border-left: 4px solid #a078ff;
        }

        .vgap-table-row.resource-rich-highlight:hover {
            background: rgba(160, 120, 255, 0.25) !important; /* Slightly darker purple on hover */
        }

        .vgap-table-cell {
            padding: 4px 6px; /* Reduced from 8px for more space */
            text-align: center; /* Match existing center alignment */
            border-right: 1px solid #333;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            font-size: 12px; /* Consistent with table font size */
            flex-shrink: 0; /* Prevent cells from shrinking */
        }

        .vgap-table-cell:last-child {
            border-right: none;
        }

        /* Enhanced sticky first column (ID column) styling */
        .vgap-table-cell.sticky-column,
        .vgap-table-header-cell.sticky-column {
            position: -webkit-sticky !important;
            position: sticky !important;
            left: 0 !important;
            z-index: 100 !important; /* Much higher z-index to ensure it's always on top */
            background: rgba(0, 0, 0, 0.95) !important;
            border-right: 2px solid #00d4ff !important;
            box-shadow: 2px 0 8px rgba(0, 212, 255, 0.3);
            min-width: 60px !important;
            max-width: 60px !important;
            width: 60px !important;
            flex-shrink: 0 !important;
            flex-grow: 0 !important;
        }

        .vgap-table-header-cell.sticky-column {
            background: rgba(0, 212, 255, 0.4) !important;
            z-index: 150 !important; /* Even higher for headers */
        }

        .vgap-table-row.selected .vgap-table-cell.sticky-column {
            background: rgba(0, 212, 255, 0.6);
        }

        .vgap-table-row:hover .vgap-table-cell.sticky-column {
            background: rgba(0, 0, 0, 0.9);
        }

        .vgap-table-row.resource-rich-highlight .vgap-table-cell.sticky-column {
            background: rgba(160, 120, 255, 0.3);
        }

        .vgap-table-row.resource-rich-highlight:hover .vgap-table-cell.sticky-column {
            background: rgba(160, 120, 255, 0.4);
        }

        /* Header specific enhancements */
        .vgap-table-header-cell {
            color: #00d4ff; /* Cyan headers */
            font-weight: 600; /* Match existing weight */
            font-size: 10px; /* Match existing smaller header text */
            cursor: pointer;
            user-select: none;
            position: relative;
            transition: background-color 0.2s ease;
        }

        .vgap-table-header-cell:hover {
            background: rgba(0, 212, 255, 0.3); /* Match existing hover */
        }

        /* Enhanced sorting arrows to match existing style */
        .vgap-table-header-cell.sorted-asc::after {
            content: '';
            position: absolute;
            right: 5px;
            top: 50%;
            transform: translateY(-50%);
            width: 0;
            height: 0;
            border-left: 4px solid transparent;
            border-right: 4px solid transparent;
            border-bottom: 6px solid #00d4ff; /* Cyan arrows */
        }

        .vgap-table-header-cell.sorted-desc::after {
            content: '';
            position: absolute;
            right: 5px;
            top: 50%;
            transform: translateY(-50%);
            width: 0;
            height: 0;
            border-left: 4px solid transparent;
            border-right: 4px solid transparent;
            border-top: 6px solid #00d4ff; /* Cyan arrows */
        }

        /* Column width classes */
        .col-xs { flex: 0 0 40px; min-width: 40px; }
        .col-sm { flex: 0 0 60px; min-width: 60px; }
        .col-md { flex: 0 0 80px; min-width: 80px; }
        .col-lg { flex: 0 0 120px; min-width: 120px; }
        .col-xl { flex: 0 0 160px; min-width: 160px; }
        .col-auto { flex: 1; min-width: 100px; }

        /* Special override for sticky ID columns */
        .sticky-column.col-xs {
            flex: 0 0 60px !important;
            min-width: 60px !important;
            max-width: 60px !important;
            width: 60px !important;
        }

        /* Cell alignment classes */
        .text-left { text-align: left; justify-content: flex-start; }
        .text-center { text-align: center; justify-content: center; }
        .text-right { text-align: right; justify-content: flex-end; }

        /* Sortable header styling */
        .vgap-table-header-cell.sortable {
            cursor: pointer;
            user-select: none;
            position: relative;
            padding-right: 25px;
        }

        .vgap-table-header-cell.sortable:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .vgap-table-header-cell.sortable::after {
            content: '↕';
            position: absolute;
            right: 8px;
            opacity: 0.5;
            font-size: 12px;
        }

        .vgap-table-header-cell.sorted-asc::after {
            content: '↑';
            opacity: 1;
            color: #4CAF50;
        }

        .vgap-table-header-cell.sorted-desc::after {
            content: '↓';
            opacity: 1;
            color: #4CAF50;
        }

        /* Color-coded cells */
        .cell-positive { color: #4CAF50; }
        .cell-negative { color: #F44336; }
        .cell-neutral { color: #9E9E9E; }
        .cell-warning { color: #FF9800; }
        .cell-info { color: #2196F3; }

        /* Status indicators */
        .status-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 6px;
        }

        .status-good { background: #4CAF50; }
        .status-warning { background: #FF9800; }
        .status-bad { background: #F44336; }
        .status-neutral { background: #9E9E9E; }

        /* Cell Color Classes - Enhanced */
        .cell-positive { color: #4CAF50; }
        .cell-warning { color: #FF9800; }
        .cell-negative { color: #F44336; }

        /* ===== SEMANTIC VGAP DATA CLASSES ===== */
        /* Temperature Styling */
        .vgap-temp-extreme {
            color: #ff5722;
            font-weight: bold;
        }

        .vgap-temp-hot {
            color: #ff9800;
        }

        .vgap-temp-moderate {
            color: #8bc34a;
        }

        .vgap-temp-cool {
            color: #03a9f4;
        }

        .vgap-temp-cold {
            color: #2196f3;
            font-weight: bold;
        }

        /* Happiness Levels - Match existing successful colors */
        .vgap-happiness-high,
        .happiness-high {
            color: #4caf50; /* Match existing green */
            font-weight: bold;
        }

        .vgap-happiness-medium,
        .happiness-medium {
            color: #8bc34a; /* Match existing light green */
        }

        .vgap-happiness-low,
        .happiness-low {
            color: #dc3545; /* Match existing red */
            opacity: 0.8;
        }

        /* Resource Levels - Match existing successful colors */
        .vgap-resource-abundant,
        .resource-high {
            color: #28a745; /* Match existing green */
            font-weight: bold;
        }

        .vgap-resource-good {
            color: #4caf50; /* Light green variation */
        }

        .vgap-resource-moderate,
        .resource-medium {
            color: #ffc107; /* Match existing yellow */
        }

        .vgap-resource-low,
        .resource-low {
            color: #ff9800; /* Orange for low but not critical */
        }

        .vgap-resource-critical {
            color: #dc3545; /* Match existing red */
            font-weight: bold;
        }

        /* Starbase Status - Match existing colors */
        .vgap-starbase-yes,
        .starbase-yes {
            color: #28a745; /* Match existing green */
            font-weight: bold;
        }

        .vgap-starbase-no,
        .starbase-no {
            color: #dc3545; /* Match existing red */
        }

        /* Native Information */
        .vgap-native-race, .vgap-native-gov {
            font-size: 11px;
            font-style: italic;
            color: #b8b8b8;
        }

        /* Friendly Codes */
        .vgap-friendly-code {
            font-family: 'Courier New', monospace;
            font-weight: bold;
            text-transform: uppercase;
            color: #e0e0e0;
            background: rgba(255, 255, 255, 0.1);
            padding: 2px 4px;
            border-radius: 3px;
        }

        /* Planet Names - Enhanced to match existing styling */
        .vgap-planet-name {
            text-align: left !important;
            justify-content: flex-start !important;
            max-width: 120px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            font-weight: 500;
            color: #00d4ff; /* Match existing cyan theme */
        }

        /* Coordinates - Match existing monospace styling */
        .vgap-coordinates {
            font-family: 'Courier New', monospace;
            color: #b0b0b0;
            font-size: 11px;
        }

        /* Ship Hull Names */
        .vgap-hull-name {
            font-size: 11px;
            font-style: italic;
            color: #00d4ff; /* Match existing cyan theme */
        }

        /* Damage Indicators */
        .vgap-damage-none {
            color: #4caf50;
        }

        .vgap-damage-light {
            color: #ffc107;
        }

        .vgap-damage-moderate {
            color: #ff9800;
        }

        .vgap-damage-heavy {
            color: #f44336;
            font-weight: bold;
        }

        /* Fuel Levels */
        .vgap-fuel-full {
            color: #4caf50;
        }

        .vgap-fuel-good {
            color: #8bc34a;
        }

        .vgap-fuel-low {
            color: #ff9800;
        }

        .vgap-fuel-critical {
            color: #f44336;
            font-weight: bold;
        }

        /* Mission Status */
        .vgap-mission-active {
            color: #4caf50;
            font-weight: bold;
        }

        .vgap-mission-pending {
            color: #ffc107;
        }

        .vgap-mission-none {
            color: #6c757d;
            opacity: 0.7;
        }

        /* Legacy compatibility - duplicate styles for backward compatibility */
        .temp-extreme,
        .vgap-temp-extreme {
            color: #ff5722;
            font-weight: bold;
        }

        .temp-hot,
        .vgap-temp-hot {
            color: #ff9800;
        }

        .temp-moderate,
        .vgap-temp-moderate {
            color: #8bc34a;
        }

        .temp-cool,
        .vgap-temp-cool {
            color: #03a9f4;
        }

        .temp-cold,
        .vgap-temp-cold {
            color: #2196f3;
            font-weight: bold;
        }

        .happiness-high,
        .vgap-happiness-high {
            color: #4caf50;
            font-weight: bold;
        }

        .happiness-medium,
        .vgap-happiness-medium {
            color: #8bc34a;
        }

        .happiness-low,
        .vgap-happiness-low {
            color: #f44336;
            opacity: 0.8;
        }

        .resource-high,
        .vgap-resource-abundant {
            color: #4caf50;
            font-weight: bold;
        }

        .resource-medium,
        .vgap-resource-moderate {
            color: #ffc107;
        }

        .resource-low,
        .vgap-resource-low {
            color: #ff9800;
        }

        .starbase-yes,
        .vgap-starbase-yes {
            color: #28a745;
            font-weight: bold;
        }

        .starbase-no,
        .vgap-starbase-no {
            color: #6c757d;
            opacity: 0.7;
        }

        /* Tech level color classes */
        .vgap-tech-max {
            color: #00ff88;
            font-weight: bold;
        }

        .vgap-tech-high {
            color: #4caf50;
        }

        .vgap-tech-medium {
            color: #ffc107;
        }

        .vgap-tech-low {
            color: #ff9800;
        }

        .vgap-tech-none {
            color: #6c757d;
            opacity: 0.6;
        }

        .friendly-code,
        .vgap-friendly-code {
            font-family: 'Courier New', monospace;
            font-weight: bold;
            text-transform: uppercase;
            color: #e0e0e0;
            background: rgba(255, 255, 255, 0.1);
            padding: 2px 4px;
            border-radius: 3px;
        }

        .planet-name,
        .vgap-planet-name {
            text-align: left;
            max-width: 120px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            font-weight: 500;
        }

        .native-race,
        .native-gov,
        .vgap-native-race,
        .vgap-native-gov {
            font-size: 11px;
            font-style: italic;
            color: #b8b8b8;
        }

        /* Compact table variant */
        .vgap-table.compact .vgap-table-row {
            min-height: 25px;
        }

        .vgap-table.compact .vgap-table-cell {
            padding: 4px 8px;
            font-size: 12px;
        }

        /* Dense table variant */
        .vgap-table.dense .vgap-table-row {
            min-height: 35px;
        }

        .vgap-table.dense .vgap-table-cell {
            padding: 6px 10px;
            font-size: 13px;
        }

        /* Dense table variant - max-height removed to show all rows */
        /* .vgap-table.dense .vgap-table-body {
            max-height: 200px;
        } */

        /* Selection highlighting styles - disable transitions for instant flash */
        .selected-object {
            stroke-width: 3 !important;
            transition: none !important; /* Disable any CSS transitions */
        }

        /* Disable transitions on all SVG elements to prevent fade effects */
        svg * {
            transition: none !important;
        }

        .table-row-selected {
            background: rgba(255, 255, 0, 0.2) !important;
            border-left: 4px solid #ff0 !important;
        }

        .data-section {
            background: rgba(0, 0, 0, 0.6);
            border-radius: 10px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .data-section h4 {
            color: #00d4ff;
            margin-bottom: 15px;
            font-size: 18px;
        }

        .data-list {
            max-height: 400px;
            overflow-y: auto;
        }

        .data-item {
            background: rgba(255, 255, 255, 0.05);
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 8px;
            font-size: 12px;
            line-height: 1.4;
        }

        .data-item:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .planets-section {
            background: rgba(0, 0, 0, 0.6);
            border-radius: 10px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            margin-bottom: 20px;
            /* Ensure vertical stacking and proper width */
            width: 100%;
            overflow-x: auto;
            display: block;
        }

        .planets-section h4 {
            color: #00d4ff;
            margin-bottom: 15px;
            font-size: 18px;
        }

        .planets-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
            margin-bottom: 20px;
        }

                .planets-table th,
        .planets-table td,
        .ships-table th,
        .ships-table td {
            padding: 8px;
            text-align: center;
            white-space: nowrap;
        }
        
        .ships-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
            background-color: rgba(0, 0, 0, 0.4);
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .planets-table th {
            background: rgba(0, 212, 255, 0.2);
            color: #00d4ff;
            font-weight: 600;
            font-size: 10px;
            cursor: pointer;
            user-select: none;
            position: relative;
            transition: background-color 0.2s ease;
        }

        .planets-table th:hover {
            background: rgba(0, 212, 255, 0.3);
        }

        .planets-table th.sort-asc::after,
        .planets-table th.sort-desc::after,
        .ships-table th.sort-asc::after,
        .ships-table th.sort-desc::after,
        .starbases-table th.sort-asc::after,
        .starbases-table th.sort-desc::after {

        /* ===== MOBILE RESPONSIVE TABLE STYLING ===== */
        /* Mobile-first responsive design for tables with many columns */
        @media screen and (max-width: 768px) {
            /* Hide traditional table headers on mobile */
            .vgap-table-header {
                display: none;
            }
            
            /* Make table body stack vertically */
            .vgap-table-body {
                display: block;
            }
            
            /* Make each row a block element that takes full width */
            .vgap-table-row {
                display: block;
                width: 100%;
                margin-bottom: 15px;
                padding: 10px;
                background: rgba(0, 0, 0, 0.4);
                border-radius: 8px;
                border: 1px solid rgba(255, 255, 255, 0.1);
                position: relative;
            }
            
            /* Make each cell a block element with label */
            .vgap-table-cell {
                display: flex;
                width: 100%;
                padding: 5px 0;
                border-right: none;
                border-bottom: 1px solid rgba(255, 255, 255, 0.1);
                text-align: right;
                justify-content: space-between;
                align-items: center;
                position: relative;
                min-height: 20px;
            }
            
            .vgap-table-cell:last-child {
                border-bottom: none;
            }
            
            /* Add column labels using pseudo-elements */
            .vgap-table-cell::before {
                content: attr(data-label);
                color: #00d4ff;
                font-weight: 600;
                font-size: 11px;
                text-align: left;
                flex: 0 0 40%;
                padding-right: 10px;
            }
            
            /* Override column width classes on mobile */
            .vgap-table-cell.col-xs,
            .vgap-table-cell.col-sm,
            .vgap-table-cell.col-md,
            .vgap-table-cell.col-lg,
            .vgap-table-cell.col-xl,
            .vgap-table-cell.col-auto {
                flex: none;
                min-width: auto;
                width: 100%;
            }
            
            /* Resource highlighting adjustments for mobile */
            .vgap-table-row.resource-rich-highlight {
                border-left: 4px solid #a078ff;
                background: rgba(160, 120, 255, 0.2);
            }
            
            .vgap-table-row.selected {
                border-left: 4px solid #00d4ff;
                background: rgba(0, 212, 255, 0.25);
            }
            
            /* Compact spacing for mobile */
            .vgap-table.compact .vgap-table-row {
                margin-bottom: 10px;
                padding: 8px;
            }
            
            .vgap-table.compact .vgap-table-cell {
                padding: 3px 0;
                font-size: 11px;
            }
            
            .vgap-table.compact .vgap-table-cell::before {
                font-size: 10px;
            }
            
            /* Dense table adjustments for mobile */
            .vgap-table.dense .vgap-table-row {
                margin-bottom: 12px;
                padding: 12px;
            }
            
            /* Hide less important columns on smaller mobile screens */
            @media screen and (max-width: 480px) {
                /* Hide coordinate cells on very small screens */
                .vgap-table-cell.vgap-coordinates {
                    display: none;
                }
                
                /* Hide density columns on very small screens */
                .vgap-table-cell[data-label*="⬇"] {
                    display: none;
                }
                
                /* More compact spacing for very small screens */
                .vgap-table-row {
                    margin-bottom: 10px;
                    padding: 8px;
                }
                
                .vgap-table-cell::before {
                    width: 35%;
                    font-size: 10px;
                }
            }
        }
        
        /* Tablet responsive adjustments */
        @media screen and (min-width: 769px) and (max-width: 1024px) {
            /* Slightly reduce column widths on tablets */
            .col-lg { flex: 0 0 100px; min-width: 100px; }
            .col-xl { flex: 0 0 140px; min-width: 140px; }
            
            /* Smaller font sizes for tablets */
            .vgap-table-cell {
                font-size: 11px;
            }
            
            .vgap-table-header-cell {
                font-size: 9px;
            }
        }
            content: '';
            position: absolute;
            right: 5px;
            top: 50%;
            transform: translateY(-50%);
            width: 0;
            height: 0;
            border-left: 4px solid transparent;
            border-right: 4px solid transparent;
        }

        .planets-table th.sort-asc::after,
        .ships-table th.sort-asc::after,
        .starbases-table th.sort-asc::after {
            border-bottom: 6px solid #00d4ff;
        }

        .planets-table th.sort-desc::after,
        .ships-table th.sort-desc::after,
        .starbases-table th.sort-desc::after {
            border-top: 6px solid #00d4ff;
        }

        .ships-table th {
            background: rgba(0, 212, 255, 0.2);
            color: #00d4ff;
            font-weight: 600;
            font-size: 10px;
            cursor: pointer;
            user-select: none;
            position: relative;
            transition: background-color 0.2s ease;
        }

        .ships-table th:hover {
            background: rgba(0, 212, 255, 0.3);
        }

        .starbases-table th {
            background: rgba(0, 212, 255, 0.2);
            color: #00d4ff;
            font-weight: 600;
            font-size: 10px;
            cursor: pointer;
            user-select: none;
            position: relative;
            transition: background-color 0.2s ease;
        }

        .starbases-table th:hover {
            background: rgba(0, 212, 255, 0.3);
        }

        .planets-table tr:nth-child(even) {
            background: rgba(255, 255, 255, 0.05);
        }

        .planets-table tr:hover,
        .ships-table tr:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }
        
        .ship-name {
            text-align: left;
            color: #00d4ff;
            font-weight: bold;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }        .planet-name {
            text-align: left !important;
            max-width: 100px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .starbase-yes {
            color: #28a745;
            font-weight: bold;
        }

        .starbase-no {
            color: #dc3545;
        }

        .resource-high {
            color: #28a745;
            font-weight: bold;
        }

        .resource-medium {
            color: #ffc107;
        }

        .resource-low {
            color: #dc3545;
        }
        
        .happiness-high {
            color: #4caf50;
            font-weight: bold;
        }
        
        .happiness-medium {
            color: #8bc34a;
        }
        
        .happiness-low {
            color: #4caf50;
            opacity: 0.6;
        }

        .temp-extreme {
            color: #ff5722;
            font-weight: bold;
        }

        .temp-hot {
            color: #ff9800;
        }

        .temp-moderate {
            color: #8bc34a;
        }

        .temp-cool {
            color: #03a9f4;
        }

        .temp-cold {
            color: #2196f3;
            font-weight: bold;
        }

        .friendly-code {
            font-family: monospace;
            font-weight: bold;
            text-transform: uppercase;
        }

        .native-race, .native-gov {
            font-size: 11px;
            font-style: italic;
        }

        .section-divider {
            margin: 20px 0;
            border-top: 2px solid rgba(0, 212, 255, 0.3);
            padding-top: 20px;
        }

        .starbases-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
        }

        .starbases-table th,
        .starbases-table td {
            padding: 6px 4px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            text-align: center;
        }

        .starbases-table th {
            background: rgba(0, 212, 255, 0.2);
            color: #00d4ff;
            font-weight: 600;
            font-size: 10px;
        }

        .starbases-table tr:nth-child(even) {
            background: rgba(255, 255, 255, 0.05);
        }

        .starbases-table tr:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .tech-high {
            color: #28a745;
            font-weight: bold;
        }

        .tech-medium {
            color: #ffc107;
        }

        .tech-low {
            color: #dc3545;
        }

        /* Starbase requirements table styling */
        .starbase-requirements-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
        }

        .starbase-requirements-table th,
        .starbase-requirements-table td {
            padding: 6px 4px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            text-align: center;
        }

        .starbase-requirements-table th {
            background: rgba(0, 212, 255, 0.2);
            color: #00d4ff;
            font-weight: 600;
            font-size: 10px;
        }

        .starbase-requirements-table tr:nth-child(even) {
            background: rgba(255, 255, 255, 0.05);
        }

        .starbase-requirements-table tr:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .building-starbase {
            background: rgba(255, 235, 59, 0.2) !important;
            border-left: 4px solid #ffeb3b;
        }

        .ready-starbase {
            background: rgba(76, 175, 80, 0.2) !important;
            border-left: 4px solid #4caf50;
        }

        .connected-starbase {
            background: rgba(244, 4, 226, 0.1) !important;
            border-left: 4px solid #f204e2;
        }

        .connection-cell {
            font-size: 11px;
            font-weight: bold;
        }

        .progress-bar {
            position: relative;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            height: 16px;
            width: 60px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            transition: width 0.3s ease;
        }

        .progress-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 10px;
            font-weight: bold;
            color: white;
            text-shadow: 0 0 3px rgba(0, 0, 0, 0.8);
        }

        .resource-complete {
            color: #28a745;
            font-weight: bold;
        }

        .resource-needed {
            color: #dc3545;
            font-weight: bold;
        }

        .status-cell {
            font-weight: bold;
            font-size: 11px;
        }

        .progress-cell {
            padding: 4px !important;
        }

        .progress-bar {
            position: relative;
            width: 60px;
            height: 16px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            overflow: hidden;
            margin: 0 auto;
        }

        .progress-fill {
            height: 100%;
            transition: width 0.3s ease;
            border-radius: 8px;
        }

        .progress-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 9px;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 0 2px rgba(0, 0, 0, 0.8);
        }

        .resource-needed {
            color: #ff9800;
            font-weight: bold;
        }

        .resource-complete {
            color: #4caf50;
        }

        /* Tab buttons styling */
        .tab-buttons {
            display: flex;
            flex-wrap: nowrap;
            gap: 2px;
            margin-bottom: 6px;
            padding: 3px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
            backdrop-filter: blur(10px);
            overflow-x: auto;
            scrollbar-width: none;
        }

        .tab-buttons::-webkit-scrollbar {
            display: none;
        }

        .tab-button {
            background: rgba(0, 212, 255, 0.1);
            color: #00d4ff;
            border: 1px solid rgba(0, 212, 255, 0.3);
            padding: 4px 6px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s ease;
            min-width: 26px;
            height: 26px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex: 0 0 auto;
        }

        .tab-button:hover {
            background: rgba(0, 212, 255, 0.2);
            transform: translateY(-1px);
        }

        .tab-button.active {
            background: rgba(0, 212, 255, 0.3);
            border-color: #00d4ff;
            box-shadow: 0 0 6px rgba(0, 212, 255, 0.5);
        }

        .tab-content {
            flex: 1;
            min-height: 100px; /* Reduced minimum height */
        }

        .tab-section {
            display: none;
        }

        .tab-section.active {
            display: block;
        }

        /* ===== STARMAP-SPECIFIC STYLES ===== */
        
        /* Enhanced zoom indicator styles */
        .zoom-indicator.zoom-min {
            border-color: #ff9800;
            color: #ff9800;
        }

        .zoom-indicator.zoom-max {
            border-color: #f44336;
            color: #f44336;
        }

        /* Legend styles */
        .legend {
            background: rgba(0, 0, 0, 0.8);
            border-radius: 8px;
            padding: 15px;
            margin-top: 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .legend h3 {
            color: #00d4ff;
            margin-bottom: 10px;
        }

        .legend-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .legend-section {
            background: rgba(255, 255, 255, 0.05);
            padding: 10px;
            border-radius: 6px;
        }

        .legend-section h4 {
            color: #00d4ff;
            font-size: 14px;
            margin-bottom: 8px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 5px;
            font-size: 12px;
        }

        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            border: 1px solid #fff;
        }

        .legend-shape {
            width: 16px;
            height: 16px;
            border: 1px solid #fff;
        }
        
        .legend-info {
            background: rgba(0, 21, 25, 0.7);
            padding: 8px 12px;
            border-radius: 6px;
            margin-bottom: 10px;
            color: #00d4ff;
            font-size: 0.9em;
            text-align: center;
        }

        /* Tooltip styles - Fixed position on right side of starmap */
        .tooltip {
            position: fixed;
            background: rgba(0, 0, 0, 0.95);
            color: #fff;
            padding: 15px 20px;
            border-radius: 8px;
            pointer-events: none;
            font-size: 12px;
            display: none;
            z-index: 1000;
            border: 2px solid #00d4ff;
            box-shadow: 0 8px 25px rgba(0, 212, 255, 0.3);
            backdrop-filter: blur(10px);
            /* Fixed positioning on right side */
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            width: 320px;
            max-height: 80vh;
            overflow-y: auto;
        }

        .tooltip h4 {
            color: #00d4ff;
            margin-bottom: 5px;
        }

        .tooltip-grid {
            display: grid;
            grid-template-columns: auto 1fr;
            gap: 5px 10px;
            font-size: 11px;
        }

        .tooltip-label {
            font-weight: bold;
            color: #ccc;
        }

        /* Enhanced controls styling from original */
        .controls {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            backdrop-filter: blur(10px);
        }

        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .checkbox-item input[type="checkbox"] {
            margin: 0;
        }

        .checkbox-item label {
            min-width: auto;
            font-size: 14px;
        }

        /* Animations for starbase planning indicators */
        @keyframes pulse {
            0% { opacity: 0; }
            50% { opacity: 0.3; }
            100% { opacity: 1; }
        }

        /* Starmap element selection and hover styles */
        [data-type="planet"].selected,
        [data-type="ship"].selected,
        [data-type="starbase"].selected {
            stroke: #00d4ff !important;
            stroke-width: 4px !important;
            filter: drop-shadow(0 0 6px #00d4ff) !important;
        }

        [data-type="planet"].hover-highlight,
        [data-type="ship"].hover-highlight,
        [data-type="starbase"].hover-highlight {
            stroke: #ffff00 !important;
            stroke-width: 3px !important;
            filter: drop-shadow(0 0 4px #ffff00) !important;
        }

        @media (max-width: 1200px) {
            .planets-table,
            .starbases-table,
            .starbase-requirements-table {
                font-size: 10px;
            }
            
            .planets-table th,
            .planets-table td,
            .starbases-table th,
            .starbases-table td,
            .starbase-requirements-table th,
            .starbase-requirements-table td {
                padding: 4px 2px;
            }

            .data-sections {
                flex-direction: column;
                height: auto;
            }

            .starmap-panel.visible {
                width: 100%;
                height: 100vh; /* Use full viewport height on smaller screens */
                margin: 0; /* Remove all margins */
            }

            .tables-panel {
                height: auto;
                min-height: 400px;
            }
        }

        @media (max-width: 768px) {
            .checkbox-rows {
                flex-direction: row; /* Stack checkbox rows horizontally on mobile */
                flex-wrap: wrap;
                gap: 4px;
            }
            
            .starmap-controls .checkbox-group {
                flex-direction: row; /* Keep checkboxes in rows */
                align-items: center;
                gap: 4px;
            }
            
            .zoom-controls {
                flex-wrap: wrap;
                justify-content: flex-start;
            }
        }

        .navigation {
            text-align: center;
            margin-bottom: 20px;
        }

        .nav-link {
            color: #00d4ff;
            text-decoration: none;
            font-weight: 600;
            padding: 10px 20px;
            border: 2px solid #00d4ff;
            border-radius: 8px;
            display: inline-block;
            margin: 0 10px;
            transition: all 0.3s ease;
        }

        .nav-link:hover {
            background: #00d4ff;
            color: #1e3c72;
            box-shadow: 0 5px 15px rgba(0, 212, 255, 0.4);
        }

        .build-info {
            text-align: center;
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
            font-size: 12px;
            color: rgba(255, 255, 255, 0.6);
        }

        .build-info a {
            color: #00d4ff;
            text-decoration: none;
        }

        .build-info a:hover {
            text-decoration: underline;
        }

        /* Debug Panel Styles */
        .debug-panel {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 400px;
            max-height: 300px;
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid #00d4ff;
            border-radius: 8px;
            padding: 15px;
            color: #ffffff;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            z-index: 10000;
            display: none;
        }

        .debug-panel.visible {
            display: block;
        }

        .debug-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            border-bottom: 1px solid #00d4ff;
            padding-bottom: 5px;
        }

        .debug-title {
            color: #00d4ff;
            font-weight: bold;
        }

        .debug-close {
            background: #dc3545;
            color: white;
            border: none;
            padding: 2px 6px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 10px;
        }

        .debug-log {
            max-height: 200px;
            overflow-y: auto;
            background: rgba(255, 255, 255, 0.1);
            padding: 8px;
            border-radius: 4px;
            margin-bottom: 10px;
        }

        .debug-log-entry {
            margin: 2px 0;
            padding: 2px;
            border-radius: 2px;
        }

        .debug-log-entry.error {
            background: rgba(220, 53, 69, 0.3);
            color: #ff6b6b;
        }

        .debug-log-entry.warn {
            background: rgba(255, 193, 7, 0.3);
            color: #ffc107;
        }

        .debug-log-entry.success {
            background: rgba(40, 167, 69, 0.3);
            color: #28a745;
        }

        .debug-controls {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
        }

        .debug-btn {
            background: #007bff;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 10px;
        }

        .debug-btn:hover {
            background: #0056b3;
        }

        .debug-btn.success {
            background: #28a745;
        }

        .debug-btn.warning {
            background: #ffc107;
            color: #000;
        }

        .debug-btn.danger {
            background: #dc3545;
        }

        @media (max-width: 600px) {
            .container {
                padding: 15px;
            }
            
            .game-details {
                grid-template-columns: 1fr;
            }

            .data-sections {
                grid-template-columns: 1fr;
            }

            .navigation {
                margin-bottom: 15px;
            }

            .nav-link {
                display: block;
                margin: 10px 0;
            }
        }
    </style>
</head>
<body>
    <script>
    // Alliance parser output (example: you are player 1, ally is player 3)
    window.alliedPlayerIds = []; // TODO: Replace with dynamic parser output
        // Embedded test data - only used in test mode
    </script>
    
    <script>
        // Load VGAP turn data from external JavaScript file
    </script>
    <script src="test_turn_data.js"></script>
    <script>
        // Turn data script loaded - contains window.VGAP_TURN_DATA
    </script>

    <div class="container">
        <!-- Tooltip element for starmap hover information -->
        <div id="starmapTooltip" class="tooltip"></div>
        
        <h1>📁 VGAP Saved Turn Viewer</h1>
        
        <!-- Test Mode Toggle -->
        <div class="test-mode-toggle" style="text-align: center; margin-bottom: 15px;">
            <label style="color: #00d4ff; font-size: 14px; display: inline-flex; align-items: center; gap: 8px;">
                <input type="checkbox" id="testModeToggle" style="margin: 0;" checked>
                <span>Test Mode (Auto-load sample data)</span>
            </label>
        </div>
        
        <div class="navigation">
            <a href="mobile_vgap_viewer.html" class="nav-link">🚀 Live Turn Loader</a>
            <a href="saved_turn_viewer.html" class="nav-link">📁 Saved Turn Viewer</a>
        </div>

        <div class="upload-section">
            <div class="drop-zone" id="dropZone">
                <div class="drop-zone-text">📄 Drop your saved turn file here</div>
                <div class="drop-zone-subtext">or</div>
                <br>
                <div class="file-input-wrapper">
                    <input type="file" id="fileInput" class="file-input" accept=".json" />
                    <label for="fileInput" class="file-input-label">Choose JSON File</label>
                    <button id="testLoadBtn" type="button" style="margin-left: 10px; padding: 8px 15px; background: #007acc; color: white; border: none; border-radius: 4px; cursor: pointer;">
                        🧪 Load Test Data
                    </button>
                </div>
                <div class="drop-zone-subtext">Supports JSON files exported from VGAP Mobile Turn Viewer</div>
            </div>

            <div id="fileInfo" class="file-info hidden">
                <h3>📄 File Information</h3>
                <div id="fileDetails"></div>
                <button id="clearFileBtn" type="button">Clear File</button>
            </div>
        </div>

        <div id="status" class="status hidden"></div>
        
        <div id="gameInfo" class="game-info hidden">
            <h3>🎮 Game Information</h3>
            <div id="gameDetails" class="game-details"></div>
            <div style="text-align: center; margin-top: 15px;">
                <button id="copyBtn" type="button">📋 Copy Data</button>
                <button id="saveBtn" type="button">💾 Re-save File</button>
            </div>
        </div>

        <div id="dataSections" class="data-sections hidden">
            <!-- Tables Panel -->
            <div class="tables-panel">
                <!-- Starmap Panel - moved above tab content -->
                <div class="starmap-panel" id="starmapPanel">
                    <div class="starmap-controls">
                        <div class="control-group">
                            <h4 style="color: #00d4ff; margin: 0; font-size: 14px;">🌌 Starmap</h4>
                            <span style="color: #e0e0e0; font-weight: 600; font-size: 10px; margin-right: 4px;">Show:</span>
                        </div>
                        <div class="checkbox-rows">
                            <div class="checkbox-group">
                                <div class="checkbox-item">
                                    <input type="checkbox" id="showPlanets" checked>
                                    <label for="showPlanets">🪐</label>
                                </div>
                                <div class="checkbox-item">
                                    <input type="checkbox" id="showShips" checked>
                                    <label for="showShips">🚢</label>
                                </div>
                            </div>
                            <div class="checkbox-group">
                                <div class="checkbox-item">
                                    <input type="checkbox" id="showStarbases" checked>
                                    <label for="showStarbases">🏭</label>
                                </div>
                                <div class="checkbox-item">
                                    <input type="checkbox" id="showNebulas" checked>
                                    <label for="showNebulas">☁️</label>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Ally Configuration -->
                        <div class="control-group" style="margin-top: 8px;">
                            <label for="allyIdsInput" style="color: #66ccff; font-size: 12px; font-weight: bold;">🤝 Allies (comma-separated player IDs):</label>
                            <input type="text" id="allyIdsInput" placeholder="e.g. 2,4,7" style="width: 100%; padding: 4px; background: rgba(0,0,0,0.5); border: 1px solid #66ccff; border-radius: 3px; color: #fff; font-size: 12px;" title="Enter ally player IDs separated by commas">
                        </div>
                        <div class="control-group">
                            <div class="zoom-controls">
                                <button id="zoomIn" type="button">+</button>
                                <button id="zoomOut" type="button">-</button>
                                <button id="resetZoom" type="button">Reset</button>
                                <button id="fitToScreen" type="button">Fit</button>
                                <div id="zoomIndicator" class="zoom-indicator">100%</div>
                            </div>
                            <button class="starmap-close-btn" id="closeStarmap" type="button">✖</button>
                        </div>
                    </div>

                    <div class="starmap-container">
                        <svg id="integratedStarmap" width="100%" height="100%" viewBox="0 0 1600 600" style="max-width: 100%; height: 100%;"></svg>
                    </div>
                </div>

                <!-- Tab buttons - moved below starmap -->
                <div class="tab-buttons">
                    <button class="tab-button" data-tab="allied-planets" title="Allied Planets" style="color:#66ccff;">🪐 Ally</button>
                    <button class="tab-button" data-tab="allied-starbases" title="Allied Starbases" style="color:#66ccff;">🏭 Ally</button>
                    <button class="tab-button" data-tab="allied-ships" title="Allied Ships" style="color:#66ccff;">🚢 Ally</button>
                    <button class="tab-button active" data-tab="my-planets" title="My Planets">🪐</button>
                    <button class="tab-button" data-tab="my-starbases" title="My Starbases">🏭</button>
                    <button class="tab-button" data-tab="future-starbases" title="Future Starbases">🏗️</button>
                    <button class="tab-button" data-tab="enemy-starbases" title="Enemy Starbases">⚔️</button>
                    <button class="tab-button" data-tab="enemy-planets" title="Enemy Planets">🌍</button>
                    <button class="tab-button" data-tab="my-ships" title="My Ships">🚢</button>
                    <button class="tab-button" data-tab="enemy-ships" title="Enemy Ships">⚓</button>
                    <button class="tab-button" data-tab="other-data" title="Other Data">📋</button>
                </div>

                <!-- Tab content -->
                <div id="tab-content" class="tab-content">
                    <!-- Content will be populated by JavaScript -->
                </div>
            </div>
        </div>

        <div class="build-info">
            <div>📁 VGAP Saved Turn Viewer</div>
            <div>Built: <span id="buildDate"></span> | <a href="https://github.com/simonclur/VGAP_MobileTurnViewExchange" target="_blank">View on GitHub</a></div>
        </div>
    </div>

    <script>
        // ===== SELECTION MANAGER MODULE =====
        class SelectionManager {
            constructor() {
                this.currentSelection = null;
                this.flashInterval = null;
                this.isFlashOn = false;
            }

            // Clear any existing selection
            clearSelection() {
                if (this.flashInterval) {
                    clearInterval(this.flashInterval);
                    this.flashInterval = null;
                }
                
                // Remove visual selection from all elements
                document.querySelectorAll('.selected-object').forEach(el => {
                    el.classList.remove('selected-object');
                    this.restoreOriginalStyle(el);
                });
                
                this.currentSelection = null;
            }

            // Select and flash an object
            selectObject(element, objectType, objectId) {
                this.clearSelection();
                
                if (!element) return;
                
                this.currentSelection = { element, objectType, objectId };
                element.classList.add('selected-object');
                
                // Store original properties
                const original = {
                    stroke: element.getAttribute('stroke') || element.style.stroke || '#ffffff',
                    strokeWidth: element.getAttribute('stroke-width') || element.style.strokeWidth || '1',
                    filter: element.style.filter || 'none'
                };
                
                element._originalStyle = original;
                
                // Start flashing
                this.startFlashing(element, original);
            }

            startFlashing(element, original) {
                this.isFlashOn = false;
                
                this.flashInterval = setInterval(() => {
                    // Force style update without transitions
                    element.style.transition = 'none';
                    
                    if (this.isFlashOn) {
                        // Flash OFF - restore original
                        element.style.stroke = original.stroke;
                        element.style.strokeWidth = original.strokeWidth;
                        element.style.filter = original.filter;
                    } else {
                        // Flash ON - highlight
                        element.style.stroke = '#ffff00';
                        element.style.strokeWidth = '4';
                        element.style.filter = 'drop-shadow(0 0 8px #ffff00)';
                    }
                    
                    this.isFlashOn = !this.isFlashOn;
                }, 500); // 500ms for snappy flash
            }

            restoreOriginalStyle(element) {
                if (element._originalStyle) {
                    const orig = element._originalStyle;
                    element.style.stroke = orig.stroke;
                    element.style.strokeWidth = orig.strokeWidth;
                    element.style.filter = orig.filter;
                    delete element._originalStyle;
                }
            }

            // Re-select current selection (useful after redraws)
            restoreSelection() {
                if (this.currentSelection) {
                    const { objectType, objectId } = this.currentSelection;
                    const newElement = document.querySelector(`[data-type="${objectType}"][data-id="${objectId}"]`);
                    if (newElement) {
                        this.selectObject(newElement, objectType, objectId);
                    }
                }
            }

            getCurrentSelection() {
                return this.currentSelection;
            }
        }

        // ===== VISUALIZATION MANAGER MODULE =====
        class VisualizationManager {
            constructor() {
                this.colors = {
                    // Player planet happiness levels
                    PLAYER_PLANET_HAPPY: '#4caf50',      // >70% happiness
                    PLAYER_PLANET_MODERATE: '#8bc34a',   // 40-70% happiness  
                    PLAYER_PLANET_UNHAPPY: '#a5d6a7',   // <40% happiness
                    
                    // Other planets
                    ENEMY_PLANET: '#ff5722',
                    NEUTRAL_PLANET: '#9e9e9e',
                    
                    // Starbases
                    STARBASE: '#00d4ff',
                    ENEMY_STARBASE: '#f44336',
                    
                    // Ships
                    SHIP_PLAYER: '#00bcd4',
                    SHIP_ENEMY: '#e91e63',
                    
                    // Nebulas
                    NEBULA_FILL: 'rgba(128, 0, 128, 0.3)',
                    NEBULA_STROKE: '#800080',
                    
                    // UI elements
                    GRID_LINE: '#333333',
                    BORDER: '#555555',
                    SELECTION: '#ffff00'
                };
            }

            // Create consistent SVG elements with proper attributes
            createSVGElement(type, attributes = {}) {
                const element = document.createElementNS("http://www.w3.org/2000/svg", type);
                Object.entries(attributes).forEach(([key, value]) => {
                    element.setAttribute(key, value);
                });
                return element;
            }

            // Apply consistent styling based on object type and ownership
            getObjectColor(type, isOwned, isNeutral, additionalData = {}) {
                switch (type) {
                    case 'planet':
                        if (isOwned) {
                            const happiness = parseInt(additionalData.happiness, 10) || 0;
                            if (happiness > 70) return this.colors.PLAYER_PLANET_HAPPY;
                            else if (happiness >= 40) return this.colors.PLAYER_PLANET_MODERATE;
                            else return this.colors.PLAYER_PLANET_UNHAPPY;
                        } else if (isNeutral) {
                            return this.colors.NEUTRAL_PLANET;
                        } else {
                            return this.colors.ENEMY_PLANET;
                        }
                    case 'starbase':
                        return isOwned ? this.colors.STARBASE : this.colors.ENEMY_STARBASE;
                    case 'ship':
                        return isOwned ? this.colors.SHIP_PLAYER : this.colors.SHIP_ENEMY;
                    default:
                        return '#ffffff';
                }
            }
        }

        // ===== ENHANCED TABLE MANAGER MODULE =====
        class TableManager {
            constructor() {
                this.selectionManager = null;
                this.currentSort = { column: null, direction: 'asc' };
                this.filters = {};
            }

            setSelectionManager(selectionManager) {
                this.selectionManager = selectionManager;
            }

            // Create a complete table with header, body, and sorting
            createTable(containerId, data, columns, options = {}) {
                const container = document.getElementById(containerId);
                if (!container) return null;

                const table = this.createTableStructure(columns, options);
                const tbody = table.querySelector('.vgap-table-body');
                
                // Store column information on the table for sorting
                table.columnMapping = {};
                columns.forEach((column, index) => {
                    table.columnMapping[column.key] = index;
                });
                
                // Populate with data
                data.forEach(item => {
                    const row = this.createTableRow(item, columns, options);
                    tbody.appendChild(row);
                });

                container.innerHTML = '';
                container.appendChild(table);
                
                // Add scroll synchronization between header and body
                this.setupScrollSync(table);
                
                return table;
            }

            setupScrollSync(table) {
                const header = table.querySelector('.vgap-table-header');
                const body = table.querySelector('.vgap-table-body');
                
                if (!header || !body) return;
                
                // Make sure the header can scroll horizontally
                header.style.overflowX = 'hidden'; // Hide scrollbar but allow programmatic scrolling
                header.style.whiteSpace = 'nowrap';
                
                // Simple scroll synchronization that works with sticky positioning
                body.addEventListener('scroll', () => {
                    // Synchronize horizontal scroll position
                    header.scrollLeft = body.scrollLeft;
                });
                
                // Add enhanced sticky column support for very wide tables
                this.setupStickyColumns(table);
            }
            
            setupStickyColumns(table) {
                const stickyColumns = table.querySelectorAll('.sticky-column');
                if (stickyColumns.length === 0) return;
                
                // Simple CSS sticky positioning - let the browser handle it
                stickyColumns.forEach(col => {
                    col.style.position = 'sticky';
                    col.style.left = '0px';
                    col.style.zIndex = col.classList.contains('vgap-table-header-cell') ? '150' : '100';
                });
                
                // Sticky columns setup completed
            }
            
            // Complex overlay methods removed - reverting to simple CSS sticky approach

            createTableStructure(columns, options = {}) {
                const table = document.createElement('div');
                table.className = `vgap-table ${options.variant || ''}`;

                // Create header
                const header = document.createElement('div');
                header.className = 'vgap-table-header';
                
                const headerRow = document.createElement('div');
                headerRow.className = 'vgap-table-header-row';

                columns.forEach((column, index) => {
                    const headerCell = document.createElement('div');
                    let cellClass = `vgap-table-cell vgap-table-header-cell ${column.width || 'col-auto'} ${column.align || 'text-left'}`;
                    
                    // Make first column (ID) sticky
                    if (index === 0) {
                        cellClass += ' sticky-column';
                    }
                    
                    headerCell.className = cellClass;
                    headerCell.textContent = column.header;
                    headerCell.style.cursor = 'pointer';
                    headerCell.addEventListener('click', () => this.handleSort(column.key, table));
                    headerRow.appendChild(headerCell);
                });

                header.appendChild(headerRow);
                table.appendChild(header);

                // Create body
                const body = document.createElement('div');
                body.className = 'vgap-table-body';
                table.appendChild(body);

                // Set up sticky columns using simple CSS
                this.setupStickyColumns(table);
                
                // Set up scroll synchronization
                this.setupScrollSync(table);

                return table;
            }

            createTableRow(data, columns, options = {}) {
                const row = document.createElement('div');
                row.className = 'vgap-table-row';
                row.setAttribute('data-type', options.objectType || 'item');
                row.setAttribute('data-id', data.id);

                // Add resource highlighting for starbase candidates and resource-rich planets/starbases
                if (options.resourceRich && options.resourceRich.includes(data.id)) {
                    row.classList.add('resource-rich-highlight');
                }

                columns.forEach((column, index) => {
                    const cell = this.createTableCell(data, column, index);
                    row.appendChild(cell);
                });

                // Add row selection handler
                row.addEventListener('click', () => this.handleRowSelection(row, data, options));

                return row;
            }

            createTableCell(data, column, columnIndex = -1) {
            }
            
            setupRowHeightSync(table, stickyOverlay) {
                if (!window.ResizeObserver) return;
                
                const rows = table.querySelectorAll('.vgap-table-row');
                const resizeObserver = new ResizeObserver(() => {
                    // Debounce the height sync to avoid too many updates
                    clearTimeout(this.heightSyncTimeout);
                    this.heightSyncTimeout = setTimeout(() => {
                        this.syncOverlayHeights(table, stickyOverlay);
                    }, 50);
                });
                
                // Observe all table rows for height changes
                rows.forEach(row => {
                    resizeObserver.observe(row);
                });
            }
            
            syncOverlayHeights(table, stickyOverlay) {
                const tbody = table.querySelector('.vgap-table-body');
                if (!tbody) return;
                
                const rows = tbody.querySelectorAll('.vgap-table-row');
                const overlayCells = stickyOverlay.querySelectorAll('.sticky-overlay-cell');
                
                let totalHeight = 0;
                rows.forEach((row, index) => {
                    const overlayCell = overlayCells[index];
                    if (overlayCell) {
                        const actualHeight = row.offsetHeight || 30;
                        overlayCell.style.height = actualHeight + 'px';
                        overlayCell.style.minHeight = actualHeight + 'px';
                        totalHeight += actualHeight;
                    }
                });
                
                stickyOverlay.style.height = totalHeight + 'px';
            }
            
            updateStickyCellBackground(stickyCell, row) {
                if (row.classList.contains('selected')) {
                    stickyCell.style.background = 'rgba(0, 212, 255, 0.6)';
                } else if (row.classList.contains('resource-rich-highlight')) {
                    stickyCell.style.background = 'rgba(160, 120, 255, 0.3)';
                } else {
                    stickyCell.style.background = 'rgba(0, 0, 0, 0.95)';
                }
            }
            
            setupRowSelectionSync(table, stickyOverlay) {
                // Watch for changes in row selection
                const observer = new MutationObserver((mutations) => {
                    mutations.forEach((mutation) => {
                        if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
                            const row = mutation.target;
                            const dataId = row.getAttribute('data-id');
                            const stickyCell = stickyOverlay.querySelector(`[data-row-id="${dataId}"]`);
                            
                            if (stickyCell) {
                                this.updateStickyCellBackground(stickyCell, row);
                            }
                        }
                    });
                });
                
                // Observe all table rows for class changes
                const rows = table.querySelectorAll('.vgap-table-row');
                rows.forEach(row => {
                    observer.observe(row, { attributes: true, attributeFilter: ['class'] });
                });
            }
            
            updateStickyColumnVisibility(table, stickyOverlay, scrollContainer) {
                const scrollTop = scrollContainer.scrollTop;
                stickyOverlay.style.transform = `translateY(-${scrollTop}px)`;
            }

            createTableStructure(columns, options = {}) {
                const table = document.createElement('div');
                table.className = `vgap-table ${options.variant || ''}`;

                // Create header
                const header = document.createElement('div');
                header.className = 'vgap-table-header';
                
                const headerRow = document.createElement('div');
                headerRow.className = 'vgap-table-header-row';

                columns.forEach((column, index) => {
                    const headerCell = document.createElement('div');
                    let cellClass = `vgap-table-cell vgap-table-header-cell ${column.width || 'col-auto'} ${column.align || 'text-left'}`;
                    
                    // Make first column (ID) sticky
                    if (index === 0) {
                        cellClass += ' sticky-column';
                    }
                    
                    headerCell.className = cellClass;
                    headerCell.textContent = column.title;
                    headerCell.setAttribute('data-column-key', column.key);
                    
                    if (column.sortable !== false) {
                        headerCell.classList.add('sortable');
                        headerCell.addEventListener('click', () => {
                            this.handleSort(column.key, table);
                        });
                    }

                    headerRow.appendChild(headerCell);
                });

                header.appendChild(headerRow);
                table.appendChild(header);

                // Create body
                const tbody = document.createElement('div');
                tbody.className = 'vgap-table-body';
                table.appendChild(tbody);

                return table;
            }

            createTableRow(data, columns, options = {}) {
                const row = document.createElement('div');
                row.className = 'vgap-table-row';
                row.setAttribute('data-type', options.objectType || 'item');
                row.setAttribute('data-id', data.id);

                // Add resource highlighting for starbase candidates and resource-rich planets/starbases
                if ((options.objectType === 'starbase-candidate' || options.objectType === 'planet' || options.objectType === 'starbase') && data.shouldHighlight) {
                    row.classList.add('resource-rich-highlight');
                    
                    // Add detailed tooltip explaining why it's highlighted
                    let reason = '';
                    if (data.isResourceRich) {
                        if (data.isLocallyResourceRich) {
                            const breakdown = data.resourceBreakdown;
                            reason = `Locally Resource Rich: Dur ${breakdown.duranium.toLocaleString()}, Tri ${breakdown.tritanium.toLocaleString()}, Mol ${breakdown.molybdenum.toLocaleString()} (all 2000+)`;
                        } else {
                            const breakdown = data.resourceBreakdown;
                            const sources = [];
                            if (breakdown.duranium >= 2000) sources.push('Local Dur');
                            else if (breakdown.hasConnectedDur) sources.push('Connected Dur');
                            if (breakdown.tritanium >= 2000) sources.push('Local Tri');
                            else if (breakdown.hasConnectedTri) sources.push('Connected Tri');
                            if (breakdown.molybdenum >= 2000) sources.push('Local Mol');
                            else if (breakdown.hasConnectedMol) sources.push('Connected Mol');
                            reason = `Resource Rich via ${sources.join(', ')} (2000+ each resource locally or within 84LY)`;
                        }
                    } else if (data.isWellConnected) {
                        reason = `Well Connected: Full supply support from ${data.conn} nearby planets`;
                    }
                    row.setAttribute('title', reason);
                }

                columns.forEach((column, index) => {
                    const cell = this.createTableCell(data, column, index);
                    row.appendChild(cell);
                });

                // Add click handler for selection
                if (options.selectable !== false) {
                    row.addEventListener('click', () => {
                        this.handleRowSelection(row, data, options);
                    });
                    
                    // Add hover event listeners for starmap cross-highlighting
                    const objectType = options.objectType || 'item';
                    if (['planet', 'ship', 'starbase'].includes(objectType)) {
                        row.addEventListener('mouseenter', () => {
                            highlightStarmapObject(objectType, data.id, true);
                        });
                        
                        row.addEventListener('mouseleave', () => {
                            clearStarmapHighlights();
                        });
                    }
                }

                return row;
            }

            createTableCell(data, column, columnIndex = -1) {
                const cell = document.createElement('div');
                let cellClass = `vgap-table-cell ${column.width || 'col-auto'} ${column.align || 'text-left'}`;
                
                // Make first column (ID) sticky
                if (columnIndex === 0) {
                    cellClass += ' sticky-column';
                }
                
                cell.className = cellClass;

                // Add data-label attribute for mobile responsive labels
                cell.setAttribute('data-label', column.title || '');

                // Add semantic CSS class if specified
                if (column.cssClass) {
                    cell.classList.add(column.cssClass);
                }

                const value = this.getNestedValue(data, column.key);
                let formattedValue;
                
                // Check if column has a custom formatter function
                if (column.formatter && typeof column.formatter === 'function') {
                    formattedValue = column.formatter.call(this, value, data);
                } else {
                    formattedValue = this.formatCellValue(value, column.format, data);
                }
                
                // Handle different cell types
                if (column.format === 'status') {
                    cell.innerHTML = this.createStatusCell(value, formattedValue);
                } else if (column.format === 'progress') {
                    cell.innerHTML = this.createProgressCell(value);
                } else if (typeof formattedValue === 'object' && formattedValue.content !== undefined) {
                    // Handle new format with content and sortValue
                    cell.textContent = formattedValue.content;
                    if (formattedValue.sortValue !== undefined) {
                        cell.setAttribute('data-sort', formattedValue.sortValue);
                    }
                } else if (formattedValue && (formattedValue.includes('<div') || formattedValue.includes('<span'))) {
                    // Allow HTML content for custom formatters that return HTML (like progress bars and colored text)
                    cell.innerHTML = formattedValue;
                } else {
                    cell.textContent = formattedValue;
                }

                // Apply conditional styling
                if (column.colorize) {
                    cell.classList.add(this.getCellColorClass(value, column.colorize));
                }

                return cell;
            }

            createStatusCell(value, text) {
                const statusClass = this.getStatusClass(value);
                return `<span class="status-indicator ${statusClass}"></span>${text}`;
            }

            createProgressCell(value) {
                const percentage = Math.max(0, Math.min(100, value || 0));
                return `
                    <div style="width: 100%; background: rgba(255,255,255,0.1); height: 8px; border-radius: 4px;">
                        <div style="width: ${percentage}%; background: #4CAF50; height: 100%; border-radius: 4px;"></div>
                    </div>
                    <span style="font-size: 10px; margin-left: 4px;">${percentage}%</span>
                `;
            }

            handleSort(columnKey, table) {
                const tbody = table.querySelector('.vgap-table-body');
                const rows = Array.from(tbody.children);
                
                // Update sort state
                if (this.currentSort.column === columnKey) {
                    this.currentSort.direction = this.currentSort.direction === 'asc' ? 'desc' : 'asc';
                } else {
                    this.currentSort.column = columnKey;
                    this.currentSort.direction = 'asc';
                }

                // Update header styling
                table.querySelectorAll('.vgap-table-header-cell').forEach(cell => {
                    cell.classList.remove('sorted-asc', 'sorted-desc');
                });

                // Find the correct header cell using data attribute
                const headerCell = table.querySelector(`.vgap-table-header-cell[data-column-key="${columnKey}"]`);
                if (headerCell) {
                    headerCell.classList.add(`sorted-${this.currentSort.direction}`);
                }

                // Get column index for value extraction
                const columnIndex = table.columnMapping ? table.columnMapping[columnKey] : -1;

                // Sort rows based on the actual data values
                rows.sort((a, b) => {
                    const aValue = this.getRowValueByColumn(a, columnKey, columnIndex);
                    const bValue = this.getRowValueByColumn(b, columnKey, columnIndex);
                    
                    let result = 0;
                    
                    // Handle numeric sorting
                    const aNum = this.parseNumericValue(aValue);
                    const bNum = this.parseNumericValue(bValue);
                    
                    if (!isNaN(aNum) && !isNaN(bNum)) {
                        result = aNum - bNum;
                    } else {
                        // String comparison for non-numeric values
                        const aStr = String(aValue).toLowerCase();
                        const bStr = String(bValue).toLowerCase();
                        if (aStr < bStr) result = -1;
                        else if (aStr > bStr) result = 1;
                    }
                    
                    return this.currentSort.direction === 'desc' ? -result : result;
                });

                // Rows sorted

                // Re-append sorted rows
                rows.forEach(row => tbody.appendChild(row));
            }

            handleRowSelection(row, data, options) {
                // Show the starmap panel when any row is selected
                showStarmapPanel();
                
                // Clear other selections from both old and new systems
                document.querySelectorAll('.vgap-table-row.selected, .table-row-selected').forEach(r => {
                    r.classList.remove('selected', 'table-row-selected');
                });
                clearStarmapSelections();
                
                row.classList.add('selected');
                
                // Highlight on starmap using multiple approaches for reliability
                const objectType = options.objectType;
                if (objectType && ['planet', 'ship', 'starbase'].includes(objectType)) {
                    // Attempting to highlight starmap object
                    
                    // Use global selection manager if available
                    if (window.selectionManager && svgElement) {
                        const element = svgElement.querySelector(`[data-type="${objectType}"][data-id="${data.id}"]`);
                        if (element) {
                            // Found starmap element, selecting via SelectionManager
                            window.selectionManager.selectObject(element, objectType, data.id);
                        } else {
                            console.warn('Starmap element not found:', `[data-type="${objectType}"][data-id="${data.id}"]`);
                        }
                    }
                    
                    // Also apply permanent highlighting and legacy functions
                    highlightStarmapObject(objectType, data.id, false);
                    highlightObjectOnStarmap(objectType, data.id);
                }
                
                // Call custom click handler
                if (options.onRowClick) {
                    options.onRowClick(data, options.objectType);
                }
            }

            // Utility methods
            getNestedValue(obj, path) {
                return path.split('.').reduce((current, key) => current?.[key], obj);
            }

            formatCellValue(value, format, data = {}) {
                if (value === null || value === undefined) return '';
                
                switch (format) {
                    case 'number':
                        return parseInt(value, 10).toLocaleString();
                    case 'decimal':
                        return parseFloat(value).toFixed(1);
                    case 'coordinates':
                        return `(${data.x || 0}, ${data.y || 0})`;
                    case 'percentage':
                        return `${Math.round(value)}%`;
                    case 'temperature':
                        const temp = parseInt(value, 10);
                        return isNaN(temp) ? '?' : `${temp}°`;
                    case 'happiness':
                        const happiness = parseInt(value, 10) || 0;
                        if (happiness > 70) return `${happiness}% 😊`;
                        else if (happiness >= 40) return `${happiness}% 😐`;
                        else return `${happiness}% 😞`;
                    case 'resources':
                        return `${parseInt(value, 10).toLocaleString()}kt`;
                    case 'population':
                        const popResult = this.formatPopulation(value);
                        return { 
                            content: popResult.display, 
                            sortValue: popResult.sortValue 
                        };
                    case 'status':
                        return this.getStatusText(value);
                    case 'boolean':
                        return value ? '✓' : '✗';
                    case 'starbase':
                        // Check for building starbase status first, then existing starbase
                        if (data.buildingstarbase) {
                            return '🚧 Building';
                        }
                        const hasStarbase = data.starbase || this.starbaseMap?.[data.id];
                        return hasStarbase ? '✓' : '✗';
                    case 'starbase_status':
                        // For Future Starbases table status column - only show Building status
                        if (data.buildingstarbase || value === true) {
                            return '🚧 Building';
                        }
                        return ''; // Show empty instead of "Planned"
                    case 'population_change':
                        const changeResult = this.formatPopulationChange(value);
                        return { 
                            content: changeResult.display, 
                            sortValue: changeResult.sortValue 
                        };
                    case 'tax_rate':
                        return `${parseInt(value, 10) || 0}%`;
                    case 'happiness':
                        const happyPoints = parseInt(value, 10) || 0;
                        if (happyPoints > 70) return `${happyPoints} 😊`;
                        else if (happyPoints >= 40) return `${happyPoints} 😐`;
                        else return `${happyPoints} 😞`;
                    case 'happiness_change':
                        const happyChange = parseInt(value, 10) || 0;
                        if (happyChange > 0) return `+${happyChange}`;
                        else if (happyChange < 0) return `${happyChange}`;
                        else return '0';
                    case 'truncate':
                        const text = value ? value.toString() : '';
                        return text.length > 12 ? text.substring(0, 12) + '...' : text;
                    case 'owner':
                        return this.getOwnerName(value, data);
                    case 'mass':
                        return `${parseInt(value, 10) || 0} kt`;
                    case 'fuel':
                        return `${parseInt(value, 10) || 0} kt`;
                    case 'planet_location':
                        return this.getPlanetAtLocation(data.x, data.y);
                    case 'weapons_beams':
                        return this.formatWeaponsDisplay(data, 'beams');
                    case 'weapons_torps':
                        return this.formatWeaponsDisplay(data, 'torps');
                    case 'planet_name':
                        return this.getPlanetNameForStarbase(data);
                    case 'connected':
                        // For starbases table, show simple connection count with emojis
                        if (typeof value === 'number') {
                            return value > 0 ? `🤝 ${value}` : '🤝 0';
                        }
                        // Fallback to complex connection display for other cases
                        return this.getConnectionDisplay(data);
                    case 'starbase_mission':
                        return this.getStarbaseMissionName(data.mission || 0);
                    case 'native_race':
                        return this.getNativeRaceName(value);
                    case 'native_government':
                        return this.getNativeGovernmentName(value);
                    case 'hull_name':
                        return this.getHullName(value);
                    default:
                        // Safe toString conversion with fallback
                        if (value === null || value === undefined) return '';
                        return String(value);
                }
            }

            // Helper methods for new formats
            getOwnerName(ownerId, data) {
                // Look up player username and race from players data using ownerid
                if (currentGameData && currentGameData.rst && ownerId) {
                    const playerId = parseInt(ownerId, 10);
                    
                    // Look up player by ID to get username and race
                    if (currentGameData.rst.players) {
                        const player = currentGameData.rst.players.find(p => parseInt(p.id, 10) === playerId);
                        if (player && player.username) {
                            // Also get race name if available
                            let raceInfo = '';
                            if (currentGameData.rst.races && player.raceid) {
                                const race = currentGameData.rst.races.find(r => parseInt(r.id, 10) === parseInt(player.raceid, 10));
                                if (race && race.adjective) {
                                    raceInfo = ` (${race.adjective})`;
                                }
                            }
                            return `${player.username}${raceInfo}`;
                        }
                    }
                    
                    // Fallback to generic player reference
                    return `Player ${playerId}`;
                }
                return 'Unknown';
            }

            formatPopulation(value) {
                const pop = parseInt(value, 10);
                
                // Handle unknown/invalid values
                if (isNaN(pop) || pop < 0) {
                    return { display: '?', sortValue: -1 };
                }
                
                // Multiply by 100 to get actual population (VGAP stores in hundreds)
                const actualPop = pop * 100;
                
                // Format based on magnitude
                let display;
                if (actualPop >= 1000000) {
                    display = `${(actualPop / 1000000).toFixed(1)}M`;
                } else if (actualPop >= 1000) {
                    display = `${(actualPop / 1000).toFixed(1)}k`;
                } else {
                    display = actualPop.toString();
                }
                
                return { display, sortValue: actualPop };
            }

            formatPopulationChange(value) {
                const change = parseInt(value, 10) || 0;
                
                if (change === 0) return { display: '0', sortValue: 0 };
                
                // Multiply by 100 to get actual population change (VGAP stores in hundreds)
                const actualChange = change * 100;
                
                const sign = actualChange > 0 ? '+' : '';
                const absChange = Math.abs(actualChange);
                
                // Format based on magnitude
                let display;
                if (absChange >= 1000000) {
                    display = `${sign}${(actualChange / 1000000).toFixed(1)}M`;
                } else if (absChange >= 1000) {
                    display = `${sign}${(actualChange / 1000).toFixed(1)}k`;
                } else {
                    display = `${sign}${actualChange}`;
                }
                
                return { display, sortValue: actualChange };
            }

            getPlanetAtLocation(x, y) {
                // Look up actual planet at this location from global game data
                if (currentGameData && currentGameData.rst && currentGameData.rst.planets) {
                    const planet = currentGameData.rst.planets.find(p => 
                        Math.abs(parseInt(p.x, 10) - parseInt(x, 10)) < 0.1 && 
                        Math.abs(parseInt(p.y, 10) - parseInt(y, 10)) < 0.1
                    );
                    return planet ? (planet.name || `Planet ${planet.id}`) : 'Deep Space';
                }
                return 'Deep Space';
            }

            formatWeaponsDisplay(shipData, weaponType) {
                if (weaponType === 'beams') {
                    const count = shipData.beams || 0;
                    if (count === 0) return '0';
                    const weaponInfo = this.getWeaponInfo('beams', shipData.beamid);
                    return weaponInfo ? `${count}x ${weaponInfo.name.substring(0, 8)}` : `${count}x Beam`;
                } else if (weaponType === 'torps') {
                    const count = shipData.ammo || shipData.torps || 0;
                    if (count === 0) return '0';
                    const weaponInfo = this.getWeaponInfo('torpedos', shipData.torpedoid);
                    return weaponInfo ? `${count}x ${weaponInfo.name.substring(0, 8)}` : `${count}x Torp`;
                }
                return '0';
            }

            getPlanetNameForStarbase(starbaseData) {
                // Look up the actual planet name for this starbase
                if (currentGameData && currentGameData.rst && currentGameData.rst.planets && starbaseData.planetid) {
                    const planet = currentGameData.rst.planets.find(p => p.id == starbaseData.planetid);
                    return planet ? (planet.name || `Planet ${planet.id}`) : `Planet ${starbaseData.planetid}`;
                }
                return `Planet ${starbaseData.planetid || 'Unknown'}`;
            }

            createFutureStarbasesTable(containerId, starbaseRequirements) {
                const columns = [
                    { 
                        key: 'id', 
                        title: 'ID', 
                        sortable: true, 
                        width: 'col-xs',
                        align: 'text-right',
                        format: 'number'
                    },
                    { 
                        key: 'name', 
                        title: 'Planet', 
                        sortable: true, 
                        width: 'col-lg',
                        align: 'text-left',
                        cssClass: 'vgap-planet-name',
                        formatter: this.formatPlanetName 
                    },
                    { 
                        key: 'x', 
                        title: 'X', 
                        sortable: true, 
                        width: 'col-xs',
                        align: 'text-center',
                        cssClass: 'vgap-coordinate',
                        formatter: this.formatCoordinate 
                    },
                    { 
                        key: 'y', 
                        title: 'Y', 
                        sortable: true, 
                        width: 'col-xs',
                        align: 'text-center', 
                        cssClass: 'vgap-coordinate',
                        formatter: this.formatCoordinate 
                    },
                    { 
                        key: 'clans', 
                        title: 'Col', 
                        sortable: true, 
                        width: 'col-sm',
                        align: 'text-right',
                        format: 'population' 
                    },
                    { 
                        key: 'readiness', 
                        title: 'Ready', 
                        sortable: true, 
                        width: 'col-md',
                        align: 'text-center',
                        formatter: this.formatReadinessProgress 
                    },
                    { 
                        key: 'duranium_req', 
                        title: 'Dur Need', 
                        sortable: true, 
                        width: 'col-sm',
                        align: 'text-right',
                        formatter: this.formatResourceNeed 
                    },
                    { 
                        key: 'tritanium_req', 
                        title: 'Tri Need', 
                        sortable: true, 
                        width: 'col-sm',
                        align: 'text-right',
                        formatter: this.formatResourceNeed 
                    },
                    { 
                        key: 'molybdenum_req', 
                        title: 'Mol Need', 
                        sortable: true, 
                        width: 'col-sm',
                        align: 'text-right',
                        formatter: this.formatResourceNeed 
                    },
                    { 
                        key: 'megacredits_req', 
                        title: 'MC Need', 
                        sortable: true, 
                        width: 'col-sm',
                        align: 'text-right',
                        formatter: this.formatResourceNeed 
                    },
                    { 
                        key: 'conn', 
                        title: 'Conn', 
                        sortable: true, 
                        width: 'col-sm',
                        align: 'text-center',
                        cssClass: 'vgap-connection',
                        formatter: this.formatConnections 
                    },
                    { 
                        key: 'status', 
                        title: 'Status', 
                        sortable: true, 
                        width: 'col-md',
                        align: 'text-center',
                        format: 'starbase_status'
                    }
                ];

                // Transform starbase requirements data to include planet info and resource needs
                const tableData = starbaseRequirements.map(req => {
                    const planet = req.planet;
                    
                    // Calculate total resources (surface + ground)
                    const totalDur = (planet.duranium || 0) + (planet.groundduranium || 0);
                    const totalTri = (planet.tritanium || 0) + (planet.groundtritanium || 0);
                    const totalMol = (planet.molybdenum || 0) + (planet.groundmolybdenum || 0);
                    
                    // Check if planet has 2000+ of each resource locally
                    const hasAbundantDuranium = totalDur >= 2000;
                    const hasAbundantTritanium = totalTri >= 2000;
                    const hasAbundantMolybdenum = totalMol >= 2000;
                    const isLocallyResourceRich = hasAbundantDuranium && hasAbundantTritanium && hasAbundantMolybdenum;
                    
                    // Check connectivity to abundant resource sources within 84LY
                    let hasConnectedDuranium = hasAbundantDuranium;
                    let hasConnectedTritanium = hasAbundantTritanium;
                    let hasConnectedMolybdenum = hasAbundantMolybdenum;
                    
                    if (currentGameData && currentGameData.rst && currentGameData.rst.planets && !isLocallyResourceRich) {
                        const planets = currentGameData.rst.planets;
                        
                        planets.forEach(nearbyPlanet => {
                            if (nearbyPlanet.id === planet.id) return; // Skip self
                            
                            const distance = Math.sqrt(
                                Math.pow(nearbyPlanet.x - planet.x, 2) + 
                                Math.pow(nearbyPlanet.y - planet.y, 2)
                            );
                            
                            if (distance <= 84) {
                                const nearbyDur = (nearbyPlanet.duranium || 0) + (nearbyPlanet.groundduranium || 0);
                                const nearbyTri = (nearbyPlanet.tritanium || 0) + (nearbyPlanet.groundtritanium || 0);
                                const nearbyMol = (nearbyPlanet.molybdenum || 0) + (nearbyPlanet.groundmolybdenum || 0);
                                
                                if (nearbyDur >= 2000) hasConnectedDuranium = true;
                                if (nearbyTri >= 2000) hasConnectedTritanium = true;
                                if (nearbyMol >= 2000) hasConnectedMolybdenum = true;
                            }
                        });
                    }
                    
                    // Define thresholds for "resource rich" based on local abundance OR connectivity
                    const isResourceRich = isLocallyResourceRich || (hasConnectedDuranium && hasConnectedTritanium && hasConnectedMolybdenum);
                    const isWellConnected = req.hasFullSupport && req.connectionCount >= 2; // Well connected with full support
                    
                    return {
                        ...planet,
                        readiness: req.avgCompletion,
                        duranium_req: { current: req.current.duranium, missing: req.missing.duranium, percent: req.percentages.duranium },
                        tritanium_req: { current: req.current.tritanium, missing: req.missing.tritanium, percent: req.percentages.tritanium },
                        molybdenum_req: { current: req.current.molybdenum, missing: req.missing.molybdenum, percent: req.percentages.molybdenum },
                        megacredits_req: { current: req.current.megacredits, missing: req.missing.megacredits, percent: req.percentages.megacredits },
                        conn: req.connectionCount,
                        status: req.isBuildingStarbase,
                        originalData: req,
                        // Resource highlighting flags
                        isResourceRich: isResourceRich,
                        isLocallyResourceRich: isLocallyResourceRich,
                        isWellConnected: isWellConnected,
                        shouldHighlight: isResourceRich || isWellConnected,
                        totalResources: totalDur + totalTri + totalMol,
                        resourceBreakdown: {
                            duranium: totalDur,
                            tritanium: totalTri,
                            molybdenum: totalMol,
                            hasConnectedDur: hasConnectedDuranium,
                            hasConnectedTri: hasConnectedTritanium,
                            hasConnectedMol: hasConnectedMolybdenum
                        }
                    };
                });

                return this.createTable(containerId, tableData, columns, {
                    objectType: 'planet',  // Changed from 'starbase-candidate' to 'planet' to match starmap elements
                    selectable: true,
                    variant: 'compact'
                });
            }

            formatReadiness(value) {
                if (value >= 100) return '✅ 100%';
                if (value >= 75) return `🟢 ${Math.round(value)}%`;
                if (value >= 50) return `🟡 ${Math.round(value)}%`;
                if (value >= 25) return `🟠 ${Math.round(value)}%`;
                return `🔴 ${Math.round(value)}%`;
            }

            formatReadinessProgress(value, data) {
                const percent = Math.round(value);
                let color;
                
                if (value >= 100) { color = '#00ff00'; }
                else if (value >= 75) { color = '#90ee90'; }
                else if (value >= 50) { color = '#ffff00'; }
                else if (value >= 25) { color = '#ffa500'; }
                else { color = '#ff4444'; }
                
                return `<div style="display: flex; align-items: center; gap: 6px;">
                    <div style="background: #333; border-radius: 8px; width: 50px; height: 14px; overflow: hidden;">
                        <div style="background: ${color}; height: 100%; width: ${percent}%; transition: width 0.3s ease;"></div>
                    </div>
                    <span style="font-size: 11px; color: ${color};">${percent}%</span>
                </div>`;
            }

            formatResourceNeed(resourceData, data) {
                if (!resourceData || typeof resourceData !== 'object') return '—';
                
                const { current, missing } = resourceData;
                
                if (missing === 0) {
                    // Have enough - show in green
                    return `<span style="color: #00ff00;">${missing} [${current}]</span>`;
                } else {
                    // Need more - show missing amount in red with current amount
                    return `<span style="color: #ff4444;">${missing} [${current}]</span>`;
                }
            }

            formatConnections(value, data) {
                const req = data.originalData;
                if (req && req.hasFullSupport) {
                    return `✅ ${value}`;
                } else if (value > 0) {
                    return `🟡 ${value}`;
                }
                return `❌ ${value}`;
            }

            formatBuildStatus(value, data) {
                // Check buildingstarbase field first
                if (data && data.buildingstarbase) {
                    return '🏗️ Building';
                }
                // Fallback to the original value check
                return value ? '🏗️ Building' : '⏳ Planned';
            }

            formatPlanetName(value, data) {
                const name = value || data.name || `Planet ${data.id}`;
                return name.length > 14 ? name.substring(0, 14) + '...' : name;
            }

            getConnectionDisplay(starbaseData) {
                // Calculate actual starbase connectedness to nearby resource-rich planets
                if (currentGameData && currentGameData.rst && currentGameData.rst.planets) {
                    const planets = currentGameData.rst.planets;
                    const starbaseX = starbaseData.x || 0;
                    const starbaseY = starbaseData.y || 0;
                    
                    let connections = 0;
                    planets.forEach(planet => {
                        const distance = Math.sqrt(
                            Math.pow(planet.x - starbaseX, 2) + 
                            Math.pow(planet.y - starbaseY, 2)
                        );
                        
                        // Check if within 84 LY and has significant resources
                        if (distance <= 84 && planet.id !== starbaseData.planetid) {
                            const totalResources = (planet.duranium || 0) + 
                                                 (planet.tritanium || 0) + 
                                                 (planet.molybdenum || 0);
                            if (totalResources > 100) { // Threshold for "resource-rich"
                                connections++;
                            }
                        }
                    });
                    
                    return connections > 0 ? `🤝 ${connections}` : '🤝 0';
                }
                return '🤝 0';
            }

            getStarbaseMissionName(missionId) {
                const missions = {
                    0: 'None',
                    1: 'Refuel',
                    2: 'Maximize Defense',
                    3: 'Load Torps',
                    4: 'Unload Freighters',
                    5: 'Repair Base',
                    6: 'Force Surrender'
                };
                return missions[missionId] || `Mission ${missionId}`;
            }

            getNativeRaceName(nativeType) {
                const nativeRaces = {
                    0: 'None',
                    1: 'Humanoid',
                    2: 'Bovinoid',
                    3: 'Reptilian', 
                    4: 'Avian',
                    5: 'Amorphous',
                    6: 'Insectoid',
                    7: 'Amphibian',
                    8: 'Ghipsoldal',
                    9: 'Siliconoid'
                };
                return nativeRaces[nativeType] || `Race ${nativeType}`;
            }

            getNativeGovernmentName(governmentId) {
                const governments = {
                    0: 'None',
                    1: 'Anarchy',
                    2: 'Pre-Tribal',
                    3: 'Early-Tribal',
                    4: 'Tribal',
                    5: 'Feudal',
                    6: 'Monarchy',
                    7: 'Representative',
                    8: 'Participatory',
                    9: 'Unity'
                };
                return governments[governmentId] || `Gov ${governmentId}`;
            }

            getHullName(hullId) {
                // Look up hull name from game data
                if (currentGameData && currentGameData.rst && currentGameData.rst.hulls) {
                    const hull = currentGameData.rst.hulls.find(h => h.id == hullId);
                    if (hull) {
                        return hull.name.length > 15 ? hull.name.substring(0, 15) + '...' : hull.name;
                    }
                }
                return `Hull ${hullId}`;
            }

            getWeaponInfo(type, weaponId) {
                // This should lookup actual weapon specs from game data
                // Placeholder implementation
                return null;
            }

            getCellColorClass(value, colorizeRule) {
                switch (colorizeRule) {
                    case 'temperature':
                        const temp = parseInt(value, 10) || 0;
                        if (temp > 85) return 'vgap-temp-extreme';
                        else if (temp > 60) return 'vgap-temp-hot';
                        else if (temp >= 15) return 'vgap-temp-moderate';
                        else if (temp >= 0) return 'vgap-temp-cool';
                        else return 'vgap-temp-cold';
                    case 'happiness':
                        const happiness = parseInt(value, 10) || 0;
                        if (happiness > 70) return 'vgap-happiness-high';
                        else if (happiness >= 40) return 'vgap-happiness-medium';
                        else return 'vgap-happiness-low';
                    case 'resources':
                        const amount = parseInt(value, 10) || 0;
                        if (amount > 5000) return 'vgap-resource-abundant';
                        else if (amount > 1000) return 'vgap-resource-good';
                        else if (amount > 100) return 'vgap-resource-moderate';
                        else if (amount > 10) return 'vgap-resource-low';
                        else return 'vgap-resource-critical';
                    case 'starbase':
                        return value ? 'vgap-starbase-yes' : 'vgap-starbase-no';
                    case 'fuel':
                        const fuel = parseInt(value, 10) || 0;
                        if (fuel > 200) return 'vgap-fuel-full';
                        else if (fuel > 100) return 'vgap-fuel-good';
                        else if (fuel > 20) return 'vgap-fuel-low';
                        else return 'vgap-fuel-critical';
                    case 'damage':
                        const damage = parseInt(value, 10) || 0;
                        if (damage === 0) return 'vgap-damage-none';
                        else if (damage < 25) return 'vgap-damage-light';
                        else if (damage < 75) return 'vgap-damage-moderate';
                        else return 'vgap-damage-heavy';
                    case 'tech':
                        const tech = parseInt(value, 10) || 0;
                        if (tech >= 10) return 'vgap-tech-max';
                        else if (tech >= 7) return 'vgap-tech-high';
                        else if (tech >= 4) return 'vgap-tech-medium';
                        else if (tech >= 1) return 'vgap-tech-low';
                        else return 'vgap-tech-none';
                    case 'positive-negative':
                        return value > 0 ? 'cell-positive' : 'cell-negative';
                    default:
                        return '';
                }
            }

            getStatusClass(value) {
                if (value > 70) return 'status-good';
                else if (value >= 40) return 'status-warning';
                else return 'status-bad';
            }

            getStatusText(value) {
                if (value > 70) return 'Good';
                else if (value >= 40) return 'Moderate';
                else return 'Poor';
            }

            getColumnIndex(table, columnKey) {
                // Use the stored column mapping for reliable column lookup
                return table.columnMapping ? table.columnMapping[columnKey] : -1;
            }

            getRowValueByColumn(row, columnKey, columnIndex) {
                const cells = row.querySelectorAll('.vgap-table-cell');
                if (columnIndex >= 0 && columnIndex < cells.length) {
                    const cell = cells[columnIndex];
                    // Check for data-sort attribute first (for formatted numbers)
                    if (cell && cell.hasAttribute('data-sort')) {
                        return parseFloat(cell.getAttribute('data-sort'));
                    }
                    // Fall back to text content
                    return cell?.textContent?.trim() || '';
                }
                return '';
            }

            getRowValue(row, columnKey) {
                const table = row.closest('.vgap-table');
                const columnIndex = this.getColumnIndex(table, columnKey);
                return this.getRowValueByColumn(row, columnKey, columnIndex);
            }

            // Parse numeric values from text for proper sorting
            parseNumericValue(value) {
                if (typeof value === 'number') return value;
                const str = String(value).replace(/[^\d.-]/g, ''); // Remove non-numeric chars except decimal and minus
                return parseFloat(str);
            }

            // Filter functionality
            addFilter(columnKey, filterValue) {
                this.filters[columnKey] = filterValue;
            }

            clearFilters() {
                this.filters = {};
            }

            applyFilters(table) {
                const tbody = table.querySelector('.vgap-table-body');
                const rows = tbody.querySelectorAll('.vgap-table-row');
                
                rows.forEach(row => {
                    let visible = true;
                    
                    Object.entries(this.filters).forEach(([columnKey, filterValue]) => {
                        const cellValue = this.getRowValue(row, columnKey).toLowerCase();
                        const filter = filterValue.toLowerCase();
                        
                        if (!cellValue.includes(filter)) {
                            visible = false;
                        }
                    });
                    
                    row.style.display = visible ? 'flex' : 'none';
                });
            }

            // Helper function to calculate resource richness for planets
            calculateResourceRichness(planet) {
                // Calculate total resources (surface + ground)
                const totalDur = (planet.duranium || 0) + (planet.groundduranium || 0);
                const totalTri = (planet.tritanium || 0) + (planet.groundtritanium || 0);
                const totalMol = (planet.molybdenum || 0) + (planet.groundmolybdenum || 0);
                
                // Check if planet has 2000+ of each resource locally
                const hasAbundantDuranium = totalDur >= 2000;
                const hasAbundantTritanium = totalTri >= 2000;
                const hasAbundantMolybdenum = totalMol >= 2000;
                const isLocallyResourceRich = hasAbundantDuranium && hasAbundantTritanium && hasAbundantMolybdenum;
                
                // Check connectivity to abundant resource sources within 84LY
                let hasConnectedDuranium = hasAbundantDuranium;
                let hasConnectedTritanium = hasAbundantTritanium;
                let hasConnectedMolybdenum = hasAbundantMolybdenum;
                
                if (currentGameData && currentGameData.rst && currentGameData.rst.planets && !isLocallyResourceRich) {
                    const planets = currentGameData.rst.planets;
                    
                    planets.forEach(nearbyPlanet => {
                        if (nearbyPlanet.id === planet.id) return; // Skip self
                        
                        const distance = Math.sqrt(
                            Math.pow(nearbyPlanet.x - planet.x, 2) + 
                            Math.pow(nearbyPlanet.y - planet.y, 2)
                        );
                        
                        if (distance <= 84) {
                            const nearbyDur = (nearbyPlanet.duranium || 0) + (nearbyPlanet.groundduranium || 0);
                            const nearbyTri = (nearbyPlanet.tritanium || 0) + (nearbyPlanet.groundtritanium || 0);
                            const nearbyMol = (nearbyPlanet.molybdenum || 0) + (nearbyPlanet.groundmolybdenum || 0);
                            
                            if (nearbyDur >= 2000) hasConnectedDuranium = true;
                            if (nearbyTri >= 2000) hasConnectedTritanium = true;
                            if (nearbyMol >= 2000) hasConnectedMolybdenum = true;
                        }
                    });
                }
                
                // Define thresholds for "resource rich" based on local abundance OR connectivity
                const isResourceRich = isLocallyResourceRich || (hasConnectedDuranium && hasConnectedTritanium && hasConnectedMolybdenum);
                
                return {
                    isResourceRich,
                    isLocallyResourceRich,
                    shouldHighlight: isResourceRich,
                    totalResources: totalDur + totalTri + totalMol,
                    resourceBreakdown: {
                        duranium: totalDur,
                        tritanium: totalTri,
                        molybdenum: totalMol,
                        hasConnectedDur: hasConnectedDuranium,
                        hasConnectedTri: hasConnectedTritanium,
                        hasConnectedMol: hasConnectedMolybdenum
                    }
                };
            }

            // Quick table creation methods for common VGAP data types with enhanced semantic styling
            createPlanetsTable(containerId, planets, starbases = [], showOwner = false) {
                const starbaseMap = {};
                starbases.forEach(sb => starbaseMap[sb.planetid] = sb);
                
                // Store starbaseMap on the TableManager instance for use in formatting
                this.starbaseMap = starbaseMap;

                // Define base columns (without owner)
                const baseColumns = [
                    { 
                        key: 'id', 
                        title: 'ID', 
                        width: 'col-xs', 
                        align: 'text-right', 
                        format: 'number' 
                    },
                    { 
                        key: 'name', 
                        title: 'Name', 
                        width: 'col-lg',
                        align: 'text-left',
                        cssClass: 'vgap-planet-name'
                    }
                ];

                // Add owner column if requested
                const ownerColumn = { 
                    key: 'ownerid', 
                    title: 'Owner', 
                    width: 'col-md',
                    align: 'text-left',
                    cssClass: 'vgap-owner',
                    format: 'owner'
                };

                // Remaining columns
                const remainingColumns = [
                    { 
                        key: 'x', 
                        title: 'Loc', 
                        width: 'col-sm', 
                        align: 'text-center',
                        cssClass: 'vgap-coordinates',
                        format: 'coordinates'
                    },
                    { 
                        key: 'friendlycode', 
                        title: 'FC', 
                        width: 'col-sm', 
                        align: 'text-center',
                        cssClass: 'vgap-friendly-code'
                    },
                    { 
                        key: 'temp', 
                        title: 'Temp', 
                        width: 'col-sm', 
                        align: 'text-center',
                        format: 'temperature',
                        colorize: 'temperature'
                    },
                    { 
                        key: 'clans', 
                        title: 'Col', 
                        width: 'col-md', 
                        align: 'text-right',
                        format: 'population', 
                        colorize: 'resources' 
                    },
                    { 
                        key: 'nativeclans', 
                        title: 'Nat', 
                        width: 'col-md', 
                        align: 'text-right',
                        format: 'population', 
                        colorize: 'resources' 
                    },
                    { 
                        key: 'nativetype', 
                        title: 'Race', 
                        width: 'col-md', 
                        align: 'text-left',
                        format: 'native_race',
                        cssClass: 'vgap-native-race'
                    },
                    { 
                        key: 'nativegovernment', 
                        title: 'Gov', 
                        width: 'col-md', 
                        align: 'text-left',
                        format: 'native_government',
                        cssClass: 'vgap-native-gov'
                    },
                    { 
                        key: 'factories', 
                        title: 'Fac', 
                        width: 'col-sm', 
                        align: 'text-right',
                        format: 'number',
                        colorize: 'resources'
                    },
                    { 
                        key: 'mines', 
                        title: 'Min', 
                        width: 'col-sm', 
                        align: 'text-right',
                        format: 'number',
                        colorize: 'resources'
                    },
                    { 
                        key: 'starbase', 
                        title: 'SB', 
                        width: 'col-xs', 
                        align: 'text-center',
                        format: 'starbase',
                        colorize: 'starbase'
                    },
                    { 
                        key: 'duranium', 
                        title: 'Dur', 
                        width: 'col-sm', 
                        align: 'text-right',
                        format: 'number',
                        colorize: 'resources'
                    },
                    { 
                        key: 'tritanium', 
                        title: 'Tri', 
                        width: 'col-sm', 
                        align: 'text-right',
                        format: 'number',
                        colorize: 'resources'
                    },
                    { 
                        key: 'molybdenum', 
                        title: 'Mol', 
                        width: 'col-sm', 
                        align: 'text-right',
                        format: 'number',
                        colorize: 'resources'
                    },
                    { 
                        key: 'densityneutronium', 
                        title: 'N⬇', 
                        width: 'col-xs', 
                        align: 'text-right',
                        format: 'number'
                    },
                    { 
                        key: 'densityduranium', 
                        title: 'D⬇', 
                        width: 'col-xs', 
                        align: 'text-right',
                        format: 'number'
                    },
                    { 
                        key: 'densitytritanium', 
                        title: 'T⬇', 
                        width: 'col-xs', 
                        align: 'text-right',
                        format: 'number'
                    },
                    { 
                        key: 'densitymolybdenum', 
                        title: 'M⬇', 
                        width: 'col-xs', 
                        align: 'text-right',
                        format: 'number'
                    },
                    { 
                        key: 'colchange', 
                        title: 'Col Δ', 
                        width: 'col-sm', 
                        align: 'text-right',
                        format: 'population_change',
                        colorize: 'positive-negative'
                    },
                    { 
                        key: 'colonisttaxrate', 
                        title: 'Col Tax', 
                        width: 'col-xs', 
                        align: 'text-right',
                        format: 'tax_rate'
                    },
                    { 
                        key: 'colonisthappypoints', 
                        title: 'Col Happy', 
                        width: 'col-sm', 
                        align: 'text-right',
                        format: 'happiness',
                        colorize: 'happiness'
                    },
                    { 
                        key: 'colhappychange', 
                        title: 'Col H Δ', 
                        width: 'col-xs', 
                        align: 'text-right',
                        format: 'happiness_change',
                        colorize: 'positive-negative'
                    },
                    { 
                        key: 'nativechange', 
                        title: 'Nat Δ', 
                        width: 'col-sm', 
                        align: 'text-right',
                        format: 'population_change',
                        colorize: 'positive-negative'
                    },
                    { 
                        key: 'nativetaxrate', 
                        title: 'Nat Tax', 
                        width: 'col-xs', 
                        align: 'text-right',
                        format: 'tax_rate'
                    },
                    { 
                        key: 'nativehappypoints', 
                        title: 'Nat Happy', 
                        width: 'col-sm', 
                        align: 'text-right',
                        format: 'happiness',
                        colorize: 'happiness'
                    },
                    { 
                        key: 'nativehappychange', 
                        title: 'Nat H Δ', 
                        width: 'col-xs', 
                        align: 'text-right',
                        format: 'happiness_change',
                        colorize: 'positive-negative'
                    }
                ];

                // Build final columns array with conditional owner column
                const columns = showOwner 
                    ? [...baseColumns, ownerColumn, ...remainingColumns]
                    : [...baseColumns, ...remainingColumns];

                // Transform planets data to include resource richness information
                const enrichedPlanets = planets.map(planet => {
                    const resourceAnalysis = this.calculateResourceRichness(planet);
                    return {
                        ...planet,
                        ...resourceAnalysis,
                        starbase: starbaseMap[planet.id] // Add explicit starbase reference for formatting
                    };
                });

                return this.createTable(containerId, enrichedPlanets, columns, {
                    objectType: 'planet',
                    selectable: true,
                    variant: 'compact',
                    starbaseMap: starbaseMap
                });
            }

            createShipsTable(containerId, ships) {
                const columns = [
                    { 
                        key: 'id', 
                        title: 'ID', 
                        width: 'col-xs', 
                        align: 'text-right', 
                        format: 'number' 
                    },
                    { 
                        key: 'name', 
                        title: 'Name', 
                        width: 'col-xl',
                        align: 'text-left',
                        cssClass: 'vgap-ship-name',
                        format: 'truncate'
                    },
                    { 
                        key: 'ownerid', 
                        title: 'Race', 
                        width: 'col-md',
                        align: 'text-left',
                        format: 'owner',
                        cssClass: 'vgap-owner'
                    },
                    { 
                        key: 'hullid', 
                        title: 'Hull', 
                        width: 'col-lg',
                        align: 'text-left',
                        format: 'hull_name',
                        cssClass: 'vgap-hull-name'
                    },
                    { 
                        key: 'mass', 
                        title: 'Mass', 
                        width: 'col-sm', 
                        align: 'text-right',
                        format: 'mass'
                    },
                    { 
                        key: 'x', 
                        title: 'Loc', 
                        width: 'col-sm', 
                        align: 'text-center',
                        cssClass: 'vgap-coordinates',
                        format: 'coordinates'
                    },
                    { 
                        key: 'x', 
                        title: 'Planet', 
                        width: 'col-md',
                        align: 'text-left',
                        format: 'planet_location'
                    },
                    { 
                        key: 'crew', 
                        title: 'Crew', 
                        width: 'col-sm', 
                        align: 'text-right',
                        format: 'population'
                    },
                    { 
                        key: 'mass', 
                        title: 'Ship Mass', 
                        width: 'col-md', 
                        align: 'text-right', 
                        format: 'mass'
                    },
                    { 
                        key: 'neutronium', 
                        title: 'Fuel', 
                        width: 'col-sm', 
                        align: 'text-right',
                        format: 'fuel',
                        colorize: 'fuel'
                    },
                    { 
                        key: 'damage', 
                        title: 'Dam%', 
                        width: 'col-sm', 
                        align: 'text-right',
                        format: 'percentage',
                        colorize: 'damage'
                    },
                    { 
                        key: 'beams', 
                        title: 'Beams', 
                        width: 'col-md', 
                        align: 'text-left',
                        format: 'weapons_beams'
                    },
                    { 
                        key: 'torps', 
                        title: 'Torps', 
                        width: 'col-md', 
                        align: 'text-left',
                        format: 'weapons_torps'
                    },
                    { 
                        key: 'fighters', 
                        title: 'Ftr', 
                        width: 'col-sm', 
                        align: 'text-right',
                        format: 'number'
                    },
                    { 
                        key: 'supplies', 
                        title: 'Sup', 
                        width: 'col-sm', 
                        align: 'text-right',
                        format: 'number',
                        colorize: 'resources'
                    },
                    { 
                        key: 'megacredits', 
                        title: 'MC', 
                        width: 'col-sm', 
                        align: 'text-right',
                        format: 'number',
                        colorize: 'resources'
                    },
                    { 
                        key: 'clans', 
                        title: 'Clans', 
                        width: 'col-sm', 
                        align: 'text-right',
                        format: 'population',
                        colorize: 'resources'
                    },
                    { 
                        key: 'tritanium', 
                        title: 'Tri', 
                        width: 'col-sm', 
                        align: 'text-right',
                        format: 'number',
                        colorize: 'resources'
                    },
                    { 
                        key: 'duranium', 
                        title: 'Dur', 
                        width: 'col-sm', 
                        align: 'text-right',
                        format: 'number',
                        colorize: 'resources'
                    },
                    { 
                        key: 'molybdenum', 
                        title: 'Mol', 
                        width: 'col-sm', 
                        align: 'text-right',
                        format: 'number',
                        colorize: 'resources'
                    }
                ];

                return this.createTable(containerId, ships, columns, {
                    objectType: 'ship',
                    selectable: true,
                    variant: 'dense'
                });
            }

            createStarbasesTable(containerId, starbases) {
                const columns = [
                    { 
                        key: 'id', 
                        title: 'ID', 
                        width: 'col-xs', 
                        align: 'text-right', 
                        format: 'number' 
                    },
                    { 
                        key: 'planetname', 
                        title: 'Planet', 
                        width: 'col-lg',
                        align: 'text-left',
                        cssClass: 'vgap-planet-name',
                        format: 'planet_name'
                    },
                    { 
                        key: 'x', 
                        title: 'Loc', 
                        width: 'col-sm', 
                        align: 'text-center',
                        cssClass: 'vgap-coordinates',
                        format: 'coordinates'
                    },
                    { 
                        key: 'connected', 
                        title: 'Conn', 
                        width: 'col-sm',
                        align: 'text-center',
                        format: 'connected',
                        cssClass: 'vgap-connection'
                    },
                    { 
                        key: 'defense', 
                        title: 'Def', 
                        width: 'col-sm', 
                        align: 'text-right', 
                        format: 'number',
                        colorize: 'resources'
                    },
                    { 
                        key: 'fighters', 
                        title: 'Ftr', 
                        width: 'col-sm', 
                        align: 'text-right',
                        format: 'number'
                    },
                    { 
                        key: 'supplies', 
                        title: 'Sup', 
                        width: 'col-sm', 
                        align: 'text-right',
                        format: 'number',
                        colorize: 'resources'
                    },
                    { 
                        key: 'megacredits', 
                        title: 'MC', 
                        width: 'col-sm', 
                        align: 'text-right',
                        format: 'number',
                        colorize: 'resources'
                    },
                    { 
                        key: 'enginetechlevel', 
                        title: 'Eng', 
                        width: 'col-xs', 
                        align: 'text-right',
                        format: 'number',
                        colorize: 'tech'
                    },
                    { 
                        key: 'hulltechlevel', 
                        title: 'Hull', 
                        width: 'col-xs', 
                        align: 'text-right',
                        format: 'number',
                        colorize: 'tech'
                    },
                    { 
                        key: 'torptechlevel', 
                        title: 'Torp', 
                        width: 'col-xs', 
                        align: 'text-right',
                        format: 'number',
                        colorize: 'tech'
                    },
                    { 
                        key: 'beamtechlevel', 
                        title: 'Beam', 
                        width: 'col-xs', 
                        align: 'text-right',
                        format: 'number',
                        colorize: 'tech'
                    },
                    { 
                        key: 'damage', 
                        title: 'Dam%', 
                        width: 'col-sm', 
                        align: 'text-right',
                        format: 'percentage',
                        colorize: 'damage'
                    },
                    { 
                        key: 'mission', 
                        title: 'Mission', 
                        width: 'col-lg',
                        align: 'text-left',
                        format: 'starbase_mission'
                    }
                ];

                // Transform starbases data to include resource richness information from associated planets
                const enrichedStarbases = starbases.map(starbase => {
                    let resourceAnalysis = { shouldHighlight: false };
                    let connectionCount = 0;
                    
                    // Find the planet associated with this starbase
                    if (currentGameData && currentGameData.rst && currentGameData.rst.planets && starbase.planetid) {
                        const planet = currentGameData.rst.planets.find(p => p.id == starbase.planetid);
                        if (planet) {
                            resourceAnalysis = this.calculateResourceRichness(planet);
                            // Add planet coordinates to starbase for location display
                            starbase.x = planet.x;
                            starbase.y = planet.y;
                            
                            // Calculate connectedness to nearby resource-rich planets (same logic as future starbases)
                            const planets = currentGameData.rst.planets;
                            planets.forEach(nearbyPlanet => {
                                if (nearbyPlanet.id === planet.id) return; // Skip self
                                
                                const distance = Math.sqrt(
                                    Math.pow(nearbyPlanet.x - planet.x, 2) + 
                                    Math.pow(nearbyPlanet.y - planet.y, 2)
                                );
                                
                                // Check if within 84 LY and has significant resources (same threshold as getConnectionDisplay)
                                if (distance <= 84) {
                                    const totalResources = (nearbyPlanet.duranium || 0) + 
                                                         (nearbyPlanet.tritanium || 0) + 
                                                         (nearbyPlanet.molybdenum || 0);
                                    if (totalResources > 100) { // Same threshold for "resource-rich"
                                        connectionCount++;
                                    }
                                }
                            });
                        }
                    }
                    
                    return {
                        ...starbase,
                        ...resourceAnalysis,
                        connected: connectionCount  // Add connection count for the connected column
                    };
                });

                return this.createTable(containerId, enrichedStarbases, columns, {
                    objectType: 'starbase',
                    selectable: true
                });
            }
        }

        // Initialize global managers
        const selectionManager = new SelectionManager();
        const visualizationManager = new VisualizationManager();
        const tableManager = new TableManager();
        tableManager.setSelectionManager(selectionManager);

        // Make getOwnerName and getHullName globally available for tooltip generation
        window.getOwnerName = tableManager.getOwnerName.bind(tableManager);
        window.getHullName = tableManager.getHullName.bind(tableManager);

        // Make managers globally accessible with consistent naming
        window.selectionManager = selectionManager;
        window.visualizationManager = visualizationManager;
        window.tableManager = tableManager;

        // Also provide class constructors for reference
        window.SelectionManager = SelectionManager;
        window.VisualizationManager = VisualizationManager;
        window.TableManager = TableManager;

        // ===== MAIN APPLICATION =====
        let currentGameData = null;
        let currentFileName = null;
        let selectedObjectId = null;
        let selectedObjectType = null; // 'planet', 'starbase', 'ship'

        // Test mode toggle - Set to false for production
        let isTestMode = true; // Change this to false for production release

        // Embedded test data for development (loaded from external script)
        // TEST_DATA is defined in test_data_embed.js as EMBEDDED_TEST_DATA

        // Starmap variables
        let svgElement = null;
        let isDragging = false;
        let dragStart = { x: 0, y: 0 };
        let dragStartTime = 0;
        const MIN_DRAG_TIME = 100; // Minimum 100ms before allowing drag end
        let viewBox = { x: 0, y: 0, width: 0, height: 0 };

        // Starmap color definitions
        const Colors = {
            // Planets - ownership based
            MINE: '#00ff00',        // Green - Mine
            ALLIED: '#66ccff',      // Light Blue - Allied
            ENEMY: '#ff0000',       // Red - Enemy
            UNOWNED: '#ffff00',     // Yellow - Unowned
            UNDISCOVERED: '#808080', // Grey - Undiscovered
            
            // Starbases
            STARBASE: '#40e0d0',    // Turquoise - All starbases
            
            // Ships (orbit circles around planets)
            SHIP_MINE_ORBIT: '#00ff00',     // Green - My ships
            SHIP_ALLIED_ORBIT: '#ff8c00',   // Orange - Allied ships
            SHIP_ENEMY_ORBIT: '#ff0000',    // Red - Enemy ships
            
            // Ships (in space - dots)
            SHIP_MINE_SPACE: '#00ff00',     // Green - My ships in space
            SHIP_ALLIED_SPACE: '#ff8c00',   // Orange - Allied ships in space
            SHIP_ENEMY_SPACE: '#ff0000',    // Red - Enemy ships in space
            
            // Nebulas
            NEBULA_FILL: 'rgba(128, 0, 128, 0.3)',
            NEBULA_STROKE: '#800080',
            
            // UI elements
            GRID_LINE: '#333333',
            BORDER: '#555555',
            SELECTION: '#ffff00'
        };

        // ===== TOOLTIP AND CROSS-HIGHLIGHTING FUNCTIONS =====
        
        let tooltip = null;
        
        function getTooltipElement() {
            if (!tooltip) {
                tooltip = document.getElementById('starmapTooltip');
            }
            return tooltip;
        }
        
        function showTooltip(element, data, type, event) {
            // showTooltip called
            const tooltipEl = getTooltipElement();
            if (!tooltipEl) {
                // No tooltip element found
                return;
            }
            
            // Generate tooltip content based on object type
            let content = '';
            
            if (type === 'planet') {
                const happiness = parseInt(data.colonisthappypoints, 10) || 0;
                const temp = parseInt(data.temp, 10) || 0;
                const ownerName = getOwnerName(data.ownerid, data);
                let raceName = 'Unknown';
                if (data.ownerid && currentGameData && currentGameData.rst && currentGameData.rst.players && currentGameData.rst.races) {
                    const player = currentGameData.rst.players.find(p => p.id == data.ownerid);
                    if (player && player.raceid) {
                        const race = currentGameData.rst.races.find(r => r.id == player.raceid);
                        if (race) raceName = race.name || race.adjective || race.shortname;
                    }
                }
                const isAllied = window.alliedPlayerIds && window.alliedPlayerIds.includes(parseInt(data.ownerid, 10));
                content = `
                    <h4>🪐 ${data.name || `Planet ${data.id}`}${isAllied ? ' <span style=\"color:#66ccff;font-weight:bold;\">[Ally]</span>' : ''}</h4>
                    <div class="tooltip-grid">
                        <span class="tooltip-label">ID:</span><span>${data.id}</span>
                        <span class="tooltip-label">Owner:</span><span>${ownerName}</span>
                        <span class="tooltip-label">Race:</span><span>${raceName}</span>
                        <span class="tooltip-label">Position:</span><span>(${data.x}, ${data.y})</span>
                        <span class="tooltip-label">Temperature:</span><span class="${getTempClass(temp)}">${temp}°</span>
                        <span class="tooltip-label">Happiness:</span><span class="${getHappinessClass(happiness)}">${happiness}%</span>
                        <span class="tooltip-label">Colonists:</span><span>${formatPopulation(data.colonistclans)}</span>
                        <span class="tooltip-label">Neutronium:</span><span>${parseInt(data.neutronium || 0).toLocaleString()}</span>
                        <span class="tooltip-label">Duranium:</span><span class="${getResourceClass(data.duranium || 0, 'duranium')}">${parseInt(data.duranium || 0).toLocaleString()}</span>
                        <span class="tooltip-label">Tritanium:</span><span class="${getResourceClass(data.tritanium || 0, 'tritanium')}">${parseInt(data.tritanium || 0).toLocaleString()}</span>
                        <span class="tooltip-label">Molybdenum:</span><span class="${getResourceClass(data.molybdenum || 0, 'molybdenum')}">${parseInt(data.molybdenum || 0).toLocaleString()}</span>
                        <span class="tooltip-label">Friendly Code:</span><span class="vgap-friendly-code">${data.friendlycode || 'N/A'}</span>
                    </div>
                `;
            } else if (type === 'ship') {
                const hullName = getHullName(data.hullid) || data.hullname || 'Unknown Hull';
                const ownerName = getOwnerName(data.ownerid, data);
                let raceName = 'Unknown';
                if (data.ownerid && currentGameData && currentGameData.rst && currentGameData.rst.players && currentGameData.rst.races) {
                    const player = currentGameData.rst.players.find(p => p.id == data.ownerid);
                    if (player && player.raceid) {
                        const race = currentGameData.rst.races.find(r => r.id == player.raceid);
                        if (race) raceName = race.name || race.adjective || race.shortname;
                    }
                }
                const isAllied = window.alliedPlayerIds && window.alliedPlayerIds.includes(parseInt(data.ownerid, 10));
                content = `
                    <h4>🚢 ${data.name || `Ship ${data.id}`}${isAllied ? ' <span style=\"color:#66ccff;font-weight:bold;\">[Ally]</span>' : ''}</h4>
                    <div class="tooltip-grid">
                        <span class="tooltip-label">ID:</span><span>${data.id}</span>
                        <span class="tooltip-label">Owner:</span><span>${ownerName}</span>
                        <span class="tooltip-label">Race:</span><span>${raceName}</span>
                        <span class="tooltip-label">Hull:</span><span class="vgap-hull-name">${hullName}</span>
                        <span class="tooltip-label">Position:</span><span>(${data.x}, ${data.y})</span>
                        <span class="tooltip-label">Damage:</span><span class="${data.damage > 0 ? 'cell-warning' : 'cell-positive'}">${data.damage || 0}%</span>
                        <span class="tooltip-label">Fuel:</span><span class="${data.neutronium > 200 ? 'cell-positive' : data.neutronium < 50 ? 'cell-warning' : 'cell-neutral'}">${parseInt(data.neutronium || 0).toLocaleString()}</span>
                        <span class="tooltip-label">Cargo:</span><span>${parseInt(data.cargo || 0).toLocaleString()}</span>
                        <span class="tooltip-label">Mission:</span><span>${data.mission || 'None'}</span>
                        <span class="tooltip-label">Friendly Code:</span><span class="vgap-friendly-code">${data.friendlycode || 'N/A'}</span>
                    </div>
                `;
            } else if (type === 'starbase') {
                const ownerName = getOwnerName(data.ownerid, data);
                let raceName = 'Unknown';
                if (data.ownerid && currentGameData && currentGameData.rst && currentGameData.rst.players && currentGameData.rst.races) {
                    const player = currentGameData.rst.players.find(p => p.id == data.ownerid);
                    if (player && player.raceid) {
                        const race = currentGameData.rst.races.find(r => r.id == player.raceid);
                        if (race) raceName = race.name || race.adjective || race.shortname;
                    }
                }
                const isAllied = window.alliedPlayerIds && window.alliedPlayerIds.includes(parseInt(data.ownerid, 10));
                content = `
                    <h4>🏭 Starbase ${data.id}${isAllied ? ' <span style=\"color:#66ccff;font-weight:bold;\">[Ally]</span>' : ''}</h4>
                    <div class="tooltip-grid">
                        <span class="tooltip-label">ID:</span><span>${data.id}</span>
                        <span class="tooltip-label">Owner:</span><span>${ownerName}</span>
                        <span class="tooltip-label">Race:</span><span>${raceName}</span>
                        <span class="tooltip-label">Position:</span><span>(${data.x}, ${data.y})</span>
                        <span class="tooltip-label">Defense:</span><span class="cell-info">${data.defense || 0}</span>
                        <span class="tooltip-label">Damage:</span><span class="${data.damage > 0 ? 'cell-warning' : 'cell-positive'}">${data.damage || 0}%</span>
                        <span class="tooltip-label">Fighters:</span><span>${data.fighters || 0}</span>
                        <span class="tooltip-label">Tech Levels:</span><span>E:${data.enginetech || 0} H:${data.hulltech || 0} B:${data.beamtech || 0} T:${data.torpedotech || 0}</span>
                    </div>
                `;
            }
            
            tooltipEl.innerHTML = content;
            tooltipEl.style.display = 'block';
            // Tooltip displayed
            
            // No positioning needed - CSS handles fixed position on right side
        }
        
        function hideTooltip() {
            const tooltipEl = getTooltipElement();
            if (tooltipEl) {
                tooltipEl.style.display = 'none';
            }
        }
        
        function addTooltipEventListeners(element, data, type) {
            // Adding tooltip listeners
            
            element.addEventListener('mouseenter', (e) => {
                // Mouse entered
                showTooltip(element, data, type, e);
            });
            
            // No longer need mousemove since tooltip is fixed position
            
            element.addEventListener('mouseleave', () => {
                // Mouse left
                hideTooltip();
            });
            
            // Also add click handler for selection
            element.addEventListener('click', (e) => {
                e.stopPropagation();
                selectStarmapObject(type, data.id);
            });
        }
        
        function highlightTableRow(type, objectId, isHover = false) {
            // Get the currently visible table
            const visibleTabSection = document.querySelector('.tab-section.active');
            if (!visibleTabSection) return;
            
            const table = visibleTabSection.querySelector('.vgap-table');
            if (!table) return;
            
            // Find the row with matching data
            const rows = table.querySelectorAll('.vgap-table-row');
            rows.forEach(row => {
                const cells = row.querySelectorAll('.vgap-table-cell');
                if (cells.length > 0) {
                    // Check first cell (ID) to match
                    const rowId = cells[0].textContent.trim();
                    if (rowId === objectId.toString()) {
                        row.classList.add(isHover ? 'hover-highlight' : 'selected');
                        // Scroll into view if not visible
                        row.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
                    }
                }
            });
        }
        
        function clearTableHighlights() {
            const allRows = document.querySelectorAll('.vgap-table-row');
            allRows.forEach(row => {
                row.classList.remove('hover-highlight', 'selected');
            });
        }
        
        function selectStarmapObject(type, objectId) {
            // Clear existing selections
            clearStarmapSelections();
            
            // Add permanent selection to starmap only
            highlightStarmapObject(type, objectId, false);
            
            // Also use existing selection system if available
            if (selectionManager) {
                const element = svgElement?.querySelector(`[data-type="${type}"][data-id="${objectId}"]`);
                if (element) {
                    selectionManager.selectObject(element, type, objectId);
                }
            }
        }
        
        function highlightStarmapObject(type, objectId, isHover = false) {
            if (!svgElement) return;
            
            const element = svgElement.querySelector(`[data-type="${type}"][data-id="${objectId}"]`);
            if (element) {
                // Add appropriate CSS class for highlighting
                if (isHover) {
                    element.classList.add('hover-highlight');
                } else {
                    element.classList.add('selected');
                    // Center view on selected object
                    centerViewOnObject(element);
                }
            }
        }
        
        function clearStarmapHighlights() {
            if (!svgElement) return;
            
            // Remove hover highlights from all starmap elements
            const elements = svgElement.querySelectorAll('[data-type="planet"], [data-type="ship"], [data-type="starbase"]');
            elements.forEach(element => {
                element.classList.remove('hover-highlight');
            });
        }
        
        function clearStarmapSelections() {
            if (!svgElement) return;
            
            // Remove selection highlights from all starmap elements
            const elements = svgElement.querySelectorAll('[data-type="planet"], [data-type="ship"], [data-type="starbase"]');
            elements.forEach(element => {
                element.classList.remove('selected');
            });
        }

        // ===== STARMAP FUNCTIONS =====

        // Force initialization function for manual testing
        window.forceInitPanZoom = function() {
            if (!svgElement) {
                svgElement = document.getElementById('integratedStarmap');
            }
            
            if (svgElement) {
                const rect = svgElement.getBoundingClientRect();
                
                if (rect.width <= 0 || rect.height <= 0) {
                    svgElement.style.width = '100%';
                    svgElement.style.height = '500px';
                    svgElement.style.minWidth = '400px';
                    svgElement.style.minHeight = '400px';
                    
                    // Check dimensions again after forcing
                    setTimeout(() => {
                        const newRect = svgElement.getBoundingClientRect();
                        
                        // Reset retry counter and try again
                        initRetryCount = 0;
                        initializePanZoom();
                    }, 100);
                } else {
                    // Reset retry counter and initialize
                    initRetryCount = 0;
                    initializePanZoom();
                }
            } else {
                console.error('No SVG element found');
            }
        };

        // Debug functions removed for cleaner console output

        let starmapInitialized = false;

        function initializeStarmap() {
            svgElement = document.getElementById('integratedStarmap');
            
            if (!svgElement) {
                console.error('SVG element not found');
                return;
            }
            
            // Prevent duplicate initialization
            if (starmapInitialized) {
                return;
            }
            
            // Add backup tooltip hiding for starmap container
            const starmapContainer = document.querySelector('.starmap-container');
            if (starmapContainer) {
                starmapContainer.addEventListener('mouseleave', () => {
                    hideTooltip();
                });
            }
            
            // Initialize pan/zoom
            initializePanZoom();
            
            // Initialize controls - remove existing listeners first to avoid duplicates
            const showPlanets = document.getElementById('showPlanets');
            const showShips = document.getElementById('showShips');
            const showStarbases = document.getElementById('showStarbases');
            const showNebulas = document.getElementById('showNebulas');
            const zoomIn = document.getElementById('zoomIn');
            const zoomOut = document.getElementById('zoomOut');
            const resetZoom = document.getElementById('resetZoom');
            const fitToScreen = document.getElementById('fitToScreen');

            if (showPlanets) showPlanets.addEventListener('change', redrawStarmap);
            if (showShips) showShips.addEventListener('change', redrawStarmap);
            if (showStarbases) showStarbases.addEventListener('change', redrawStarmap);
            if (showNebulas) showNebulas.addEventListener('change', redrawStarmap);
            
            // Ally configuration input handler
            const allyIdsInput = document.getElementById('allyIdsInput');
            if (allyIdsInput) {
                allyIdsInput.addEventListener('input', function() {
                    const value = this.value.trim();
                    if (value === '') {
                        window.alliedPlayerIds = [];
                    } else {
                        const ids = value.split(',').map(id => parseInt(id.trim())).filter(id => !isNaN(id));
                        window.alliedPlayerIds = ids;
                    }
                    // Updated alliedPlayerIds
                    redrawStarmap(); // Redraw to reflect ally changes
                });
                
                // Initialize with current allies
                if (window.alliedPlayerIds && window.alliedPlayerIds.length > 0) {
                    allyIdsInput.value = window.alliedPlayerIds.join(', ');
                }
            }
            
            if (zoomIn) {
                // Setting up zoomIn event listener
                // Remove any existing listeners first
                zoomIn.onclick = null;
                zoomIn.onclick = function(e) {
                    // ZOOM IN CLICKED
                    e.preventDefault();
                    e.stopPropagation();
                    zoomStarmap(1.4);
                };
            } else {
                console.error('zoomIn button not found!');
            }
            if (zoomOut) {
                // Setting up zoomOut event listener
                // Remove any existing listeners first
                zoomOut.onclick = null;
                zoomOut.onclick = function(e) {
                    // ZOOM OUT CLICKED
                    e.preventDefault();
                    e.stopPropagation();
                    zoomStarmap(0.714);
                };
            } else {
                console.error('zoomOut button not found!');
            }
            if (resetZoom) resetZoom.addEventListener('click', resetStarmapView);
            if (fitToScreen) fitToScreen.addEventListener('click', fitStarmapToScreen);
            
            starmapInitialized = true;
        }

        let initRetryCount = 0;
        const maxInitRetries = 5;

        function initializePanZoom() {
            if (!svgElement) {
                return;
            }
            
            // Debug parent containers
            const starmapContainer = svgElement.parentElement;
            
            // Check if SVG is visible (not hidden by CSS)
            const dataSections = document.getElementById('dataSections');
            const isVisible = dataSections && !dataSections.classList.contains('hidden');
            const isSvgInDom = svgElement.isConnected;
            const computedStyle = window.getComputedStyle(svgElement);
            const isSvgVisible = computedStyle.display !== 'none' && computedStyle.visibility !== 'hidden';
            
            // Force SVG to have dimensions if it's not getting them
            if (computedStyle.width === 'auto' || computedStyle.height === 'auto' || computedStyle.width === '0px' || computedStyle.height === '0px') {
                svgElement.style.width = '100%';
                svgElement.style.height = '100%';
                svgElement.style.minHeight = '300px';
                svgElement.style.display = 'block';
                
                // Force reflow
                svgElement.offsetHeight;
                
                // Re-check computed style after forcing
                const newComputedStyle = window.getComputedStyle(svgElement);
                
                // If still not working, try explicit pixel dimensions based on parent
                if (newComputedStyle.width === '0px' || newComputedStyle.height === '0px') {
                    const parentRect = starmapContainer ? starmapContainer.getBoundingClientRect() : null;
                    if (parentRect && parentRect.width > 0 && parentRect.height > 0) {
                        svgElement.style.width = parentRect.width + 'px';
                        svgElement.style.height = parentRect.height + 'px';
                    } else {
                        // Fallback to viewport-based dimensions
                        const viewportWidth = Math.max(window.innerWidth * 0.8, 800);
                        const viewportHeight = Math.max(window.innerHeight * 0.5, 400);
                        svgElement.style.width = viewportWidth + 'px';
                        svgElement.style.height = viewportHeight + 'px';
                    }
                }
            }
            
            if (!isVisible || !isSvgInDom || !isSvgVisible) {
                if (initRetryCount < maxInitRetries) {
                    initRetryCount++;
                    const delay = 200 * initRetryCount; // Increasing delay
                    
                    setTimeout(() => {
                        initializePanZoom();
                    }, delay);
                    return;
                } else {
                    console.error('Failed to initialize pan/zoom after', maxInitRetries, 'attempts - SVG not ready');
                    // Reset retry counter for future attempts
                    initRetryCount = 0;
                    return;
                }
            }
            
            // Check if SVG has proper dimensions before proceeding
            const rect = svgElement.getBoundingClientRect();
            
            // Check multiple dimension sources for robustness
            const hasDimensions = 
                (rect.width > 0 && rect.height > 0) || 
                (svgElement.offsetWidth > 0 && svgElement.offsetHeight > 0) ||
                (svgElement.clientWidth > 0 && svgElement.clientHeight > 0);
            
            if (!hasDimensions) {
                if (initRetryCount < maxInitRetries) {
                    initRetryCount++;
                    const delay = 200 * initRetryCount; // Increasing delay
                    
                    // Try to force SVG to have dimensions
                    if (!svgElement.style.minHeight) {
                        svgElement.style.minWidth = '400px';
                        svgElement.style.minHeight = '300px';
                        svgElement.style.width = '100%';
                        svgElement.style.height = '100%';
                    }
                    
                    // Force a reflow to ensure dimensions are calculated
                    svgElement.offsetHeight; // Trigger reflow
                    
                    setTimeout(() => {
                        initializePanZoom();
                    }, delay);
                    return;
                } else {
                    console.error('Failed to initialize pan/zoom after', maxInitRetries, 'attempts - SVG still has no dimensions');
                    console.error('Final SVG dimensions - rect:', rect, 'offset:', svgElement.offsetWidth, 'x', svgElement.offsetHeight, 'client:', svgElement.clientWidth, 'x', svgElement.clientHeight);
                    // Reset retry counter for future attempts
                    initRetryCount = 0;
                    return;
                }
            }
            
            // Success! Reset retry counter
            initRetryCount = 0;
            
            // Ensure SVG has proper attributes for pan/zoom
            if (!svgElement.getAttribute('viewBox')) {
                svgElement.setAttribute('viewBox', '0 0 1600 600');
            }
            
            // Ensure SVG has proper width/height attributes
            if (!svgElement.getAttribute('width')) {
                svgElement.setAttribute('width', '100%');
            }
            if (!svgElement.getAttribute('height')) {
                svgElement.setAttribute('height', '100%');
            }
            
            // Reset drag state before initialization to prevent stuck states
            isDragging = false;
            dragStart = { x: 0, y: 0 };
            dragStartTime = 0;
            
            // Remove any existing listeners first - be thorough
            svgElement.removeEventListener('mousedown', startDrag);
            svgElement.removeEventListener('mouseup', endDrag);
            svgElement.removeEventListener('mouseleave', endDrag);
            svgElement.removeEventListener('wheel', handleWheel);
            
            // Also remove any document listeners that might be lingering
            document.removeEventListener('mousedown', handleDocumentMouseDown, false);
            document.removeEventListener('mousemove', drag, true);
            document.removeEventListener('mouseup', endDrag, true);
            
            // Use document-level event delegation for better event handling with SVG child elements
            document.addEventListener('mousedown', handleDocumentMouseDown, false);
            
            // Add wheel event
            svgElement.addEventListener('wheel', handleWheel, { passive: false });
            
            // Add mouseleave to hide tooltip when leaving starmap area
            svgElement.addEventListener('mouseleave', () => {
                hideTooltip();
            });
            
            // Set default cursor
            svgElement.style.cursor = 'move';
        }

        function handleDocumentMouseDown(e) {
            // Check if the event target is within the SVG element
            const svgElement = document.getElementById('integratedStarmap');
            if (!svgElement) {
                return;
            }
            
            // Check if the event target is the SVG or a descendant of the SVG
            if (!svgElement.contains(e.target)) {
                return;
            }
            
            // Call the original startDrag function
            startDrag(e);
        }

        function startDrag(e) {
            // If already dragging, force reset first
            if (isDragging) {
                window.resetDragState();
            }
            
            // Don't start dragging if clicking on interactive elements (planets, ships, starbases)
            const dataType = e.target.getAttribute('data-type');
            if (dataType && (dataType === 'planet' || dataType === 'ship' || dataType === 'starbase')) {
                return;
            }
            
            isDragging = true;
            dragStart.x = e.clientX;
            dragStart.y = e.clientY;
            dragStartTime = Date.now();
            
            if (svgElement) {
                svgElement.style.cursor = 'grabbing';
            }
            
            // Add event listeners to document for better drag handling
            document.addEventListener('mousemove', drag, true); // Use capture phase
            document.addEventListener('mouseup', endDrag, true); // Use capture phase
            
            e.preventDefault();
            e.stopPropagation();
            // Event prevented and propagation stopped
        }

        function drag(e) {
            if (!isDragging) {
                return;
            }
            
            e.preventDefault();
            
            const dx = e.clientX - dragStart.x;
            const dy = e.clientY - dragStart.y;
            
            // Only update if there's significant movement
            if (Math.abs(dx) < 2 && Math.abs(dy) < 2) {
                return;
            }
            
            const viewBoxAttr = svgElement.getAttribute('viewBox');
            if (viewBoxAttr) {
                const [x, y, width, height] = viewBoxAttr.split(' ').map(Number);
                
                // Calculate how much to move the viewBox based on current zoom level
                const rect = svgElement.getBoundingClientRect();
                const scaleX = width / rect.width;
                const scaleY = height / rect.height;
                
                const newX = x - dx * scaleX;
                const newY = y - dy * scaleY;
                
                svgElement.setAttribute('viewBox', `${newX} ${newY} ${width} ${height}`);
            }
            
            dragStart.x = e.clientX;
            dragStart.y = e.clientY;
        }

        function endDrag(e) {
            const currentTime = Date.now();
            const dragDuration = currentTime - dragStartTime;
            
            if (!isDragging) {
                return;
            }
            
            // Prevent accidental immediate drag ends
            if (dragDuration < MIN_DRAG_TIME) {
                return;
            }
            
            isDragging = false;
            if (svgElement) {
                svgElement.style.cursor = 'move';
            }
            
            // Remove event listeners from document
            document.removeEventListener('mousemove', drag, true);
            document.removeEventListener('mouseup', endDrag, true);
        }

        function handleWheel(e) {
            if (!svgElement) {
                return;
            }
            
            // Check SVG dimensions before proceeding
            const rect = svgElement.getBoundingClientRect();
            if (rect.width <= 0 || rect.height <= 0) {
                return;
            }
            
            e.preventDefault();
            const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
            
            // Get mouse position relative to the SVG
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            zoomStarmapToPoint(zoomFactor, mouseX, mouseY);
        }

        function zoomStarmap(factor) {
            // Legacy function for button clicks - zoom to center
            if (!svgElement) {
                return;
            }
            const rect = svgElement.getBoundingClientRect();
            const centerX = rect.width / 2;
            const centerY = rect.height / 2;
            zoomStarmapToPoint(factor, centerX, centerY);
        }

        function zoomStarmapToPoint(factor, screenX, screenY) {
            if (!svgElement) {
                console.error('zoomStarmapToPoint called but svgElement is null');
                return;
            }
            
            const rect = svgElement.getBoundingClientRect();
            
            // Validate SVG rect
            if (!rect || rect.width <= 0 || rect.height <= 0) {
                console.error('Invalid SVG bounding rect:', rect);
                return;
            }
            
            // Get the current viewBox
            const viewBoxAttr = svgElement.getAttribute('viewBox');
            console.log('Current viewBox attribute:', viewBoxAttr);
            if (!viewBoxAttr) {
                // If no viewBox is set, try to initialize one
                const { width, height } = calculateStarmapDimensions();
                console.log('Initializing viewBox with dimensions:', width, height);
                svgElement.setAttribute('viewBox', `0 0 ${width} ${height}`);
                console.log('ViewBox set, returning for retry');
                return; // Let user try again after viewBox is set
            }
            
            const viewBox = viewBoxAttr.split(' ').map(parseFloat);
            const [vbX, vbY, vbWidth, vbHeight] = viewBox;
            console.log('Parsed viewBox:', { vbX, vbY, vbWidth, vbHeight });
            
            // Validate viewBox values
            if (!isFinite(vbX) || !isFinite(vbY) || !isFinite(vbWidth) || !isFinite(vbHeight) || 
                vbWidth <= 0 || vbHeight <= 0) {
                console.error('Invalid viewBox values:', { vbX, vbY, vbWidth, vbHeight });
                return;
            }
            
            // Calculate current and new zoom levels based on SVG dimensions
            const { width, height } = calculateStarmapDimensions();
            console.log('Starmap dimensions:', { width, height });
            
            // Validate dimensions
            if (!isFinite(width) || !isFinite(height) || width <= 0 || height <= 0) {
                console.error('Invalid starmap dimensions:', { width, height });
                return;
            }
            
            const currentActualZoom = width / vbWidth;
            const newActualZoom = currentActualZoom * factor;
            console.log('Zoom calculations:', { currentActualZoom, newActualZoom, factor });
            
            // Validate zoom calculations
            if (!isFinite(currentActualZoom) || !isFinite(newActualZoom)) {
                console.error('Invalid zoom calculations:', { currentActualZoom, newActualZoom, factor });
                return;
            }
            
            // Apply zoom limits
            const clampedZoom = Math.max(0.05, Math.min(20, newActualZoom));
            console.log('Clamped zoom:', clampedZoom, 'vs current:', currentActualZoom);
            if (clampedZoom === currentActualZoom) {
                console.log('No zoom change needed, returning');
                return; // No change
            }
            
            // Calculate the world coordinate that was under the mouse
            const worldX = vbX + (screenX / rect.width) * vbWidth;
            const worldY = vbY + (screenY / rect.height) * vbHeight;
            console.log('World coordinates:', { worldX, worldY });
            
            // Validate world coordinates
            if (!isFinite(worldX) || !isFinite(worldY)) {
                console.error('Invalid world coordinates calculated:', { worldX, worldY });
                return;
            }
            
            // Calculate new viewBox dimensions
            const newVbWidth = width / clampedZoom;
            const newVbHeight = height / clampedZoom;
            console.log('New viewBox dimensions:', { newVbWidth, newVbHeight });
            
            // Validate new dimensions
            if (!isFinite(newVbWidth) || !isFinite(newVbHeight) || newVbWidth <= 0 || newVbHeight <= 0) {
                console.error('Invalid viewBox dimensions calculated:', { newVbWidth, newVbHeight });
                return;
            }
            
            // Position the new viewBox so the world coordinate stays under the mouse
            const newVbX = worldX - (screenX / rect.width) * newVbWidth;
            const newVbY = worldY - (screenY / rect.height) * newVbHeight;
            console.log('New viewBox position:', { newVbX, newVbY });
            
            // Validate new position
            if (!isFinite(newVbX) || !isFinite(newVbY)) {
                console.error('Invalid viewBox position calculated:', { newVbX, newVbY });
                return;
            }
            
            console.log('Setting new viewBox:', `${newVbX} ${newVbY} ${newVbWidth} ${newVbHeight}`);
            svgElement.setAttribute('viewBox', `${newVbX} ${newVbY} ${newVbWidth} ${newVbHeight}`);
            
            updateZoomIndicator();
            
            // Use requestAnimationFrame to ensure viewBox change is processed before redraw
            requestAnimationFrame(() => {
                redrawStarmap();
            });
        }

        function resetStarmapView() {
            if (!svgElement || !window.gameBounds) return;
            
            // Reset to initial viewBox showing entire SVG area
            const { width, height } = calculateStarmapDimensions();
            svgElement.setAttribute('viewBox', `0 0 ${width} ${height}`);
            
            updateZoomIndicator();
            
            // Use requestAnimationFrame to ensure viewBox change is processed before redraw
            requestAnimationFrame(() => {
                redrawStarmap();
            });
        }

        function fitStarmapToScreen() {
            if (!svgElement || !window.gameBounds) return;
            
            // Same as reset - fits entire SVG area
            const { width, height } = calculateStarmapDimensions();
            svgElement.setAttribute('viewBox', `0 0 ${width} ${height}`);
            
            updateZoomIndicator();
            
            // Use requestAnimationFrame to ensure viewBox change is processed before redraw
            requestAnimationFrame(() => {
                redrawStarmap();
            });
        }

        function updateZoomIndicator() {
            const indicator = document.getElementById('zoomIndicator');
            if (!indicator || !svgElement) return;
            
            const viewBoxAttr = svgElement.getAttribute('viewBox');
            if (viewBoxAttr) {
                // Calculate actual zoom level based on viewBox vs SVG dimensions
                const [, , vbWidth] = viewBoxAttr.split(' ').map(parseFloat);
                const { width } = calculateStarmapDimensions();
                const actualZoom = width / vbWidth;
                
                const percentage = Math.round(actualZoom * 100);
                indicator.textContent = `${percentage}%`;
                
                // Add visual feedback for extreme zoom levels
                indicator.className = 'zoom-indicator';
                if (actualZoom <= 0.1) {
                    indicator.classList.add('zoom-min');
                } else if (actualZoom >= 15) {
                    indicator.classList.add('zoom-max');
                }
            }
        }

        function calculateStarmapDimensions() {
            // Use standard VGAP map aspect ratio (typically square maps)
            const gameSettings = currentGameData?.rst?.settings;
            const mapWidth = gameSettings?.mapwidth || 2000;
            const mapHeight = gameSettings?.mapheight || 2000;
            const aspectRatio = mapWidth / mapHeight;
            
            // Calculate responsive dimensions based on container
            const container = document.querySelector('.starmap-container');
            const containerWidth = container ? container.clientWidth - 20 : window.innerWidth - 60;
            const maxWidth = Math.min(containerWidth, 1200);
            const baseHeight = 500;
            const baseWidth = Math.max(maxWidth * 0.95, baseHeight * aspectRatio);
            
            return { 
                width: baseWidth, 
                height: baseHeight
            };
        }

        function getCurrentZoomLevel() {
            try {
                if (!svgElement) {
                    console.log('getCurrentZoomLevel: No svgElement');
                    return 1;
                }
                const viewBox = svgElement.getAttribute('viewBox');
                if (!viewBox) {
                    console.log('getCurrentZoomLevel: No viewBox');
                    return 1;
                }
                
                const [, , vbWidth] = viewBox.split(' ').map(parseFloat);
                const { width } = calculateStarmapDimensions();
                if (width > 0 && vbWidth > 0) {
                    const zoomLevel = width / vbWidth;
                    console.log('getCurrentZoomLevel: viewBox width =', vbWidth, ', SVG width =', width, ', zoom =', zoomLevel);
                    return zoomLevel;
                }
                console.log('getCurrentZoomLevel: Invalid dimensions - width:', width, 'vbWidth:', vbWidth);
            } catch (error) {
                console.log('Error calculating zoom level:', error.message);
            }
            return 1;
        }

        function createScalingFunctions(svgWidth, svgHeight, gameData) {
            if (!gameData) return { scaleX: (x) => x, scaleY: (y) => y };
            
            const planets = gameData.rst?.planets || [];
            const ships = gameData.rst?.ships || [];
            const allObjects = [...planets, ...ships];
            
            if (allObjects.length === 0) {
                return { scaleX: (x) => x, scaleY: (y) => y };
            }
            
            // Find actual game bounds
            let gameMinX = Infinity, gameMaxX = -Infinity;
            let gameMinY = Infinity, gameMaxY = -Infinity;
            
            allObjects.forEach(obj => {
                if (obj.x !== undefined && obj.y !== undefined) {
                    gameMinX = Math.min(gameMinX, obj.x);
                    gameMaxX = Math.max(gameMaxX, obj.x);
                    gameMinY = Math.min(gameMinY, obj.y);
                    gameMaxY = Math.max(gameMaxY, obj.y);
                }
            });
            
            // Add padding
            const padding = 50;
            gameMinX -= padding;
            gameMaxX += padding;
            gameMinY -= padding;
            gameMaxY += padding;
            
            const gameWidth = gameMaxX - gameMinX;
            const gameHeight = gameMaxY - gameMinY;
            
            // Calculate scale to fit in SVG while maintaining aspect ratio
            const scaleFactorX = svgWidth / gameWidth;
            const scaleFactorY = svgHeight / gameHeight;
            const scaleFactor = Math.min(scaleFactorX, scaleFactorY);
            
            // Center the game area in the SVG
            const offsetX = (svgWidth - (gameWidth * scaleFactor)) / 2;
            const offsetY = (svgHeight - (gameHeight * scaleFactor)) / 2;
            
            // Transform game coordinates to SVG coordinates
            const scaleX = (x) => {
                const gameX = (x || 0) - gameMinX;
                return gameX * scaleFactor + offsetX;
            };
            
            const scaleY = (y) => {
                const gameY = (y || 0) - gameMinY;
                // Flip Y coordinate: SVG Y=0 is top, VGAP Y=0 is bottom
                return (gameHeight - gameY) * scaleFactor + offsetY;
            };
            
            // Store bounds for viewBox calculation
            window.gameBounds = {
                minX: offsetX,
                maxX: offsetX + (gameWidth * scaleFactor),
                minY: offsetY,
                maxY: offsetY + (gameHeight * scaleFactor),
                width: gameWidth * scaleFactor,
                height: gameHeight * scaleFactor,
                gameMinX: gameMinX,
                gameMaxX: gameMaxX,
                gameMinY: gameMinY,
                gameMaxY: gameMaxY,
                gameWidth: gameWidth,
                gameHeight: gameHeight,
                scaleFactor: scaleFactor
            };
            
            return { scaleX, scaleY };
        }

        function redrawStarmap() {
            if (!currentGameData || !svgElement) {
                return;
            }

            // Clear existing content
            svgElement.innerHTML = '';

            const { width, height } = calculateStarmapDimensions();
            const playerId = parseInt(currentGameData.rst?.player?.id, 10) || 0;
            
            // Update SVG dimensions
            svgElement.setAttribute('width', '100%');
            svgElement.setAttribute('height', '100%');
            
            // Set initial viewBox only if one doesn't exist (don't override zoom state)
            if (window.gameBounds && !svgElement.getAttribute('viewBox')) {
                const bounds = window.gameBounds;
                svgElement.setAttribute('viewBox', `${bounds.minX} ${bounds.minY} ${bounds.width} ${bounds.height}`);
            }
            
            // Get current zoom level for dynamic scaling
            const currentZoomLevel = getCurrentZoomLevel();
            
            // Calculate zoom-based scaling factor for element sizes (not coordinates)
            const elementScale = Math.max(0.2, Math.min(3.0, 1 / Math.sqrt(currentZoomLevel)));
            
            // Create proper scaling functions that include zoom adjustment
            const { scaleX, scaleY } = createScalingFunctions(width, height, currentGameData);
            const drawingContext = { scaleX, scaleY, width, height, elementScale };
            
            // Draw components based on display options
            if (document.getElementById('showNebulas')?.checked) {
                drawNebulas(svgElement, drawingContext);
            }
            
            if (document.getElementById('showPlanets')?.checked) {
                drawPlanets(svgElement, playerId, drawingContext);
            }
            
            if (document.getElementById('showShips')?.checked) {
                drawShips(svgElement, playerId, drawingContext);
            }

            // Restore selection after redraw using SelectionManager
            selectionManager.restoreSelection();

            // CRITICAL: Re-initialize pan/zoom after redraw to ensure event listeners are active
            // Use a longer delay to ensure SVG has proper dimensions after DOM layout
            setTimeout(() => {
                initializePanZoom();
            }, 200);

            updateZoomIndicator();
        }        function drawNebulas(parent, drawingContext) {
            const nebulas = currentGameData.rst?.nebulas || [];
            const { scaleX, scaleY } = drawingContext;
            
            // Calculate dynamic scaling based on zoom level (only for stroke properties)
            const currentZoomLevel = getCurrentZoomLevel();
            const zoomScale = 1 / currentZoomLevel;
            
            nebulas.forEach(nebula => {
                const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                const cx = scaleX(nebula.x || 0);
                const cy = scaleY(nebula.y || 0);
                const gameRadius = nebula.radius || 50;
                const scaledRadius = gameRadius * 0.5; // Fixed scale factor, NO zoom scaling
                
                circle.setAttribute("cx", cx);
                circle.setAttribute("cy", cy);
                circle.setAttribute("r", scaledRadius);
                circle.setAttribute("fill", Colors.NEBULA_FILL);
                circle.setAttribute("stroke", Colors.NEBULA_STROKE);
                circle.setAttribute("stroke-width", 2 * zoomScale);
                circle.setAttribute("stroke-dasharray", `${5 * zoomScale},${5 * zoomScale}`);
                circle.setAttribute("pointer-events", "none"); // Don't capture mouse events
                
                parent.appendChild(circle);
            });
        }

        function drawPlanets(parent, playerId, drawingContext) {
            const planets = currentGameData.rst?.planets || [];
            const starbases = currentGameData.rst?.starbases || [];
            const { scaleX, scaleY } = drawingContext;
            const starbaseMap = {};
            
            // Create starbase lookup
            starbases.forEach(sb => {
                starbaseMap[sb.planetid] = sb;
            });
            
            planets.forEach(planet => {
                drawSinglePlanet(parent, planet, starbaseMap, playerId, scaleX, scaleY);
            });
        }

        function drawSinglePlanet(parent, planet, starbaseMap, playerId, scaleX, scaleY) {
            if (!planet || planet.x === undefined || planet.y === undefined) return;
            
            const isOwned = parseInt(planet.ownerid, 10) === playerId;
            const isNeutral = parseInt(planet.ownerid, 10) === 0;
            const isAllied = window.alliedPlayerIds && window.alliedPlayerIds.includes(parseInt(planet.ownerid, 10));
            const hasStarbase = starbaseMap[planet.id];
            
            const cx = scaleX(planet.x);
            const cy = scaleY(planet.y);
            
            // Get current zoom level for element scaling
            const currentZoomLevel = getCurrentZoomLevel();
            const elementScale = Math.max(0.2, Math.min(3.0, 1 / Math.sqrt(currentZoomLevel)));
            
            // Apply element scaling to base sizes
            const radiusPx = 7.5 * elementScale;
            const fontSize = 10 * elementScale;
            const strokeWidth = 1 * elementScale;
            
            // Determine planet color based on ownership
            let planetColor;
            if (isOwned) {
                planetColor = Colors.MINE;        // Green - Mine
            } else if (isAllied) {
                planetColor = Colors.ALLIED;      // Light Blue - Allied
            } else if (!isNeutral && planet.ownerid > 0) {
                planetColor = Colors.ENEMY;      // Red - Enemy
            } else if (isNeutral) {
                planetColor = Colors.UNOWNED;    // Yellow - Unowned
            } else {
                planetColor = Colors.UNDISCOVERED; // Grey - Undiscovered
            }
            
            // Create 3D sphere effect using radial gradient
            const gradientId = `planetGradient${planet.id}`;
            const defs = parent.querySelector('defs') || document.createElementNS("http://www.w3.org/2000/svg", "defs");
            if (!parent.querySelector('defs')) {
                parent.appendChild(defs);
            }
            
            const gradient = document.createElementNS("http://www.w3.org/2000/svg", "radialGradient");
            gradient.setAttribute("id", gradientId);
            gradient.setAttribute("cx", "30%");
            gradient.setAttribute("cy", "30%");
            gradient.setAttribute("r", "70%");
            
            const stop1 = document.createElementNS("http://www.w3.org/2000/svg", "stop");
            stop1.setAttribute("offset", "0%");
            stop1.setAttribute("stop-color", lightenColor(planetColor, 0.4));
            
            const stop2 = document.createElementNS("http://www.w3.org/2000/svg", "stop");
            stop2.setAttribute("offset", "100%");
            stop2.setAttribute("stop-color", darkenColor(planetColor, 0.3));
            
            gradient.appendChild(stop1);
            gradient.appendChild(stop2);
            defs.appendChild(gradient);
            
            // Draw planet as 3D sphere
            const planetCircle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
            planetCircle.setAttribute("cx", cx);
            planetCircle.setAttribute("cy", cy);
            planetCircle.setAttribute("r", radiusPx);
            planetCircle.setAttribute("fill", `url(#${gradientId})`);
            planetCircle.setAttribute("stroke", "#ffffff");
            planetCircle.setAttribute("stroke-width", strokeWidth * 0.5);
            planetCircle.setAttribute("data-type", "planet");
            planetCircle.setAttribute("data-id", planet.id);
            
            // Add tooltip event listeners
            addTooltipEventListeners(planetCircle, planet, "planet");
            
            parent.appendChild(planetCircle);
            
            // Draw starbase as turquoise square if present
            if (hasStarbase) {
                const starbaseRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                const rectSize = 10 * elementScale;
                starbaseRect.setAttribute("x", cx - rectSize/2);
                starbaseRect.setAttribute("y", cy - rectSize/2);
                starbaseRect.setAttribute("width", rectSize);
                starbaseRect.setAttribute("height", rectSize);
                starbaseRect.setAttribute("fill", Colors.STARBASE);        // Turquoise
                starbaseRect.setAttribute("stroke", "#ffffff");
                starbaseRect.setAttribute("stroke-width", strokeWidth * 0.5);
                starbaseRect.setAttribute("data-type", "starbase");
                starbaseRect.setAttribute("data-id", hasStarbase.id);
                
                // Add tooltip event listeners for starbase
                addTooltipEventListeners(starbaseRect, hasStarbase, "starbase");
                
                parent.appendChild(starbaseRect);
            }
            
            // Add planet name label
            const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
            text.setAttribute("x", cx);
            text.setAttribute("y", cy + radiusPx + 15 * elementScale);
            text.setAttribute("text-anchor", "middle");
            text.setAttribute("font-family", "Arial, sans-serif");
            text.setAttribute("font-size", fontSize);
            text.setAttribute("fill", "#ffffff");
            text.setAttribute("pointer-events", "none"); // Don't capture mouse events
            text.textContent = (planet.name || `P${planet.id}`).substring(0, 12);
            
            parent.appendChild(text);
        }

        function drawShips(parent, playerId, drawingContext) {
            if (!currentGameData || !currentGameData.rst) return;
            
            const ships = currentGameData.rst?.ships || [];
            const planets = currentGameData.rst?.planets || [];
            const { scaleX, scaleY } = drawingContext;
            
            // Get current zoom level for element scaling
            const currentZoomLevel = getCurrentZoomLevel();
            const elementScale = Math.max(0.2, Math.min(3.0, 1 / Math.sqrt(currentZoomLevel)));
            
            // Convert planets to a lookup map for distance checking
            const planetMap = new Map();
            planets.forEach(planet => {
                planetMap.set(planet.id, planet);
            });
            
            ships.forEach(ship => {
                if (ship.x === undefined || ship.y === undefined) return;
                
                const isOwned = parseInt(ship.ownerid, 10) === playerId;
                const isAllied = window.alliedPlayerIds && window.alliedPlayerIds.includes(parseInt(ship.ownerid, 10));
                const cx = scaleX(ship.x);
                const cy = scaleY(ship.y);
                
                // Check if ship is over a planet (within 1 LY)
                let isOverPlanet = false;
                let nearestPlanet = null;
                let minDistance = Infinity;
                
                planets.forEach(planet => {
                    const distance = Math.sqrt(
                        Math.pow(ship.x - planet.x, 2) + 
                        Math.pow(ship.y - planet.y, 2)
                    );
                    if (distance <= 1 && distance < minDistance) { // Within 1 LY
                        isOverPlanet = true;
                        nearestPlanet = planet;
                        minDistance = distance;
                    }
                });
                
                if (isOverPlanet && nearestPlanet) {
                    // Ship over planet - draw orbit circle
                    const planetCx = scaleX(nearestPlanet.x);
                    const planetCy = scaleY(nearestPlanet.y);
                    
                    // Determine orbit radius based on ownership
                    let orbitRadiusLY;
                    let orbitColor;
                    
                    if (isOwned) {
                        orbitRadiusLY = 4;  // My ship: 4LY radius
                        orbitColor = Colors.SHIP_MINE_ORBIT;
                    } else if (isAllied) {
                        orbitRadiusLY = 5;  // Allied ship: 5LY radius
                        orbitColor = Colors.ALLIED;
                    } else {
                        orbitRadiusLY = 6;  // Enemy ship: 6LY radius
                        orbitColor = Colors.SHIP_ENEMY_ORBIT;
                    }
                    
                    // Convert LY to pixels (approximate scale factor)
                    const orbitRadiusPx = orbitRadiusLY * elementScale * 3; // Adjust multiplier as needed
                    
                    const orbitCircle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                    orbitCircle.setAttribute("cx", planetCx);
                    orbitCircle.setAttribute("cy", planetCy);
                    orbitCircle.setAttribute("r", orbitRadiusPx);
                    orbitCircle.setAttribute("fill", "none");
                    orbitCircle.setAttribute("stroke", orbitColor);
                    orbitCircle.setAttribute("stroke-width", 1.5 * elementScale);
                    orbitCircle.setAttribute("stroke-dasharray", "3,2");
                    orbitCircle.setAttribute("data-type", "ship");
                    orbitCircle.setAttribute("data-id", ship.id);
                    
                    // Add tooltip event listeners
                    addTooltipEventListeners(orbitCircle, ship, "ship");
                    
                    parent.appendChild(orbitCircle);
                    
                } else {
                    // Ship in space - draw small dot (1/4 size of planet)
                    const planetRadius = 7.5 * elementScale;
                    const shipRadius = planetRadius / 4;  // 1/4 size of planet
                    
                    let shipColor;
                    if (isOwned) {
                        shipColor = Colors.SHIP_MINE_SPACE;
                    } else if (isAllied) {
                        shipColor = Colors.ALLIED;
                    } else {
                        shipColor = Colors.SHIP_ENEMY_SPACE;
                    }
                    
                    const shipDot = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                    shipDot.setAttribute("cx", cx);
                    shipDot.setAttribute("cy", cy);
                    shipDot.setAttribute("r", shipRadius);
                    shipDot.setAttribute("fill", shipColor);
                    shipDot.setAttribute("stroke", "#ffffff");
                    shipDot.setAttribute("stroke-width", 0.5 * elementScale);
                    shipDot.setAttribute("data-type", "ship");
                    shipDot.setAttribute("data-id", ship.id);
                    
                    // Add tooltip event listeners
                    addTooltipEventListeners(shipDot, ship, "ship");
                    
                    parent.appendChild(shipDot);
                }
            });
        }

        function highlightObjectOnStarmap(objectType, objectId) {
            if (!svgElement) return;
            
            // Find the object element
            const objectElement = svgElement.querySelector(`[data-type="${objectType}"][data-id="${objectId}"]`);
            if (objectElement) {
                // Use the new SelectionManager
                selectionManager.selectObject(objectElement, objectType, objectId);
                
                // Center the view on the selected object
                centerViewOnObject(objectElement);
            }
            
            selectedObjectId = objectId;
            selectedObjectType = objectType;
        }

        function centerViewOnObject(element) {
            if (!element || !svgElement) return;
            
            const viewBoxAttr = svgElement.getAttribute('viewBox');
            if (!viewBoxAttr) return;
            
            const [vbX, vbY, vbWidth, vbHeight] = viewBoxAttr.split(' ').map(Number);
            
            // Get object position
            let objX, objY;
            if (element.getAttribute('cx')) {
                objX = parseFloat(element.getAttribute('cx'));
                objY = parseFloat(element.getAttribute('cy'));
            } else if (element.getAttribute('x')) {
                objX = parseFloat(element.getAttribute('x')) + parseFloat(element.getAttribute('width')) / 2;
                objY = parseFloat(element.getAttribute('y')) + parseFloat(element.getAttribute('height')) / 2;
            } else if (element.getAttribute('points')) {
                // For triangles (ships), calculate centroid
                const points = element.getAttribute('points').split(' ');
                const coords = points.map(p => p.split(',').map(Number));
                objX = coords.reduce((sum, coord) => sum + coord[0], 0) / coords.length;
                objY = coords.reduce((sum, coord) => sum + coord[1], 0) / coords.length;
            }
            
            // Check if object is within current view
            if (objX >= vbX && objX <= vbX + vbWidth && objY >= vbY && objY <= vbY + vbHeight) {
                return; // Object is already visible
            }
            
            // Position object in bottom third of view (so it stays visible above table)
            const newX = objX - vbWidth / 2;
            const newY = objY - vbHeight * 0.75; // Position at 75% down from top (bottom third)
            svgElement.setAttribute('viewBox', `${newX} ${newY} ${vbWidth} ${vbHeight}`);
        }

        // Helper functions for planet analysis
        function getResourceClass(value, type) {
            if (type === 'factories') {
                if (value >= 100) return 'resource-high';
                if (value >= 50) return 'resource-medium';
                return 'resource-low';
            } else if (type === 'defense') {
                if (value >= 50) return 'resource-high';
                if (value >= 20) return 'resource-medium';
                return 'resource-low';
            } else if (type === 'minerals') {
                if (value >= 1000) return 'resource-high';
                if (value >= 500) return 'resource-medium';
                return 'resource-low';
            }
            return '';
        }

        function getHappinessClass(value) {
            const happiness = parseInt(value, 10) || 0;
            if (happiness >= 70) return 'happiness-high';
            if (happiness >= 40) return 'happiness-medium';
            return 'happiness-low';
        }

        // Color manipulation helper functions for 3D sphere effect
        function lightenColor(color, percent) {
            const num = parseInt(color.replace("#",""), 16);
            const amt = Math.round(2.55 * percent * 100);
            const R = (num >> 16) + amt;
            const G = (num >> 8 & 0x00FF) + amt;
            const B = (num & 0x0000FF) + amt;
            return "#" + (0x1000000 + (R < 255 ? R < 1 ? 0 : R : 255) * 0x10000 +
                (G < 255 ? G < 1 ? 0 : G : 255) * 0x100 + (B < 255 ? B < 1 ? 0 : B : 255))
                .toString(16).slice(1);
        }

        function darkenColor(color, percent) {
            const num = parseInt(color.replace("#",""), 16);
            const amt = Math.round(2.55 * percent * 100);
            const R = (num >> 16) - amt;
            const G = (num >> 8 & 0x00FF) - amt;
            const B = (num & 0x0000FF) - amt;
            return "#" + (0x1000000 + (R > 255 ? 255 : R < 0 ? 0 : R) * 0x10000 +
                (G > 255 ? 255 : G < 0 ? 0 : G) * 0x100 + (B > 255 ? 255 : B < 0 ? 0 : B))
                .toString(16).slice(1);
        }

        function getTempClass(temp) {
            const temperature = parseInt(temp, 10) || 0;
            if (temperature >= 85) return 'temp-extreme';
            if (temperature >= 70) return 'temp-hot';
            if (temperature >= 30) return 'temp-moderate';
            if (temperature >= 15) return 'temp-cool';
            return 'temp-cold';
        }

        function getTechClass(level) {
            if (level >= 8) return 'tech-high';
            if (level >= 5) return 'tech-medium';
            return 'tech-low';
        }

        function calculateTotalMinerals(planet) {
            const neutronium = (planet.neutronium || 0) + (planet.densityneutronium || 0);
            const duranium = (planet.duranium || 0) + (planet.densityduranium || 0);
            const tritanium = (planet.tritanium || 0) + (planet.densitytritanium || 0);
            const molybdenum = (planet.molybdenum || 0) + (planet.densitymolybdenum || 0);
            return neutronium + duranium + tritanium + molybdenum;
        }

        function sortPlanets(planets) {
            return planets.sort((a, b) => {
                // First by factories (descending)
                const factoryDiff = (b.factories || 0) - (a.factories || 0);
                if (factoryDiff !== 0) return factoryDiff;
                
                // Then by defense (descending)
                const defenseDiff = (b.defense || 0) - (a.defense || 0);
                if (defenseDiff !== 0) return defenseDiff;
                
                // Then by total minerals (descending)
                const totalMineralsA = calculateTotalMinerals(a);
                const totalMineralsB = calculateTotalMinerals(b);
                return totalMineralsB - totalMineralsA;
            });
        }

        function sortStarbases(starbases, planets) {
            return starbases.sort((a, b) => {
                // First by defense (descending)
                const defenseDiff = (b.defense || 0) - (a.defense || 0);
                if (defenseDiff !== 0) return defenseDiff;
                
                // Then by fighters (descending)
                const fighterDiff = (b.fighters || 0) - (a.fighters || 0);
                if (fighterDiff !== 0) return fighterDiff;
                
                // Then by engine tech (descending)
                const engineDiff = (b.enginetech || 0) - (a.enginetech || 0);
                if (engineDiff !== 0) return engineDiff;
                
                // Then by hull tech (descending)
                const hullDiff = (b.hulltech || 0) - (a.hulltech || 0);
                if (hullDiff !== 0) return hullDiff;
                
                // Then by torpedo tech (descending)
                const torpDiff = (b.torptech || 0) - (a.torptech || 0);
                if (torpDiff !== 0) return torpDiff;
                
                // Finally by beam tech (descending)
                return (b.beamtech || 0) - (a.beamtech || 0);
            });
        }

        // Show status message
        // Helper functions for hull and race information
        function getHullInfo(hullId, gameData) {
            if (!hullId) return null;
            const hulls = gameData.rst?.hulls || [];
            return hulls.find(hull => parseInt(hull.id, 10) === parseInt(hullId, 10));
        }

        function getRaceInfo(raceId, gameData) {
            if (!raceId) return null;
            const races = gameData.rst?.races || [];
            return races.find(race => parseInt(race.id, 10) === parseInt(raceId, 10));
        }

        function getPlayerRace(ownerId, gameData) {
            // First find the player by ownerId
            const players = gameData.rst?.players || [];
            const player = players.find(p => parseInt(p.id, 10) === parseInt(ownerId, 10));
            
            if (!player) return null;
            
            // Then find the race by the player's raceid
            const races = gameData.rst?.races || [];
            const race = races.find(r => parseInt(r.id, 10) === parseInt(player.raceid, 10));
            return race ? race.adjective || race.name || race.shortname : null;
        }

        function getOwnerDisplayName(ownerId, playerId, gameData) {
            if (!ownerId) return "Unknown";
            const ownerIdNum = parseInt(ownerId, 10);
            const playerIdNum = parseInt(playerId, 10);
            
            if (ownerIdNum === playerIdNum) {
                return "You";
            }
            
            const raceInfo = getPlayerRace(ownerId, gameData);
            if (raceInfo) {
                return raceInfo;
            }
            
            return `Player ${ownerIdNum}`;
        }

        // Get starbase mission name from mission ID
        function getStarbaseMissionName(missionId) {
            const missions = {
                0: 'None',
                1: 'Refuel Ships',
                2: 'Maximize Defense',
                3: 'Load Torpedoes Onto Ships',
                4: 'Unload Incoming Ships',
                5: 'Repair Base',
                6: 'Force Surrender',
                7: 'Send Fighters to Galaxy',
                8: 'Gather Debris',
                9: 'Send Money to Galaxy',
                10: 'Receive Money from Galaxy',
                11: 'Send Fighters',
                12: 'Receive Fighters'
            };
            return missions[parseInt(missionId, 10)] || `Mission ${missionId}`;
        }

        // Get beam weapon information from beam ID
        function getBeamInfo(beamId, gameData) {
            if (!beamId || beamId === 0) return null;
            const beams = gameData.rst?.beams || [];
            return beams.find(beam => parseInt(beam.id, 10) === parseInt(beamId, 10));
        }

        // Get torpedo weapon information from torpedo ID
        function getTorpedoInfo(torpedoId, gameData) {
            if (!torpedoId || torpedoId === 0) return null;
            const torpedos = gameData.rst?.torpedos || [];
            return torpedos.find(torpedo => parseInt(torpedo.id, 10) === parseInt(torpedoId, 10));
        }

        function showStatus(message, type = 'loading') {
            const statusElement = document.getElementById('status');
            statusElement.textContent = message;
            statusElement.className = `status ${type}`;
            statusElement.classList.remove('hidden');
        }

        // Hide status message
        function hideStatus() {
            document.getElementById('status').classList.add('hidden');
        }

        // Show file information
        function showFileInfo(file, data) {
            const fileInfoElement = document.getElementById('fileInfo');
            const fileDetailsElement = document.getElementById('fileDetails');
            
            const fileSize = (file.size / 1024).toFixed(2);
            const turn = data.rst?.settings?.turn || 'Unknown';
            
            fileDetailsElement.innerHTML = `
                <div class="detail-item">
                    <span class="detail-label">Filename:</span> ${file.name}
                </div>
                <div class="detail-item">
                    <span class="detail-label">File Size:</span> ${fileSize} KB
                </div>
                <div class="detail-item">
                    <span class="detail-label">Turn:</span> ${turn}
                </div>
                <div class="detail-item">
                    <span class="detail-label">Last Modified:</span> ${new Date(file.lastModified).toLocaleString()}
                </div>
            `;
            
            fileInfoElement.classList.remove('hidden');
            currentFileName = file.name;
        }

        // Show game information
        function showGameInfo(gameData) {
            const gameInfoElement = document.getElementById('gameInfo');
            const gameDetailsElement = document.getElementById('gameDetails');
            
            // Extract race name from races array
            let raceName = 'Unknown';
            if (gameData.rst?.races && gameData.rst?.player?.raceid) {
                const raceId = parseInt(gameData.rst.player.raceid, 10);
                const playerRace = gameData.rst.races.find(race => parseInt(race.id, 10) === raceId);
                if (playerRace) {
                    raceName = playerRace.shortname || playerRace.name || 'Unknown';
                }
                console.log(`Found race: ${raceName} (ID: ${raceId})`);
            }
            
            // Extract key game information
            const gameInfo = {
                'Game Name': gameData.rst?.settings?.name || 'Unknown',
                'Game ID': gameData.rst?.game?.id || 'Unknown',
                'Turn': gameData.rst?.settings?.turn || 'Unknown',
                'Player Name': gameData.rst?.player?.username || 'Unknown',
                'Race': raceName,
                'Player ID': gameData.rst?.player?.id || 'Unknown',
                'Race ID': gameData.rst?.player?.raceid || 'Unknown',
                'Account ID': gameData.rst?.player?.accountid || 'Unknown',
                'Turn Ready': gameData.rst?.player?.turnready ? 'Yes' : 'No',
                'Ships': Array.isArray(gameData.rst?.ships) ? gameData.rst.ships.length : 0,
                'Planets': Array.isArray(gameData.rst?.planets) ? gameData.rst.planets.length : 0,
                'Starbases': Array.isArray(gameData.rst?.starbases) ? gameData.rst.starbases.length : 0,
                'VCR Battles': Array.isArray(gameData.rst?.vcrs) ? gameData.rst.vcrs.length : 0,
                'Messages': Array.isArray(gameData.rst?.messages) ? gameData.rst.messages.length : 0,
                'Ion Storms': Array.isArray(gameData.rst?.ionstorms) ? gameData.rst.ionstorms.length : 0
            };

            gameDetailsElement.innerHTML = Object.entries(gameInfo)
                .map(([label, value]) => `
                    <div class="detail-item">
                        <span class="detail-label">${label}:</span> ${value}
                    </div>
                `).join('');
            
            gameInfoElement.classList.remove('hidden');
        }

        // Show data sections
        function showDataSections(gameData) {
            const dataSectionsElement = document.getElementById('dataSections');
            const tabContentElement = document.getElementById('tab-content');

            // Get player ID for ownership checks
            const playerId = parseInt(gameData.rst?.player?.id, 10) || 0;
            const playerRaceId = parseInt(gameData.rst?.player?.raceid, 10) || 0;
            
            // Filter data by ownership
            const planets = gameData.rst?.planets || [];
            const starbases = gameData.rst?.starbases || [];
            const ships = gameData.rst?.ships || [];

            console.log('Starbases data:', starbases);

            const ownedPlanets = planets.filter(planet => parseInt(planet.ownerid, 10) === playerId);
            
            // Filter enemy planets - exclude owned planets, unoccupied planets, and allied planets
            const enemyPlanets = planets.filter(planet => {
                const ownerId = parseInt(planet.ownerid, 10);
                
                // Exclude unoccupied planets
                if (ownerId === 0) return false;
                
                // Exclude owned planets
                if (ownerId === playerId) return false;
                
                // Exclude allied planets if alliance data is available
                if (window.alliedPlayerIds && window.alliedPlayerIds.includes(ownerId)) {
                    return false;
                }
                
                return true;
            });
            
            // Filter starbases by planet ownership and enhance with planet data
            const myStarbases = starbases.filter(sb => {
                const planet = planets.find(p => p.id === sb.planetid);
                return planet && parseInt(planet.ownerid, 10) === playerId;
            }).map(sb => {
                const planet = planets.find(p => p.id === sb.planetid);
                return {
                    ...sb,
                    // Add planet data for supplies and megacredits
                    supplies: planet ? planet.supplies : 0,
                    megacredits: planet ? planet.megacredits : 0,
                    planetname: planet ? planet.name : `Planet ${sb.planetid}`,
                    x: planet ? planet.x : 0,
                    y: planet ? planet.y : 0
                };
            });
            const enemyStarbases = starbases.filter(sb => {
                const planet = planets.find(p => p.id === sb.planetid);
                if (!planet) return false;
                
                const ownerId = parseInt(planet.ownerid, 10);
                
                // Exclude unoccupied planets
                if (ownerId === 0) return false;
                
                // Exclude owned planets
                if (ownerId === playerId) return false;
                
                // Exclude allied planets if alliance data is available
                if (window.alliedPlayerIds && window.alliedPlayerIds.includes(ownerId)) {
                    return false;
                }
                
                return true;
            }).map(sb => {
                const planet = planets.find(p => p.id === sb.planetid);
                return {
                    ...sb,
                    // Add planet data for supplies and megacredits
                    supplies: planet ? planet.supplies : 0,
                    megacredits: planet ? planet.megacredits : 0,
                    planetname: planet ? planet.name : `Planet ${sb.planetid}`,
                    x: planet ? planet.x : 0,
                    y: planet ? planet.y : 0
                };
            });
            
            console.log(`Found ${starbases.length} total starbases, ${myStarbases.length} owned by player, ${enemyStarbases.length} enemy starbases`);
            
            const myShips = ships.filter(ship => parseInt(ship.ownerid, 10) === playerId);
            
            // Filter enemy ships - exclude owned ships, unoccupied ships, and allied ships
            const enemyShips = ships.filter(ship => {
                const ownerId = parseInt(ship.ownerid, 10);
                
                // Exclude unoccupied ships
                if (ownerId === 0) return false;
                
                // Exclude owned ships
                if (ownerId === playerId) return false;
                
                // Exclude allied ships if alliance data is available
                if (window.alliedPlayerIds && window.alliedPlayerIds.includes(ownerId)) {
                    return false;
                }
                
                return true;
            });
            
            // Create tab content
            const starbaseRequirements = calculateStarbaseRequirements(ownedPlanets, starbases, playerId);
            
            const tabContent = `
                <div id="my-planets-tab" class="tab-section active">
                    <h3>🪐 My Planets (${ownedPlanets.length})</h3>
                    <div id="my-planets-container"></div>
                </div>

                <div id="my-starbases-tab" class="tab-section">
                    <h3>🏭 My Starbases (${myStarbases.length})</h3>
                    <div id="my-starbases-container"></div>
                </div>

                <div id="future-starbases-tab" class="tab-section">
                    <h3>🏗️ Future Starbases (${starbaseRequirements.length})</h3>
                    <div id="future-starbases-container"></div>
                </div>

                <div id="enemy-starbases-tab" class="tab-section">
                    <h3>🏭 Enemy Starbases (${enemyStarbases.length})</h3>
                    <div id="enemy-starbases-container"></div>
                </div>

                <div id="enemy-planets-tab" class="tab-section">
                    <h3>� Enemy Planets (${enemyPlanets.length})</h3>
                    <div id="enemy-planets-container"></div>
                </div>

                <div id="my-ships-tab" class="tab-section">
                    <h3>🚢 My Ships (${myShips.length})</h3>
                    <div id="my-ships-container"></div>
                </div>

                <div id="enemy-ships-tab" class="tab-section">
                    <h3>🚢 Enemy Ships (${enemyShips.length})</h3>
                    <div id="enemy-ships-container"></div>
                </div>

                <div id="allied-planets-tab" class="tab-section">
                    <h3>🪐 Allied Planets</h3>
                    <div id="allied-planets-table" class="vgap-table-container"></div>
                </div>

                <div id="allied-starbases-tab" class="tab-section">
                    <h3>🏭 Allied Starbases</h3>
                    <div id="allied-starbases-table" class="vgap-table-container"></div>
                </div>

                <div id="allied-ships-tab" class="tab-section">
                    <h3>🚢 Allied Ships</h3>
                    <div id="allied-ships-table" class="vgap-table-container"></div>
                </div>

                <div id="other-data-tab" class="tab-section">
                    <h3>📋 Other Game Data</h3>
                    ${createOtherDataSection(gameData)}
                </div>
            `;

            tabContentElement.innerHTML = tabContent;

            // Now populate tables using the new TableManager system
            if (window.tableManager) {
                try {
                    // My Planets
                    if (ownedPlanets.length > 0) {
                        window.tableManager.createPlanetsTable('my-planets-container', ownedPlanets, starbases);
                    } else {
                        document.getElementById('my-planets-container').innerHTML = '<p>No owned planets found.</p>';
                    }

                    // My Starbases
                    if (myStarbases.length > 0) {
                        window.tableManager.createStarbasesTable('my-starbases-container', myStarbases);
                    } else {
                        document.getElementById('my-starbases-container').innerHTML = '<p>No starbases found.</p>';
                    }

                    // Future Starbases
                    if (starbaseRequirements.length > 0) {
                        // Use specialized table for starbase candidates with readiness info
                        window.tableManager.createFutureStarbasesTable('future-starbases-container', starbaseRequirements);
                    } else {
                        document.getElementById('future-starbases-container').innerHTML = '<p>No starbase candidates found. Build up resources on your planets!</p>';
                    }

                    // Enemy Starbases
                    if (enemyStarbases.length > 0) {
                        window.tableManager.createStarbasesTable('enemy-starbases-container', enemyStarbases);
                    } else {
                        document.getElementById('enemy-starbases-container').innerHTML = '<p>No enemy starbases found.</p>';
                    }

                    // Enemy Planets
                    if (enemyPlanets.length > 0) {
                        window.tableManager.createPlanetsTable('enemy-planets-container', enemyPlanets, starbases, true);
                    } else {
                        document.getElementById('enemy-planets-container').innerHTML = '<p>No enemy planets found.</p>';
                    }

                    // My Ships
                    if (myShips.length > 0) {
                        window.tableManager.createShipsTable('my-ships-container', myShips);
                    } else {
                        document.getElementById('my-ships-container').innerHTML = '<p>No ships found.</p>';
                    }

                    // Enemy Ships
                    if (enemyShips.length > 0) {
                        window.tableManager.createShipsTable('enemy-ships-container', enemyShips);
                    } else {
                        document.getElementById('enemy-ships-container').innerHTML = '<p>No enemy ships found.</p>';
                    }

                    // Allied Planets
                    if (window.alliedPlayerIds && window.alliedPlayerIds.length > 0) {
                        const alliedPlanets = planets.filter(p => window.alliedPlayerIds.includes(parseInt(p.ownerid, 10)));
                        if (alliedPlanets.length > 0) {
                            window.tableManager.createPlanetsTable('allied-planets-table', alliedPlanets, starbases, true);
                        } else {
                            document.getElementById('allied-planets-table').innerHTML = '<p>No allied planets found.</p>';
                        }
                    }

                    // Allied Starbases
                    if (window.alliedPlayerIds && window.alliedPlayerIds.length > 0) {
                        const alliedStarbases = starbases.filter(sb => {
                            const planet = planets.find(p => p.id === sb.planetid);
                            return planet && window.alliedPlayerIds.includes(parseInt(planet.ownerid, 10));
                        }).map(sb => {
                            const planet = planets.find(p => p.id === sb.planetid);
                            return {
                                ...sb,
                                // Add planet data for supplies and megacredits
                                supplies: planet ? planet.supplies : 0,
                                megacredits: planet ? planet.megacredits : 0,
                                planetname: planet ? planet.name : `Planet ${sb.planetid}`,
                                x: planet ? planet.x : 0,
                                y: planet ? planet.y : 0
                            };
                        });
                        if (alliedStarbases.length > 0) {
                            window.tableManager.createStarbasesTable('allied-starbases-table', alliedStarbases);
                        } else {
                            document.getElementById('allied-starbases-table').innerHTML = '<p>No allied starbases found.</p>';
                        }
                    }

                    // Allied Ships
                    if (window.alliedPlayerIds && window.alliedPlayerIds.length > 0) {
                        const alliedShips = ships.filter(s => window.alliedPlayerIds.includes(parseInt(s.ownerid, 10)));
                        if (alliedShips.length > 0) {
                            window.tableManager.createShipsTable('allied-ships-table', alliedShips);
                        } else {
                            document.getElementById('allied-ships-table').innerHTML = '<p>No allied ships found.</p>';
                        }
                    }

                    console.log('✅ All tables converted to use modern TableManager system');
                } catch (error) {
                    console.error('❌ Error creating tables with TableManager:', error);
                    // Fallback to basic error message
                    Object.keys({
                        'my-planets-container': ownedPlanets,
                        'my-starbases-container': myStarbases, 
                        'enemy-starbases-container': enemyStarbases,
                        'enemy-planets-container': enemyPlanets,
                        'my-ships-container': myShips,
                        'enemy-ships-container': enemyShips
                    }).forEach(containerId => {
                        const container = document.getElementById(containerId);
                        if (container && container.children.length === 0) {
                            container.innerHTML = '<p style="color: #F44336;">Error loading table. Check console for details.</p>';
                        }
                    });
                }
            } else {
                console.error('❌ TableManager not available - cannot create modern tables');
            }
            dataSectionsElement.classList.remove('hidden');

            // Reset initialization flag since DOM elements are new
            starmapInitialized = false;
            
            // Initialize starmap
            initializeStarmap();
            
            // Add close button event listener
            document.getElementById('closeStarmap').addEventListener('click', hideStarmapPanel);
            
            // Draw initial starmap
            setTimeout(() => {
                redrawStarmap();
            }, 300);

            // Initialize tab switching
            initializeTabs();

            // Initialize table sorting for all tables
            if (ownedPlanets.length > 0) {
                const myPlanetsTable = document.querySelector('#my-planets-tab table.vgap-table');
                if (myPlanetsTable) {
                    initializeTableSorting(myPlanetsTable, ownedPlanets, 'planets', gameData, planets, starbases);
                    // Add initial click handlers
                    const tbody = myPlanetsTable.querySelector('tbody');
                    if (tbody) addTableRowClickHandlers(tbody, 'planets', ownedPlanets);
                }
            }

            if (myStarbases.length > 0) {
                const myStarbasesTable = document.querySelector('#my-starbases-tab table.vgap-table');
                if (myStarbasesTable) {
                    initializeTableSorting(myStarbasesTable, myStarbases, 'starbases', gameData, planets, starbases);
                    // Add initial click handlers
                    const tbody = myStarbasesTable.querySelector('tbody');
                    if (tbody) addTableRowClickHandlers(tbody, 'starbases', myStarbases);
                }
            }

            // Initialize starbase requirements table (legacy table - no longer used)
            // Future starbases now use TableManager system with proper planet object type

            if (enemyStarbases.length > 0) {
                const enemyStarbasesTable = document.querySelector('#enemy-starbases-tab table.vgap-table');
                if (enemyStarbasesTable) {
                    initializeTableSorting(enemyStarbasesTable, enemyStarbases, 'starbases', gameData, planets, starbases);
                    // Add initial click handlers
                    const tbody = enemyStarbasesTable.querySelector('tbody');
                    if (tbody) addTableRowClickHandlers(tbody, 'starbases', enemyStarbases);
                }
            }

            if (enemyPlanets.length > 0) {
                const enemyPlanetsTable = document.querySelector('#enemy-planets-tab table.vgap-table');
                if (enemyPlanetsTable) {
                    initializeTableSorting(enemyPlanetsTable, enemyPlanets, 'planets', gameData, planets, starbases);
                    // Add initial click handlers
                    const tbody = enemyPlanetsTable.querySelector('tbody');
                    if (tbody) addTableRowClickHandlers(tbody, 'planets', enemyPlanets);
                }
            }

            if (myShips.length > 0) {
                const myShipsTable = document.querySelector('#my-ships-tab table.vgap-table');
                if (myShipsTable) {
                    initializeTableSorting(myShipsTable, myShips, 'ships', gameData, planets, starbases);
                    // Add initial click handlers
                    const tbody = myShipsTable.querySelector('tbody');
                    if (tbody) addTableRowClickHandlers(tbody, 'ships', myShips);
                }
            }

            if (enemyShips.length > 0) {
                const enemyShipsTable = document.querySelector('#enemy-ships-tab table.vgap-table');
                if (enemyShipsTable) {
                    initializeTableSorting(enemyShipsTable, enemyShips, 'ships', gameData, planets, starbases);
                    // Add initial click handlers
                    const tbody = enemyShipsTable.querySelector('tbody');
                    if (tbody) addTableRowClickHandlers(tbody, 'ships', enemyShips);
                }
            }
        }

        // Initialize tab switching functionality
        function initializeTabs() {
            const tabButtons = document.querySelectorAll('.tab-button');
            const tabSections = document.querySelectorAll('.tab-section');

            // Set first tab as active by default
            if (tabButtons.length > 0 && tabSections.length > 0) {
                tabButtons[0].classList.add('active');
                tabSections[0].classList.add('active');
            }

            // Add click event listeners to tab buttons
            tabButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const tabId = button.getAttribute('data-tab');

                    // Remove active class from all buttons and sections
                    tabButtons.forEach(btn => btn.classList.remove('active'));
                    tabSections.forEach(section => section.classList.remove('active'));

                    // Add active class to clicked button and corresponding section
                    button.classList.add('active');
                    const targetSection = document.getElementById(tabId + '-tab');
                    if (targetSection) {
                        targetSection.classList.add('active');
                    }
                });
            });
        }

        // Create other data section for messages, VCRs, etc.
        function createOtherDataSection(gameData) {
            const sections = [
                {
                    title: '⚔️ VCR Battles',
                    data: gameData.rst?.vcrs || [],
                    formatter: (vcr) => `
                        <strong>Battle ${vcr.battletype || 'Unknown'}:</strong><br>
                        <span style="opacity: 0.8;">Location: (${vcr.x || 0}, ${vcr.y || 0})</span><br>
                        <span style="opacity: 0.8;">Left: ${vcr.left?.name || 'Unknown'} vs Right: ${vcr.right?.name || 'Unknown'}</span>
                    `
                },
                {
                    title: '📨 Messages',
                    data: gameData.rst?.messages || [],
                    formatter: (msg) => `
                        <strong>From Player ${msg.ownerid || 'Unknown'}:</strong><br>
                        <span style="opacity: 0.8;">${(msg.body || 'No message content').substring(0, 100)}${msg.body && msg.body.length > 100 ? '...' : ''}</span>
                    `
                },
                {
                    title: '🌪️ Ion Storms',
                    data: gameData.rst?.ionstorms || [],
                    formatter: (storm) => `
                        <strong>Storm ID ${storm.id}:</strong><br>
                        <span style="opacity: 0.8;">Location: (${storm.x || 0}, ${storm.y || 0}) | Voltage: ${storm.voltage || 0}</span><br>
                        <span style="opacity: 0.8;">Radius: ${storm.radius || 0} ly | Heading: ${storm.heading || 0}°</span>
                    `
                }
            ];

            return sections
                .filter(section => section.data.length > 0)
                .map(section => `
                    <div class="data-section">
                        <h4>${section.title} (${section.data.length})</h4>
                        <div class="data-list">
                            ${section.data.slice(0, 50).map(item => `
                                <div class="data-item">${section.formatter(item)}</div>
                            `).join('')}
                            ${section.data.length > 50 ? `<div class="data-item"><em>... and ${section.data.length - 50} more items</em></div>` : ''}
                        </div>
                    </div>
                `).join('') || '<p>No additional data found.</p>';
        }

        // Table sorting functionality
        let currentSort = { column: null, direction: 'asc' };

        // Generic sorting function
        function sortData(data, column, direction = 'asc', gameData = null) {
            try {
                return [...data].sort((a, b) => {
                    let aVal, bVal;

                    // Handle different column types
                    switch (column) {
                        case 'name':
                            aVal = (a.name || '').toLowerCase();
                            bVal = (b.name || '').toLowerCase();
                            break;
                        case 'id':
                            aVal = parseInt(a.id, 10) || 0;
                            bVal = parseInt(b.id, 10) || 0;
                            break;
                        case 'x':
                        case 'y':
                            aVal = parseInt(a[column], 10) || 0;
                            bVal = parseInt(b[column], 10) || 0;
                            break;
                    case 'colonists':
                    case 'clans':
                    case 'nativeclans':
                    case 'temp':
                    case 'factories':
                    case 'mines':
                    case 'defense':
                    case 'neutronium':
                    case 'duranium':
                    case 'tritanium':
                    case 'molybdenum':
                    case 'densityneutronium':
                    case 'densityduranium':
                    case 'densitytritanium':
                    case 'densitymolybdenum':
                    case 'crew':
                    case 'mass':
                    case 'damage':
                    case 'beams':
                    case 'torps':
                    case 'hull':
                    case 'engines':
                    case 'enginetechlevel':
                    case 'hulltechlevel':
                    case 'torptechlevel':
                    case 'beamtechlevel':
                    case 'mission':
                        aVal = parseInt(a[column], 10);
                        bVal = parseInt(b[column], 10);
                        // Handle -1 values (unknown data) by treating as 0
                        if (isNaN(aVal) || aVal === -1) aVal = 0;
                        if (isNaN(bVal) || bVal === -1) bVal = 0;
                        break;
                    case 'colonisthappypoints':
                    case 'nativehappypoints':
                        aVal = parseInt(a[column], 10) || 0;
                        bVal = parseInt(b[column], 10) || 0;
                        break;
                    case 'friendlycode':
                        aVal = (a[column] || '').toUpperCase();
                        bVal = (b[column] || '').toUpperCase();
                        break;
                    case 'nativeracename':
                    case 'nativegovernmentname':
                        aVal = (a[column] || '').toLowerCase();
                        bVal = (b[column] || '').toLowerCase();
                        break;
                    case 'hullname':
                        // For hull column, get the computed hull name for sorting
                        const aHullInfoName = gameData ? getHullInfo(a.hullid, gameData) : null;
                        const bHullInfoName = gameData ? getHullInfo(b.hullid, gameData) : null;
                        aVal = aHullInfoName ? (aHullInfoName.name || '').toLowerCase() : (a.hullname || '').toLowerCase();
                        bVal = bHullInfoName ? (bHullInfoName.name || '').toLowerCase() : (b.hullname || '').toLowerCase();
                        break;
                    case 'ownerid':
                        // For race column, get the race name for sorting
                        const aRaceInfo = gameData ? getPlayerRace(a.ownerid, gameData) : null;
                        const bRaceInfo = gameData ? getPlayerRace(b.ownerid, gameData) : null;
                        aVal = (aRaceInfo || getOwnerDisplayName(a.ownerid, gameData?.rst?.player?.id, gameData) || '').toLowerCase();
                        bVal = (bRaceInfo || getOwnerDisplayName(b.ownerid, gameData?.rst?.player?.id, gameData) || '').toLowerCase();
                        break;
                    case 'hullmass':
                        // For hull mass column, get the hull mass
                        const aHullInfoMass = gameData ? getHullInfo(a.hullid, gameData) : null;
                        const bHullInfoMass = gameData ? getHullInfo(b.hullid, gameData) : null;
                        aVal = aHullInfoMass ? (aHullInfoMass.mass || 0) : 0;
                        bVal = bHullInfoMass ? (bHullInfoMass.mass || 0) : 0;
                        break;
                    case 'hullcargo':
                        // For hull cargo column, get the hull cargo
                        const aHullInfoCargo = gameData ? getHullInfo(a.hullid, gameData) : null;
                        const bHullInfoCargo = gameData ? getHullInfo(b.hullid, gameData) : null;
                        aVal = aHullInfoCargo ? (aHullInfoCargo.cargo || 0) : 0;
                        bVal = bHullInfoCargo ? (bHullInfoCargo.cargo || 0) : 0;
                        break;
                    // Starbase requirements columns
                    case 'status':
                        aVal = (a.status || '').toLowerCase();
                        bVal = (b.status || '').toLowerCase();
                        break;
                    case 'progress':
                        aVal = parseFloat(a.progress) || 0;
                        bVal = parseFloat(b.progress) || 0;
                        break;
                    case 'connections':
                        aVal = parseInt(a.connectionCount, 10) || 0;
                        bVal = parseInt(b.connectionCount, 10) || 0;
                        break;
                    case 'duranium_need':
                        aVal = parseInt(a.missingResources?.duranium, 10) || 0;
                        bVal = parseInt(b.missingResources?.duranium, 10) || 0;
                        break;
                    case 'tritanium_need':
                        aVal = parseInt(a.missingResources?.tritanium, 10) || 0;
                        bVal = parseInt(b.missingResources?.tritanium, 10) || 0;
                        break;
                    case 'molybdenum_need':
                        aVal = parseInt(a.missingResources?.molybdenum, 10) || 0;
                        bVal = parseInt(b.missingResources?.molybdenum, 10) || 0;
                        break;
                    case 'megacredits_need':
                        aVal = parseInt(a.missingResources?.megacredits, 10) || 0;
                        bVal = parseInt(b.missingResources?.megacredits, 10) || 0;
                        break;
                    case 'duranium_current':
                        aVal = parseInt(a.planet?.duranium, 10) || 0;
                        bVal = parseInt(b.planet?.duranium, 10) || 0;
                        break;
                    case 'tritanium_current':
                        aVal = parseInt(a.planet?.tritanium, 10) || 0;
                        bVal = parseInt(b.planet?.tritanium, 10) || 0;
                        break;
                    case 'molybdenum_current':
                        aVal = parseInt(a.planet?.molybdenum, 10) || 0;
                        bVal = parseInt(b.planet?.molybdenum, 10) || 0;
                        break;
                    case 'megacredits_current':
                        aVal = parseInt(a.planet?.megacredits, 10) || 0;
                        bVal = parseInt(b.planet?.megacredits, 10) || 0;
                        break;
                    default:
                        aVal = a[column] || '';
                        bVal = b[column] || '';
                }

                // Handle string comparison
                if (typeof aVal === 'string' && typeof bVal === 'string') {
                    const comparison = aVal.localeCompare(bVal);
                    return direction === 'asc' ? comparison : -comparison;
                }

                // Handle numeric comparison
                if (aVal < bVal) return direction === 'asc' ? -1 : 1;
                if (aVal > bVal) return direction === 'asc' ? 1 : -1;
                return 0;
            });
            } catch (error) {
                console.error('Error in sortData:', error);
                return [...data]; // Return unsorted data if error occurs
            }
        }

        // Initialize table sorting
        function initializeTableSorting(tableElement, data, tableType, gameData, planets = null, starbases = null) {
            const headers = tableElement.querySelectorAll('th[data-column]');

            headers.forEach((header) => {
                const column = header.getAttribute('data-column');
                if (!column) return;

                header.addEventListener('click', () => {
                    try {
                        // Toggle sort direction if same column, otherwise set to ascending
                        if (currentSort.column === column) {
                            currentSort.direction = currentSort.direction === 'asc' ? 'desc' : 'asc';
                        } else {
                            currentSort.column = column;
                            currentSort.direction = 'asc';
                        }

                        // Clear previous sort indicators
                        tableElement.querySelectorAll('th').forEach(h => {
                            h.classList.remove('sort-asc', 'sort-desc');
                        });

                        // Add sort indicator to clicked header
                        header.classList.add(`sort-${currentSort.direction}`);

                        // Sort and re-render table
                        const sortedData = sortData(data, column, currentSort.direction, gameData);
                        updateTableContent(tableElement, sortedData, tableType, gameData, planets, starbases);
                    } catch (error) {
                        console.error('Error in sort click handler:', error);
                    }
                });
            });
        }

        // Update table content after sorting
        function updateTableContent(tableElement, data, tableType, gameData, planets = null, starbases = null) {
            const tbody = tableElement.querySelector('tbody');
            if (!tbody) {
                console.error('No tbody found in table element');
                return;
            }
            
            let newContent = '';

            try {
                if (tableType === 'planets') {
                newContent = data.map(planet => {
                    const hasStarbase = starbases?.some(sb => sb.planetid === planet.id);
                    const totalMinerals = calculateTotalMinerals(planet);

                    return `
                        <tr>
                            <td class="planet-name" title="${planet.name || 'Unnamed'}">${(planet.name || 'Unnamed').substring(0, 12)}</td>
                            <td>${planet.id}</td>
                            <td>(${planet.x || 0}, ${planet.y || 0})</td>
                            <td class="friendly-code">${planet.friendlycode || ''}</td>
                            <td class="${getTempClass(planet.temp >= 0 ? planet.temp : 0)}">${planet.temp >= 0 ? planet.temp + '°' : '?'}</td>
                            <td>${formatPopulation(planet.clans)}</td>
                            <td>${formatPopulation(planet.nativeclans)}</td>
                            <td class="native-race">${planet.nativeracename || '-'}</td>
                            <td class="native-gov">${planet.nativegovernmentname || '-'}</td>
                            <td class="${getResourceClass(planet.factories || 0, 'factories')}">${planet.factories || 0}</td>
                            <td>${planet.mines || 0}</td>
                            <td class="${getResourceClass(planet.defense || 0, 'defense')}">${planet.defense || 0}</td>
                            <td class="${getHappinessClass(planet.colonisthappypoints || 0)}">${planet.colonisthappypoints || 0}%</td>
                            <td class="${getHappinessClass(planet.nativehappypoints || 0)}">${planet.nativehappypoints || 0}%</td>
                            <td class="${hasStarbase ? 'starbase-yes' : 'starbase-no'}">${hasStarbase ? 'true' : 'false'}</td>
                            <td>${planet.neutronium || 0}</td>
                            <td>${planet.duranium || 0}</td>
                            <td>${planet.tritanium || 0}</td>
                            <td>${planet.molybdenum || 0}</td>
                            <td>${planet.densityneutronium || 0}</td>
                            <td>${planet.densityduranium || 0}</td>
                            <td>${planet.densitytritanium || 0}</td>
                            <td>${planet.densitymolybdenum || 0}</td>
                            <td class="${getResourceClass(totalMinerals, 'minerals')}">${totalMinerals}</td>
                        </tr>
                    `;
                }).join('');
            } else if (tableType === 'ships') {
                newContent = data.map(ship => {
                    const planetAtLocation = planets?.find(p =>
                        parseInt(p.x, 10) === parseInt(ship.x, 10) &&
                        parseInt(p.y, 10) === parseInt(ship.y, 10)
                    );
                    const planetName = planetAtLocation ? (planetAtLocation.name || `Planet ${planetAtLocation.id}`) : 'None';
                    
                    // Get enhanced hull and race information
                    const hullInfo = getHullInfo(ship.hullid, gameData);
                    const raceInfo = getPlayerRace(ship.ownerid, gameData);
                    const shipDisplayName = hullInfo ? `${ship.name || 'Unnamed'} (${hullInfo.name})` : (ship.name || 'Unnamed');

                    // Get weapon information
                    const beamInfo = getBeamInfo(ship.beamid, gameData);
                    const torpedoInfo = getTorpedoInfo(ship.torpedoid, gameData);
                    
                    // Format beam display
                    const beamDisplay = ship.beams > 0 && beamInfo ? 
                        `${ship.beams} ${beamInfo.name}` : 
                        `${ship.beams || 0}`;
                    
                    // Format torpedo display  
                    const torpedoDisplay = ship.torps > 0 && torpedoInfo ?
                        `${ship.torps} ${torpedoInfo.name}` :
                        `${ship.torps || 0}`;

                    return `
                        <tr>
                            <td class="ship-name" title="${shipDisplayName}">${shipDisplayName.substring(0, 18)}</td>
                            <td>${ship.id}</td>
                            <td>${raceInfo || getOwnerDisplayName(ship.ownerid, gameData.rst?.player?.id, gameData)}</td>
                            <td>${hullInfo ? hullInfo.name : (ship.hullname || 'Unknown')}</td>
                            <td>${hullInfo ? hullInfo.mass || 0 : 0} kt</td>
                            <td>${hullInfo ? hullInfo.cargo || 0 : 0} kt</td>
                            <td>(${ship.x || 0}, ${ship.y || 0})</td>
                            <td>${planetName}</td>
                            <td>${formatPopulation(ship.crew)}</td>
                            <td>${ship.mass || 0} kt</td>
                            <td>${ship.neutronium || 0} kt</td>
                            <td class="${ship.damage > 40 ? 'resource-low' : 'resource-high'}">${ship.damage || 0}%</td>
                            <td title="${beamInfo ? `${beamInfo.name} (Damage: ${beamInfo.damage}, Kill: ${beamInfo.crewkill})` : ''}">${beamDisplay}</td>
                            <td title="${torpedoInfo ? `${torpedoInfo.name} (Damage: ${torpedoInfo.damage}, Kill: ${torpedoInfo.crewkill})` : ''}">${torpedoDisplay}</td>
                            <td>${ship.fighters || 0}</td>
                        </tr>
                    `;
                }).join('');
            } else if (tableType === 'starbases') {
                newContent = data.map(starbase => {
                    const planet = planets?.find(p => p.id === starbase.planetid);
                    const planetName = planet ? (planet.name || `Planet ${planet.id}`) : 'Unknown';

                    return `
                        <tr>
                            <td class="planet-name" title="${planetName}">${planetName.substring(0, 12)}</td>
                            <td>${starbase.id}</td>
                            <td>(${planet?.x || 0}, ${planet?.y || 0})</td>
                            <td class="${getResourceClass(starbase.defense || 0, 'defense')}">${starbase.defense || 0}</td>
                            <td>${starbase.fighters || 0}</td>
                            <td class="${getTechClass(starbase.enginetechlevel || 0)}">${starbase.enginetechlevel || 0}</td>
                            <td class="${getTechClass(starbase.hulltechlevel || 0)}">${starbase.hulltechlevel || 0}</td>
                            <td class="${getTechClass(starbase.torptechlevel || 0)}">${starbase.torptechlevel || 0}</td>
                            <td class="${getTechClass(starbase.beamtechlevel || 0)}">${starbase.beamtechlevel || 0}</td>
                            <td class="${(starbase.damage || 0) > 40 ? 'resource-low' : 'resource-high'}">${starbase.damage || 0}%</td>
                            <td title="${starbase.mission || 0}">${getStarbaseMissionName(starbase.mission || 0)}</td>
                        </tr>
                    `;
                }).join('');
            } else if (tableType === 'starbase-requirements') {
                newContent = data.map(req => {
                    const statusIcon = req.isBuildingStarbase ? '🏗️' : 
                                      req.avgCompletion >= 85 ? '🟢' : 
                                      req.avgCompletion >= 50 ? '🟡' : '🔴';
                    const statusText = req.isBuildingStarbase ? 'Building' : 
                                      req.avgCompletion >= 85 ? 'Ready' : 
                                      req.avgCompletion >= 50 ? 'Close' : 'Need Resources';
                    
                    const connectionIcon = req.hasFullSupport ? '🤝' : 
                                          req.connectionCount > 0 ? '🔗' : '⚠️';
                    const connectionText = req.hasFullSupport ? 'Full Support' : 
                                          req.connectionCount > 0 ? `${req.connectionCount} suppliers` : 'No support';
                    
                    const rowClass = req.isBuildingStarbase ? 'building-starbase' : 
                                   req.hasFullSupport ? 'connected-starbase' :
                                   req.avgCompletion >= 85 ? 'ready-starbase' : '';
                    
                    return `
                        <tr class="${rowClass}" data-planet-id="${req.planet.id}">
                            <td class="planet-name" title="${req.planet.name}">${req.planet.name?.substring(0, 12) || 'Unknown'}</td>
                            <td class="status-cell">${statusIcon} ${statusText}</td>
                            <td class="progress-cell">
                                <div class="progress-bar">
                                    <div class="progress-fill" style="width: ${req.avgCompletion}%; background: ${
                                        req.avgCompletion >= 85 ? '#28a745' : 
                                        req.avgCompletion >= 50 ? '#ffc107' : '#dc3545'
                                    }"></div>
                                    <span class="progress-text">${req.avgCompletion.toFixed(1)}%</span>
                                </div>
                            </td>
                            <td class="connection-cell" title="${req.connectedSuppliers.map(s => 
                                `${s.planet.name} (${s.provides.join(',')}, ${Math.round(s.distance)}ly)`
                            ).join('; ')}">${connectionIcon} ${connectionText}</td>
                            <td class="${req.missing.duranium === 0 ? 'resource-complete' : 'resource-needed'}">${req.missing.duranium}</td>
                            <td class="${req.missing.tritanium === 0 ? 'resource-complete' : 'resource-needed'}">${req.missing.tritanium}</td>
                            <td class="${req.missing.molybdenum === 0 ? 'resource-complete' : 'resource-needed'}">${req.missing.molybdenum}</td>
                            <td class="${req.missing.megacredits === 0 ? 'resource-complete' : 'resource-needed'}">${req.missing.megacredits}</td>
                            <td class="${getResourceClass(req.current.duranium, 'duranium')}">${req.current.duranium}</td>
                            <td class="${getResourceClass(req.current.tritanium, 'tritanium')}">${req.current.tritanium}</td>
                            <td class="${getResourceClass(req.current.molybdenum, 'molybdenum')}">${req.current.molybdenum}</td>
                            <td class="${getResourceClass(req.current.megacredits, 'megacredits')}">${req.current.megacredits}</td>
                        </tr>
                    `;
                }).join('');
            }

            tbody.innerHTML = newContent;
            
            // Add click handlers for starmap integration
            addTableRowClickHandlers(tbody, tableType, data);
            } catch (error) {
                console.error('Error updating table content:', error);
            }
        }

        function addTableRowClickHandlers(tbody, tableType, data) {
            const rows = tbody.querySelectorAll('tr');
            rows.forEach((row, index) => {
                if (index >= data.length) return;
                
                const item = data[index];
                let objectType, objectId, planetId;
                
                if (tableType === 'planets') {
                    objectType = 'planet';
                    objectId = item.id;
                } else if (tableType === 'ships') {
                    objectType = 'ship';  
                    objectId = item.id;
                } else if (tableType === 'starbases') {
                    objectType = 'starbase';
                    objectId = item.id;
                    planetId = item.planetid;
                } else if (tableType === 'starbase-requirements') {
                    objectType = 'planet';
                    objectId = item.planet.id;
                }
                
                if (objectType && objectId) {
                    row.setAttribute('data-object-type', objectType);
                    row.setAttribute('data-object-id', objectId);
                    if (planetId) row.setAttribute('data-planet-id', planetId);
                    
                    row.style.cursor = 'pointer';
                    row.addEventListener('click', (e) => {
                        // Prevent action if clicking on header elements (th tags)
                        if (e.target.tagName === 'TH') {
                            return;
                        }
                        
                        console.log('Legacy table row clicked:', objectType, objectId);
                        
                        // Show starmap panel
                        showStarmapPanel();
                        
                        // Clear previous selections using both old and new selection classes
                        document.querySelectorAll('.table-row-selected, .vgap-table-row.selected').forEach(r => {
                            r.classList.remove('table-row-selected', 'selected');
                        });
                        clearStarmapSelections();
                        
                        // Highlight clicked row
                        row.classList.add('table-row-selected', 'selected');
                        
                        // Highlight object on starmap using both selection systems
                        if (window.selectionManager && svgElement) {
                            const element = svgElement.querySelector(`[data-type="${objectType}"][data-id="${objectId}"]`);
                            if (element) {
                                console.log('Found starmap element via legacy system, selecting');
                                window.selectionManager.selectObject(element, objectType, objectId);
                            } else {
                                console.warn('Starmap element not found via legacy system:', `[data-type="${objectType}"][data-id="${objectId}"]`);
                            }
                        }
                        
                        // Also apply highlighting functions for consistency
                        highlightStarmapObject(objectType, objectId, false);
                        highlightObjectOnStarmap(objectType, objectId);
                    });
                }
            });
        }

        function showStarmapPanel() {
            const panel = document.getElementById('starmapPanel');
            if (panel) {
                panel.classList.add('visible');
                
                // Redraw starmap when panel becomes visible
                setTimeout(() => {
                    redrawStarmap();
                    fitStarmapToScreen();
                }, 100);
            }
        }

        function hideStarmapPanel() {
            const panel = document.getElementById('starmapPanel');
            if (panel) {
                panel.classList.remove('visible');
            }
            
            // Clear table selections
            document.querySelectorAll('.table-row-selected').forEach(r => {
                r.classList.remove('table-row-selected');
            });
        }

        // Create enhanced planets section - DEPRECATED: Use TableManager instead
        function createPlanetsSection(gameData) {
            // This function is deprecated and should not be used
            // Use the new TableManager system instead
            console.warn('createPlanetsSection is deprecated. Use TableManager methods instead.');
            return '<div class="deprecated-notice">Please use the new tab-based interface</div>';
        }

        // Calculate starbase requirements for owned planets
        function calculateStarbaseRequirements(ownedPlanets, starbases, playerId) {
            const requirements = [];
            const starbaseBuilds = currentGameData.rst?.starbasebuilds || [];
            
            // Starbase build requirements (standard cost)
            const required = {
                duranium: 120,     
                tritanium: 402,
                molybdenum: 340,
                megacredits: 900
            };
            
            ownedPlanets.forEach(planet => {
                // Skip planets that already have a starbase
                const hasStarbase = starbases.some(sb => sb.planetid === planet.id);
                if (hasStarbase) return;
                
                // Check if planet is building a starbase this turn
                const isBuildingStarbase = starbaseBuilds.some(build => 
                    build.planetid === planet.id
                );
                
                // Calculate resource gaps
                const current = {
                    duranium: planet.duranium || 0,
                    tritanium: planet.tritanium || 0, 
                    molybdenum: planet.molybdenum || 0,
                    megacredits: planet.megacredits || 0
                };
                
                const missing = {
                    duranium: Math.max(0, required.duranium - current.duranium),
                    tritanium: Math.max(0, required.tritanium - current.tritanium),
                    molybdenum: Math.max(0, required.molybdenum - current.molybdenum),
                    megacredits: Math.max(0, required.megacredits - current.megacredits)
                };
                
                // Calculate how close to starbase requirements (0-100%)
                const percentages = {
                    duranium: Math.min(100, (current.duranium / required.duranium) * 100),
                    tritanium: Math.min(100, (current.tritanium / required.tritanium) * 100),
                    molybdenum: Math.min(100, (current.molybdenum / required.molybdenum) * 100),
                    megacredits: Math.min(100, (current.megacredits / required.megacredits) * 100)
                };
                
                const avgCompletion = (percentages.duranium + percentages.tritanium + 
                                     percentages.molybdenum + percentages.megacredits) / 4;
                
                // Find connected suppliers within 84LY
                const connectedSuppliers = findConnectedSuppliers(planet, ownedPlanets, missing);
                const connectionCount = connectedSuppliers.length;
                const hasFullSupport = checkFullResourceSupport(missing, connectedSuppliers);
                
                // Include planets that have some progress, are building, or have connections
                if (avgCompletion > 5 || isBuildingStarbase || connectionCount > 0) {
                    requirements.push({
                        planet: planet,
                        isBuildingStarbase: isBuildingStarbase,
                        current: current,
                        missing: missing,
                        percentages: percentages,
                        avgCompletion: avgCompletion,
                        connectedSuppliers: connectedSuppliers,
                        connectionCount: connectionCount,
                        hasFullSupport: hasFullSupport
                    });
                }
            });
            
            // Sort by: 1) Building status, 2) Completion percentage, 3) Connection count
            return requirements.sort((a, b) => {
                // Building starbases first
                if (a.isBuildingStarbase && !b.isBuildingStarbase) return -1;
                if (!a.isBuildingStarbase && b.isBuildingStarbase) return 1;
                
                // Then by completion percentage (descending)
                if (Math.abs(a.avgCompletion - b.avgCompletion) > 1) {
                    return b.avgCompletion - a.avgCompletion;
                }
                
                // Then by connection count (descending)
                return b.connectionCount - a.connectionCount;
            });
        }

        // Find planets that can supply missing resources within 84LY
        function findConnectedSuppliers(targetPlanet, allPlanets, missingResources) {
            const suppliers = [];
            const resourceTargets = {
                megacredits: 1500,
                duranium: 1500,
                tritanium: 1500,
                molybdenum: 1500
            };
            
            for (const planet of allPlanets) {
                if (planet.id === targetPlanet.id) continue;
                
                // Calculate distance
                const dx = targetPlanet.x - planet.x;
                const dy = targetPlanet.y - planet.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance > 84) continue;
                
                // Check what resources this planet can provide for missing ones
                const provides = [];
                if (missingResources.megacredits > 0 && 
                    (planet.megacredits || 0) + (planet.supplies || 0) > resourceTargets.megacredits) {
                    provides.push('MC');
                }
                if (missingResources.duranium > 0 && 
                    (planet.duranium || 0) + (planet.groundduranium || 0) > resourceTargets.duranium) {
                    provides.push('D');
                }
                if (missingResources.tritanium > 0 && 
                    (planet.tritanium || 0) + (planet.groundtritanium || 0) > resourceTargets.tritanium) {
                    provides.push('T');
                }
                if (missingResources.molybdenum > 0 && 
                    (planet.molybdenum || 0) + (planet.groundmolybdenum || 0) > resourceTargets.molybdenum) {
                    provides.push('M');
                }
                
                if (provides.length > 0) {
                    suppliers.push({
                        planet: planet,
                        distance: distance,
                        provides: provides
                    });
                }
            }
            
            return suppliers.sort((a, b) => a.distance - b.distance);
        }

        // Check if connected suppliers can provide all missing resources
        function checkFullResourceSupport(missingResources, suppliers) {
            const neededResources = [];
            if (missingResources.duranium > 0) neededResources.push('D');
            if (missingResources.tritanium > 0) neededResources.push('T');
            if (missingResources.molybdenum > 0) neededResources.push('M');
            if (missingResources.megacredits > 0) neededResources.push('MC');
            
            const suppliedResources = new Set();
            suppliers.forEach(supplier => {
                supplier.provides.forEach(resource => suppliedResources.add(resource));
            });
            
            return neededResources.every(needed => suppliedResources.has(needed));
        }

        // Create starbase requirements table
        function createStarbaseRequirementsTable(requirements) {
            const headers = [
                { text: 'Planet', column: 'name' },
                { text: 'Status', column: 'status' },
                { text: 'Progress', column: 'progress' },
                { text: 'Connections', column: 'connections' },
                { text: 'D Need', column: 'duranium_need' },
                { text: 'T Need', column: 'tritanium_need' },
                { text: 'M Need', column: 'molybdenum_need' },
                { text: 'MC Need', column: 'megacredits_need' },
                { text: 'Current D', column: 'duranium_current' },
                { text: 'Current T', column: 'tritanium_current' },
                { text: 'Current M', column: 'molybdenum_current' },
                { text: 'Current MC', column: 'megacredits_current' }
            ];
            
            return `
                <table class="starbase-requirements-table">
                    <thead>
                        <tr>
                            ${headers.map(header => `<th data-column="${header.column || ''}">${header.text}</th>`).join('')}
                        </tr>
                    </thead>
                    <tbody>
                        ${requirements.map(req => {
                            const statusIcon = req.isBuildingStarbase ? '🏗️' : 
                                              req.avgCompletion >= 85 ? '🟢' : 
                                              req.avgCompletion >= 50 ? '🟡' : '🔴';
                            const statusText = req.isBuildingStarbase ? 'Building' : 
                                              req.avgCompletion >= 85 ? 'Ready' : 
                                              req.avgCompletion >= 50 ? 'Close' : 'Need Resources';
                            
                            const connectionIcon = req.hasFullSupport ? '🤝' : 
                                                  req.connectionCount > 0 ? '🔗' : '⚠️';
                            const connectionText = req.hasFullSupport ? 'Full Support' : 
                                                  req.connectionCount > 0 ? `${req.connectionCount} suppliers` : 'No support';
                            
                            const rowClass = req.isBuildingStarbase ? 'building-starbase' : 
                                           req.hasFullSupport ? 'connected-starbase' :
                                           req.avgCompletion >= 85 ? 'ready-starbase' : '';
                            
                            return `
                                <tr class="${rowClass}" data-planet-id="${req.planet.id}">
                                    <td class="planet-name" title="${req.planet.name}">${req.planet.name?.substring(0, 12) || 'Unknown'}</td>
                                    <td class="status-cell">${statusIcon} ${statusText}</td>
                                    <td class="progress-cell">
                                        <div class="progress-bar">
                                            <div class="progress-fill" style="width: ${req.avgCompletion}%; background: ${
                                                req.avgCompletion >= 85 ? '#28a745' : 
                                                req.avgCompletion >= 50 ? '#ffc107' : '#dc3545'
                                            }"></div>
                                            <span class="progress-text">${req.avgCompletion.toFixed(1)}%</span>
                                        </div>
                                    </td>
                                    <td class="connection-cell" title="${req.connectedSuppliers.map(s => 
                                        `${s.planet.name} (${s.provides.join(',')}, ${Math.round(s.distance)}ly)`
                                    ).join('; ')}">${connectionIcon} ${connectionText}</td>
                                    <td class="${req.missing.duranium === 0 ? 'resource-complete' : 'resource-needed'}">${req.missing.duranium}</td>
                                    <td class="${req.missing.tritanium === 0 ? 'resource-complete' : 'resource-needed'}">${req.missing.tritanium}</td>
                                    <td class="${req.missing.molybdenum === 0 ? 'resource-complete' : 'resource-needed'}">${req.missing.molybdenum}</td>
                                    <td class="${req.missing.megacredits === 0 ? 'resource-complete' : 'resource-needed'}">${req.missing.megacredits}</td>
                                    <td class="${getResourceClass(req.current.duranium, 'duranium')}">${req.current.duranium}</td>
                                    <td class="${getResourceClass(req.current.tritanium, 'tritanium')}">${req.current.tritanium}</td>
                                    <td class="${getResourceClass(req.current.molybdenum, 'molybdenum')}">${req.current.molybdenum}</td>
                                    <td class="${getResourceClass(req.current.megacredits, 'megacredits')}">${req.current.megacredits}</td>
                                </tr>
                            `;
                        }).join('')}
                    </tbody>
                </table>
            `;
        }

        // Process uploaded file
        function processFile(file) {
            console.log('processFile called with:', file);
            showStatus('Reading file...', 'loading');

            const reader = new FileReader();
            reader.onload = function(e) {
                console.log('File read successfully, content length:', e.target.result.length);
                try {
                    const jsonData = JSON.parse(e.target.result);
                    console.log('JSON parsed successfully:', Object.keys(jsonData));
                    
                    // Validate that it looks like a VGAP turn file
                    if (!jsonData.rst || !jsonData.rst.settings) {
                        console.log('Validation failed - missing rst or rst.settings');
                        console.log('Available keys:', Object.keys(jsonData));
                        throw new Error('Invalid VGAP turn file format');
                    }

                    console.log('File validation passed');
                    currentGameData = jsonData;
                    
                    // Parse alliances from turn data
                    try {
                        // Import alliance parser
                        const allianceParserScript = document.createElement('script');
                        allianceParserScript.src = 'alliance_parser.js';
                        document.head.appendChild(allianceParserScript);
                        
                        allianceParserScript.onload = function() {
                            if (window.extractAlliances) {
                                // Extract player ID from turn data
                                const playerId = jsonData.rst?.player?.id;
                                console.log('Player ID:', playerId);
                                
                                // Extract alliances
                                const alliedIds = window.extractAlliances(jsonData, playerId);
                                window.alliedPlayerIds = alliedIds;
                                console.log('✅ Alliances parsed:', alliedIds);
                                
                                // Update the ally input field
                                const allyIdsInput = document.getElementById('allyIdsInput');
                                if (allyIdsInput && alliedIds.length > 0) {
                                    allyIdsInput.value = alliedIds.join(', ');
                                }
                            } else {
                                console.warn('⚠️ Alliance parser not available, using test data');
                                window.alliedPlayerIds = []; // Fallback to no allies
                            }
                        };
                    } catch (allianceError) {
                        console.warn('⚠️ Alliance parsing failed, using test data:', allianceError);
                        window.alliedPlayerIds = []; // Fallback to no allies
                    }
                    
                    showFileInfo(file, jsonData);
                    showGameInfo(jsonData);
                    showDataSections(jsonData);
                    
                    showStatus('Turn file loaded successfully! 🎉', 'success');
                    setTimeout(hideStatus, 3000);

                } catch (error) {
                    console.error('Error in processFile:', error);
                    showStatus(`Error reading file: ${error.message}`, 'error');
                    console.error('File processing error:', error);
                }
            };

            reader.onerror = function(error) {
                console.error('FileReader error:', error);
                showStatus('Error reading file', 'error');
            };

            console.log('Starting to read file as text');
            reader.readAsText(file);
        }

        // Clear all data
        function clearData() {
            currentGameData = null;
            currentFileName = null;
            document.getElementById('fileInfo').classList.add('hidden');
            document.getElementById('gameInfo').classList.add('hidden');
            document.getElementById('dataSections').classList.add('hidden');
            document.getElementById('fileInput').value = '';
            hideStatus();
        }

        // Copy data to clipboard
        async function copyToClipboard() {
            if (!currentGameData) {
                showStatus('No data to copy', 'error');
                return;
            }

            try {
                const jsonString = JSON.stringify(currentGameData, null, 2);
                
                if (navigator.clipboard && window.isSecureContext) {
                    await navigator.clipboard.writeText(jsonString);
                    showStatus('Data copied to clipboard! 📋', 'success');
                } else {
                    // Fallback for older browsers
                    const textArea = document.createElement('textarea');
                    textArea.value = jsonString;
                    textArea.style.position = 'fixed';
                    textArea.style.left = '-999999px';
                    textArea.style.top = '-999999px';
                    document.body.appendChild(textArea);
                    textArea.focus();
                    textArea.select();
                    
                    try {
                        document.execCommand('copy');
                        showStatus('Data copied to clipboard! 📋', 'success');
                    } catch (err) {
                        showStatus('Failed to copy data', 'error');
                    }
                    
                    document.body.removeChild(textArea);
                }
                
                setTimeout(hideStatus, 2000);
            } catch (error) {
                showStatus('Failed to copy data', 'error');
                console.error('Copy failed:', error);
            }
        }

        // Re-save file
        function resaveFile() {
            if (!currentGameData) {
                showStatus('No data to save', 'error');
                return;
            }

            try {
                const jsonString = JSON.stringify(currentGameData, null, 2);
                const blob = new Blob([jsonString], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                
                // Create filename
                const turn = currentGameData.rst?.settings?.turn || 'unknown';
                const timestamp = new Date().toISOString().slice(0, 16).replace(/[:-]/g, '');
                const filename = currentFileName || `vgap_turn${turn}_${timestamp}.json`;
                
                // Create download link and trigger download
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                a.style.display = 'none';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                
                URL.revokeObjectURL(url);
                showStatus(`File saved as ${filename} 💾`, 'success');
                setTimeout(hideStatus, 3000);
            } catch (error) {
                showStatus('Failed to save file', 'error');
                console.error('Save failed:', error);
            }
        }

        // Initialize test mode functionality
        function initializeTestMode() {
            console.log('initializeTestMode called, isTestMode:', isTestMode);
            
            const testModeToggle = document.getElementById('testModeToggle');
            const uploadSection = document.querySelector('.upload-section');
            
            if (!testModeToggle) {
                console.error('testModeToggle element not found');
                return;
            }
            
            // Set initial state based on isTestMode variable
            testModeToggle.checked = isTestMode;
            updateTestModeUI();
            
            // Add event listener for toggle changes
            testModeToggle.addEventListener('change', function() {
                isTestMode = this.checked;
                console.log('Test mode toggled to:', isTestMode);
                updateTestModeUI();
                
                // Clear any existing data when switching modes
                clearCurrentData();
                
                if (isTestMode) {
                    loadTestData();
                }
            });
            
            // Auto-load test data if in test mode
            console.log('Checking auto-load: isTestMode =', isTestMode);
            if (isTestMode) {
                console.log('Auto-loading test data in 100ms');
                setTimeout(() => loadTestData(), 100);
            }
        }
        
        function updateTestModeUI() {
            const uploadSection = document.querySelector('.upload-section');
            const testModeToggle = document.getElementById('testModeToggle');
            
            if (isTestMode) {
                uploadSection.style.display = 'none';
                testModeToggle.parentElement.parentElement.style.background = 'rgba(40, 167, 69, 0.2)';
                testModeToggle.parentElement.parentElement.style.border = '2px solid #28a745';
            } else {
                uploadSection.style.display = 'block';
                testModeToggle.parentElement.parentElement.style.background = 'rgba(255, 255, 255, 0.1)';
                testModeToggle.parentElement.parentElement.style.border = 'none';
            }
        }
        
        function loadTestData() {
            console.log('loadTestData called - using test_turn_data.js');
            console.log('VGAP_TURN_DATA available:', typeof window.VGAP_TURN_DATA !== 'undefined');
            
            if (typeof window.VGAP_TURN_DATA === 'undefined') {
                console.error('VGAP_TURN_DATA is undefined - test_turn_data.js may not have loaded');
                showStatus('Test data not available', 'error');
                return;
            }
            
            showStatus('Loading test data...', 'loading');
            console.log('Test data loaded, processing...');
            
            try {
                const jsonData = window.VGAP_TURN_DATA;
                
                // Validate that it looks like a VGAP turn file
                if (!jsonData.rst || !jsonData.rst.settings) {
                    console.log('Validation failed - missing rst or rst.settings');
                    console.log('Available keys:', Object.keys(jsonData));
                    throw new Error('Invalid VGAP turn file format');
                }

                console.log('Test data validation passed');
                currentGameData = jsonData;
                currentFileName = 'test_turn_file.json';
                
                console.log('currentGameData set:', currentGameData ? 'success' : 'failed');
                console.log('Game data structure:', {
                    success: currentGameData?.success,
                    hasRst: !!currentGameData?.rst,
                    hasSettings: !!currentGameData?.rst?.settings,
                    turn: currentGameData?.rst?.settings?.turn
                });
                
                // Call alliance parser for test data too
                try {
                    // Import alliance parser
                    const allianceParserScript = document.createElement('script');
                    allianceParserScript.src = 'alliance_parser.js';
                    document.head.appendChild(allianceParserScript);
                    
                    allianceParserScript.onload = function() {
                        if (window.extractAlliances) {
                            // Extract player ID from turn data
                            const playerId = currentGameData.rst?.player?.id;
                            console.log('🔍 Test Data - Player ID:', playerId);
                            
                            // Extract alliances
                            const alliedIds = window.extractAlliances(currentGameData, playerId);
                            window.alliedPlayerIds = alliedIds;
                            console.log('✅ Test Data - Alliances parsed:', alliedIds);
                            
                            // Update the ally input field
                            const allyIdsInput = document.getElementById('allyIdsInput');
                            if (allyIdsInput && alliedIds.length > 0) {
                                allyIdsInput.value = alliedIds.join(', ');
                            }
                        } else {
                            console.warn('⚠️ Test Data - Alliance parser not available');
                            window.alliedPlayerIds = [];
                        }
                        
                        // Call showDataSections after alliance parsing is complete
                        showDataSections(currentGameData);
                    };
                } catch (allianceError) {
                    console.warn('⚠️ Test Data - Alliance parsing failed:', allianceError);
                    window.alliedPlayerIds = [];
                    showDataSections(currentGameData);
                }
                
                // Create a fake file info for the test data
                showFileInfo({ name: currentFileName, size: 789855 }, currentGameData);
                showGameInfo(currentGameData);
                
                showStatus('Test data loaded successfully! 🎉', 'success');
                setTimeout(hideStatus, 3000);
                
            } catch (error) {
                console.error('Error loading test data:', error);
                showStatus('Failed to load test data: ' + error.message, 'error');
            }
        }
        
        function clearCurrentData() {
            currentGameData = null;
            currentFileName = null;
            selectedObjectId = null;
            selectedObjectType = null;
            
            // Hide data sections
            document.getElementById('gameInfo').classList.add('hidden');
            document.getElementById('dataSections').classList.add('hidden');
            
            // Clear file info
            document.getElementById('fileInfo').classList.add('hidden');
        }

        // Event listeners
        document.addEventListener('DOMContentLoaded', function() {
            const fileInput = document.getElementById('fileInput');
            const fileInputLabel = document.querySelector('.file-input-label');
            const dropZone = document.getElementById('dropZone');
            const clearFileBtn = document.getElementById('clearFileBtn');
            const copyBtn = document.getElementById('copyBtn');
            const saveBtn = document.getElementById('saveBtn');

            // File input change
            fileInput.addEventListener('change', function(e) {
                console.log('File input changed:', e.target.files);
                const file = e.target.files[0];
                if (file) {
                    console.log('Processing file:', file.name, 'Size:', file.size, 'Type:', file.type);
                    processFile(file);
                } else {
                    console.log('No file selected');
                    showStatus('No file selected', 'error');
                }
            });

            // File input label click handling (for better iOS compatibility)
            fileInputLabel.addEventListener('click', function(e) {
                e.preventDefault();
                fileInput.click();
            });

            // Add touch events for the label (iOS specific)
            fileInputLabel.addEventListener('touchstart', function(e) {
                this.style.background = 'linear-gradient(45deg, #0099cc, #007399)';
            }, { passive: true });

            fileInputLabel.addEventListener('touchend', function(e) {
                e.preventDefault();
                this.style.background = 'linear-gradient(45deg, #00d4ff, #0099cc)';
                fileInput.click();
            });

            // Test load button
            document.getElementById('testLoadBtn').addEventListener('click', function() {
                console.log('Test load button clicked');
                showStatus('Loading test data...', 'loading');
                
                // Load the local turn_data.json file
                fetch('/VGAP/turn_data.json')
                    .then(response => {
                        if (!response.ok) {
                            throw new Error('Failed to load test data file');
                        }
                        return response.json();
                    })
                    .then(jsonData => {
                        console.log('Test data loaded successfully:', Object.keys(jsonData));
                        
                        // Validate that it looks like a VGAP turn file
                        if (!jsonData.rst || !jsonData.rst.settings) {
                            throw new Error('Invalid VGAP turn file format in test data');
                        }

                        currentGameData = jsonData;
                        
                        // Create fake file object for display
                        const fakeFile = { name: 'turn_data.json (test)', size: JSON.stringify(jsonData).length, type: 'application/json' };
                        showFileInfo(fakeFile, jsonData);
                        showGameInfo(jsonData);
                        showDataSections(jsonData);
                        
                        showStatus('Test turn file loaded successfully! 🎉', 'success');
                        setTimeout(hideStatus, 3000);
                    })
                    .catch(error => {
                        console.error('Error loading test data:', error);
                        showStatus(`Error loading test data: ${error.message}`, 'error');
                    });
            });

            // Drag and drop functionality
            dropZone.addEventListener('dragover', function(e) {
                e.preventDefault();
                dropZone.classList.add('dragover');
            });

            dropZone.addEventListener('dragleave', function(e) {
                e.preventDefault();
                dropZone.classList.remove('dragover');
            });

            dropZone.addEventListener('drop', function(e) {
                e.preventDefault();
                dropZone.classList.remove('dragover');
                
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    const file = files[0];
                    if (file.type === 'application/json' || file.name.endsWith('.json')) {
                        processFile(file);
                    } else {
                        showStatus('Please upload a JSON file', 'error');
                    }
                }
            });

            // Click to upload (but not on the label itself to avoid double-triggering)
            dropZone.addEventListener('click', function(e) {
                // Don't trigger if clicking on the label
                if (!e.target.classList.contains('file-input-label')) {
                    fileInput.click();
                }
            });

            // Button event listeners
            clearFileBtn.addEventListener('click', clearData);
            copyBtn.addEventListener('click', copyToClipboard);
            saveBtn.addEventListener('click', resaveFile);

            // Initialize test mode toggle
            initializeTestMode();

            // Set build date from GitHub API
            const buildDateElement = document.getElementById('buildDate');
            buildDateElement.textContent = 'Loading...';
            
            // Fetch last commit date from GitHub API
            fetch('https://api.github.com/repos/simonclur/VGAP_MobileTurnViewExchange/commits/main')
                .then(response => response.json())
                .then(data => {
                    const commitDate = new Date(data.commit.author.date);
                    const formattedDate = commitDate.toLocaleString('en-US', {
                        year: 'numeric',
                        month: 'short',
                        day: 'numeric',
                        hour: '2-digit',
                        minute: '2-digit',
                        timeZoneName: 'short'
                    });
                    buildDateElement.innerHTML = `${formattedDate} <span style="opacity: 0.7;">(<a href="https://github.com/simonclur/VGAP_MobileTurnViewExchange/commit/${data.sha}" target="_blank" style="color: #00d4ff; text-decoration: none;">${data.sha.substring(0, 7)}</a>)</span>`;
                })
                .catch(error => {
                    console.error('Failed to fetch commit date:', error);
                    const fallbackDate = new Date().toLocaleString('en-US', {
                        year: 'numeric',
                        month: 'short',
                        day: 'numeric',
                        hour: '2-digit',
                        minute: '2-digit',
                        timeZoneName: 'short'
                    });
                    buildDateElement.textContent = `${fallbackDate} (offline)`;
                });
        });
    </script>
</body>
</html>
