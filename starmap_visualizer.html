<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VGAP Starmap Visualizer</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%);
            color: #ffffff;
            min-height: 100vh;
            overflow-x: auto;
        }

        .container {
            max-width: 100%;
            margin: 0 auto;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }

        h1 {
            text-align: center;
            margin-bottom: 20px;
            color: #00d4ff;
            text-shadow: 0 0 10px rgba(0, 212, 255, 0.5);
        }

        .navigation {
            text-align: center;
            margin-bottom: 20px;
        }

        .nav-link {
            color: #00d4ff;
            text-decoration: none;
            font-weight: 600;
            padding: 10px 20px;
            border: 2px solid #00d4ff;
            border-radius: 8px;
            display: inline-block;
            margin: 0 10px;
            transition: all 0.3s ease;
        }

        .nav-link:hover {
            background: #00d4ff;
            color: #1e3c72;
            box-shadow: 0 5px 15px rgba(0, 212, 255, 0.4);
        }

        .upload-section {
            background: rgba(255, 255, 255, 0.1);
            padding: 25px;
            border-radius: 10px;
            margin-bottom: 20px;
            backdrop-filter: blur(10px);
            text-align: center;
        }

        .file-input-wrapper {
            position: relative;
            display: inline-block;
            margin-bottom: 15px;
        }

        .file-input {
            position: absolute;
            width: 0.1px;
            height: 0.1px;
            opacity: 0;
            overflow: hidden;
            z-index: -1;
        }

        .file-input-label {
            display: inline-block;
            padding: 15px 30px;
            background: linear-gradient(45deg, #00d4ff, #0099cc);
            border: none;
            border-radius: 8px;
            color: white;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            -webkit-appearance: none;
            appearance: none;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }

        .file-input-label:hover, .file-input-label:focus {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 212, 255, 0.4);
            outline: none;
        }

        .status {
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            font-weight: 600;
            text-align: center;
        }

        .status.loading {
            background: rgba(255, 193, 7, 0.2);
            border: 2px solid #ffc107;
            color: #ffc107;
        }

        .status.success {
            background: rgba(40, 167, 69, 0.2);
            border: 2px solid #28a745;
            color: #28a745;
        }

        .status.error {
            background: rgba(220, 53, 69, 0.2);
            border: 2px solid #dc3545;
            color: #dc3545;
        }

        .status.info {
            background: rgba(0, 212, 255, 0.2);
            border: 2px solid #00d4ff;
            color: #00d4ff;
        }

        .hidden {
            display: none;
        }

        .controls {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            backdrop-filter: blur(10px);
        }

        .control-group {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            align-items: center;
            margin-bottom: 15px;
        }

        .control-group:last-child {
            margin-bottom: 0;
        }

        .control-group label {
            color: #e0e0e0;
            font-weight: 600;
            min-width: 120px;
        }

        .checkbox-group {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
        }

        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .checkbox-item input[type="checkbox"] {
            margin: 0;
        }

        .checkbox-item label {
            min-width: auto;
            font-size: 14px;
        }

        .zoom-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .zoom-indicator {
            background: #1e1e1e;
            border: 2px solid #00d4ff;
            border-radius: 4px;
            padding: 4px 8px;
            color: #00d4ff;
            font-family: monospace;
            font-size: 13px;
            font-weight: bold;
            min-width: 50px;
            text-align: center;
            transition: all 0.2s ease;
        }

        .zoom-indicator.zoom-min {
            border-color: #ff9800;
            color: #ff9800;
        }

        .zoom-indicator.zoom-max {
            border-color: #f44336;
            color: #f44336;
        }

        button {
            padding: 8px 16px;
            background: linear-gradient(45deg, #00d4ff, #0099cc);
            border: none;
            border-radius: 6px;
            color: white;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        button:hover {
            transform: translateY(-1px);
            box-shadow: 0 3px 10px rgba(0, 212, 255, 0.3);
        }

        .starmap-container {
            background: rgba(0, 0, 0, 0.9);
            border-radius: 10px;
            padding: 20px;
            border: 2px solid rgba(0, 212, 255, 0.3);
            overflow: auto;
            max-height: 80vh;
        }

        #starmap {
            background: #000011;
            border: 1px solid #333;
            cursor: move;
        }

        .legend {
            background: rgba(0, 0, 0, 0.8);
            border-radius: 8px;
            padding: 15px;
            margin-top: 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .legend h3 {
            color: #00d4ff;
            margin-bottom: 10px;
        }

        .legend-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .legend-section {
            background: rgba(255, 255, 255, 0.05);
            padding: 10px;
            border-radius: 6px;
        }

        .legend-section h4 {
            color: #00d4ff;
            font-size: 14px;
            margin-bottom: 8px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 5px;
            font-size: 12px;
        }

        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            border: 1px solid #fff;
        }

        .legend-shape {
            width: 16px;
            height: 16px;
            border: 1px solid #fff;
        }
        
        .legend-info {
            background: rgba(0, 21, 25, 0.7);
            padding: 8px 12px;
            border-radius: 6px;
            margin-bottom: 10px;
            color: #00d4ff;
            font-size: 0.9em;
            text-align: center;
        }

        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.95);
            color: #fff;
            padding: 10px 15px;
            border-radius: 6px;
            pointer-events: none;
            font-size: 12px;
            display: none;
            z-index: 1000;
            border: 1px solid #00d4ff;
            max-width: 300px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
        }

        .tooltip h4 {
            color: #00d4ff;
            margin-bottom: 5px;
        }

        .tooltip-grid {
            display: grid;
            grid-template-columns: auto 1fr;
            gap: 5px 10px;
            font-size: 11px;
        }

        .tooltip-label {
            font-weight: bold;
            color: #ccc;
        }

        .build-info {
            text-align: center;
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
            font-size: 12px;
            color: rgba(255, 255, 255, 0.6);
        }

        .build-info a {
            color: #00d4ff;
            text-decoration: none;
        }

        .build-info a:hover {
            text-decoration: underline;
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            .control-group {
                flex-direction: column;
                align-items: flex-start;
            }
            
            .control-group label {
                min-width: auto;
            }
            
            .nav-link {
                display: block;
                margin: 5px 0;
            }
        }

        /* Animations for starbase planning indicators */
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.3; }
            100% { opacity: 1; }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>🌌 VGAP Starmap Visualizer</h1>
        
        <div class="navigation">
            <a href="mobile_vgap_viewer.html" class="nav-link">🚀 Live Turn Loader</a>
            <a href="saved_turn_viewer.html" class="nav-link">📁 Saved Turn Viewer</a>
            <a href="starmap_visualizer.html" class="nav-link">🌌 Starmap Visualizer</a>
        </div>

        <div class="upload-section">
            <h3>Load Turn Data for Starmap Visualization</h3>
            <p>Upload a JSON file exported from VGAP Mobile Turn Viewer to visualize your empire's starmap.</p>
            <div class="file-input-wrapper">
                <input type="file" id="fileInput" class="file-input" accept=".json" />
                <label for="fileInput" class="file-input-label">Choose Turn Data JSON File</label>
            </div>
        </div>

        <div id="status" class="status hidden"></div>

        <div id="controlsSection" class="controls hidden">
            <div class="control-group">
                <label>Display Options:</label>
                <div class="checkbox-group">
                    <div class="checkbox-item">
                        <input type="checkbox" id="showPlanets" checked>
                        <label for="showPlanets">Planets</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="showShips" checked>
                        <label for="showShips">Ships</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="showStarbases" checked>
                        <label for="showStarbases">Starbases</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="showNebulas" checked>
                        <label for="showNebulas">Nebulas</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="showNotes" checked>
                        <label for="showNotes">Strategic Notes</label>
                    </div>
                </div>
            </div>
            
            <div class="control-group">
                <label>Zoom Controls:</label>
                <div class="zoom-controls">
                    <button id="zoomIn">Zoom In</button>
                    <button id="zoomOut">Zoom Out</button>
                    <button id="resetZoom">Reset View</button>
                    <button id="fitToScreen">Fit to Screen</button>
                    <div id="zoomIndicator" class="zoom-indicator">100%</div>
                </div>
            </div>
        </div>

        <div id="starmapContainer" class="starmap-container hidden">
            <svg id="starmap" width="1200" height="800"></svg>
        </div>

        <div id="legend" class="legend hidden">
            <h3>🗺️ Starmap Legend</h3>
            <div id="playerInfoLegend" class="legend-info">
                <p id="playerNameDisplay">Loading player information...</p>
                <p style="margin-top: 5px; font-size: 0.8em; font-style: italic;">Ownership is determined by Player ID (not Race ID)</p>
            </div>
            <div class="legend-grid">
                <div class="legend-section">
                    <h4>Planets</h4>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #4caf50;"></div>
                        <span>Your Planets (Happy: >70%)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #8bc34a;"></div>
                        <span>Your Planets (Moderate: 40-70%)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #a5d6a7;"></div>
                        <span>Your Planets (Unhappy: <40%)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #ff5722;"></div>
                        <span>Enemy Planets</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #9e9e9e;"></div>
                        <span>Neutral Planets</span>
                    </div>
                </div>
                
                <div class="legend-section">
                    <h4>Starbases</h4>
                    <div class="legend-item">
                        <div class="legend-shape" style="background: #00d4ff; transform: rotate(45deg);"></div>
                        <span>Your Starbases</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-shape" style="background: #f44336; transform: rotate(45deg);"></div>
                        <span>Enemy Starbases</span>
                    </div>
                </div>
                
                <div class="legend-section">
                    <h4>Ships</h4>
                    <div class="legend-item">
                        <div class="legend-shape" style="background: #00ff00; width: 12px; height: 4px; border-radius: 2px;"></div>
                        <span>Your Ships</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-shape" style="background: #ff4444; width: 12px; height: 4px; border-radius: 2px;"></div>
                        <span>Enemy Ships</span>
                    </div>
                </div>
                
                <div class="legend-section">
                    <h4>Special Features</h4>
                    <div class="legend-item">
                        <div class="legend-color" style="background: rgba(128, 0, 128, 0.3); border: 1px dashed #800080;"></div>
                        <span>Nebulas</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #ffeb3b; border-radius: 2px;"></div>
                        <span>Strategic Notes</span>
                    </div>
                </div>
            </div>
        </div>

        <div class="build-info">
            <div>🌌 VGAP Starmap Visualizer</div>
            <div>Built: <span id="buildDate"></span> | <a href="https://github.com/simonclur/VGAP_MobileTurnViewExchange" target="_blank">View on GitHub</a></div>
        </div>
    </div>

    <div id="tooltip" class="tooltip"></div>

    <script>
        let currentGameData = null;
        let svgElement = null;
        let tooltip = null;
        let currentZoom = 1;
        let currentPan = { x: 0, y: 0 };
        let isDragging = false;
        let dragStart = { x: 0, y: 0 };

        // Color schemes
        const Colors = {
            // Planets by happiness - all in shades of green
            PLANET_HAPPY: '#4caf50',      // Bright green (>70%)
            PLANET_MODERATE: '#8bc34a',   // Medium green (40-70%)
            PLANET_UNHAPPY: '#a5d6a7',    // Light green (<40%)
            PLANET_ENEMY: '#ff5722',      // Orange
            PLANET_NEUTRAL: '#9e9e9e',    // Gray
            
            // Starbases
            STARBASE_MINE: '#00d4ff',     // Cyan
            STARBASE_ENEMY: '#f44336',    // Red
            
            // Ships
            SHIP_MINE: '#00ff00',         // Green
            SHIP_ENEMY: '#ff4444',        // Red
            
            // Nebulas
            NEBULA_FILL: 'rgba(128, 0, 128, 0.3)', // Purple transparent
            NEBULA_STROKE: '#800080',     // Purple
            
            // Notes
            NOTE_COLOR: '#ffeb3b',        // Yellow
            
            // Allied objects
            ALLIED: '#4a90e2',           // Blue
        };

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            svgElement = document.getElementById('starmap');
            tooltip = document.getElementById('tooltip');
            
            initializeEventListeners();
            initializePanZoom();
            setBuildDate();
            loadSampleData();
        });

        function initializeEventListeners() {
            // File input
            document.getElementById('fileInput').addEventListener('change', handleFileSelect);
            
            // Display toggles
            ['showPlanets', 'showShips', 'showStarbases', 'showNebulas', 'showNotes'].forEach(id => {
                document.getElementById(id).addEventListener('change', redrawStarmap);
            });
            
            // Zoom controls
            document.getElementById('zoomIn').addEventListener('click', () => zoomStarmap(1.4));
            document.getElementById('zoomOut').addEventListener('click', () => zoomStarmap(0.714)); // 1/1.4
            document.getElementById('resetZoom').addEventListener('click', resetView);
            document.getElementById('fitToScreen').addEventListener('click', fitToScreen);
        }

        function initializePanZoom() {
            svgElement.addEventListener('mousedown', startDrag);
            svgElement.addEventListener('mousemove', drag);
            svgElement.addEventListener('mouseup', endDrag);
            svgElement.addEventListener('mouseleave', endDrag);
            svgElement.addEventListener('wheel', handleWheel, { passive: false });
        }

        function setBuildDate() {
            const buildDateElement = document.getElementById('buildDate');
            buildDateElement.textContent = 'Loading...';
            
            fetch('https://api.github.com/repos/simonclur/VGAP_MobileTurnViewExchange/commits/main')
                .then(response => response.json())
                .then(data => {
                    const commitDate = new Date(data.commit.author.date);
                    const formattedDate = commitDate.toLocaleString('en-US', {
                        year: 'numeric',
                        month: 'short',
                        day: 'numeric',
                        hour: '2-digit',
                        minute: '2-digit',
                        timeZoneName: 'short'
                    });
                    buildDateElement.innerHTML = `${formattedDate} <span style="opacity: 0.7;">(<a href="https://github.com/simonclur/VGAP_MobileTurnViewExchange/commit/${data.sha}" target="_blank" style="color: #00d4ff; text-decoration: none;">${data.sha.substring(0, 7)}</a>)</span>`;
                })
                .catch(error => {
                    console.error('Failed to fetch commit date:', error);
                    const fallbackDate = new Date().toLocaleString();
                    buildDateElement.textContent = `${fallbackDate} (offline)`;
                });
        }

        function showStatus(message, type = 'loading') {
            const statusElement = document.getElementById('status');
            statusElement.textContent = message;
            statusElement.className = `status ${type}`;
            statusElement.classList.remove('hidden');
        }

        function hideStatus() {
            document.getElementById('status').classList.add('hidden');
        }

        function loadSampleData() {
            showStatus('Loading sample turn data...', 'loading');
            
            fetch('vgap_gameunknown_turn41_20250917T2327.json')
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Sample data file not found');
                    }
                    return response.json();
                })
                .then(jsonData => {
                    if (!jsonData.rst || !jsonData.rst.settings) {
                        throw new Error('Invalid VGAP turn file format');
                    }
                    
                    // Extract player information
                    const playerInfo = jsonData.rst?.player || {};
                    const playerRaceId = parseInt(playerInfo.raceid, 10) || 0;
                    const playerName = playerInfo.username || 'Unknown';
                    
                    console.log(`Sample data loaded successfully:`);
                    console.log(`- Game: ${jsonData.rst?.settings?.name || 'Unknown'}`);
                    console.log(`- Player: ${playerName} (Race ID: ${playerRaceId})`);
                    console.log(`- Planets: ${jsonData.rst?.planets?.length || 0}`);
                    console.log(`- Ships: ${jsonData.rst?.ships?.length || 0}`);

                    currentGameData = jsonData;
                    initializeStarmap();
                    
                    showStatus('Sample turn data loaded! Upload your own turn file to explore different games. 🌟', 'success');
                    setTimeout(hideStatus, 4000);
                })
                .catch(error => {
                    console.warn('Could not load sample data:', error);
                    showStatus('Ready to load turn data. Please select a VGAP turn file above.', 'info');
                    setTimeout(hideStatus, 3000);
                });
        }

        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (file) {
                processFile(file);
            }
        }

        function processFile(file) {
            showStatus('Reading turn data...', 'loading');
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const jsonData = JSON.parse(e.target.result);
                    
                    if (!jsonData.rst || !jsonData.rst.settings) {
                        throw new Error('Invalid VGAP turn file format');
                    }
                    
                    // Extract player information
                    const playerInfo = jsonData.rst?.player || {};
                    const playerRaceId = parseInt(playerInfo.raceid, 10) || 0;
                    const playerName = playerInfo.username || 'Unknown';
                    const gameName = jsonData.rst?.settings?.name || 'Unknown Game';
                    
                    console.log(`Turn data loaded successfully:`);
                    console.log(`- Game: ${gameName} (Turn: ${jsonData.rst?.settings?.turn || '?'})`);
                    console.log(`- Player: ${playerName} (Race ID: ${playerRaceId})`);
                    console.log(`- Planets: ${jsonData.rst?.planets?.length || 0}`);
                    console.log(`- Ships: ${jsonData.rst?.ships?.length || 0}`);
                    
                    if (playerRaceId === 0) {
                        console.warn("WARNING: No player race ID detected in turn data!");
                        showStatus('Turn data loaded, but player race ID not found. Ownership detection may be incorrect.', 'info');
                    } else {
                        showStatus(`Turn data for ${gameName} loaded successfully! 🎉`, 'success');
                    }

                    currentGameData = jsonData;
                    initializeStarmap();
                    
                    setTimeout(hideStatus, 4000);

                } catch (error) {
                    showStatus(`Error reading file: ${error.message}`, 'error');
                    console.error('File processing error:', error);
                }
            };

            reader.onerror = function() {
                showStatus('Error reading file', 'error');
            };

            reader.readAsText(file);
        }

        function initializeStarmap() {
            if (!currentGameData) return;
            
            // Show controls and starmap
            document.getElementById('controlsSection').classList.remove('hidden');
            document.getElementById('starmapContainer').classList.remove('hidden');
            document.getElementById('legend').classList.remove('hidden');
            
            // Extract and validate player information
            const playerInfo = currentGameData.rst?.player || {};
            const playerId = parseInt(playerInfo.id, 10) || 0;
            const playerRaceId = parseInt(playerInfo.raceid, 10) || 0;
            const playerName = playerInfo.username || 'Unknown';
            const raceName = playerInfo.racename || 'Unknown Race';
            
            console.log(`Initializing starmap for player: ${playerName} (Player ID: ${playerId}, Race: ${raceName}, Race ID: ${playerRaceId})`);
            
            // Debug: Examine the structure of the game data to ensure we're accessing properties correctly
            console.log("Game data structure check:");
            console.log("- Player information:", currentGameData.rst?.player);
            console.log("- Player ID:", playerId);
            console.log("- Player race ID:", playerRaceId);
            
            // Check a sample planet and ship to verify property access
            const samplePlanet = (currentGameData.rst?.planets || [])[0];
            const sampleShip = (currentGameData.rst?.ships || [])[0];
            
            if (samplePlanet) {
                console.log("- Sample planet structure:", samplePlanet);
                console.log("- Planet owner ID:", samplePlanet.ownerid);
            }
            
            if (sampleShip) {
                console.log("- Sample ship structure:", sampleShip);
                console.log("- Ship owner ID:", sampleShip.ownerid);
            }
            
            // Calculate starmap dimensions based on game data
            const { width, height } = calculateStarmapDimensions();
            svgElement.setAttribute('width', width);
            svgElement.setAttribute('height', height);
            svgElement.setAttribute('viewBox', `0 0 ${width} ${height}`);
            
            // Display player information in UI if available
            const gameTitle = document.querySelector('h1');
            if (gameTitle && playerId > 0) {
                const gameName = currentGameData.rst?.settings?.name || 'Unknown Game';
                const raceName = playerInfo.racename || 'Unknown Race';
                
                // Update the main title
                gameTitle.textContent = `🌌 VGAP Starmap - ${playerName}`;
                
                // Add game name as a subtitle
                const subtitle = document.createElement('div');
                subtitle.textContent = `${gameName} - Playing as ${raceName}`;
                subtitle.style.fontSize = '0.7em';
                subtitle.style.opacity = '0.8';
                subtitle.style.marginTop = '5px';
                
                // Clear existing content and add title with subtitle
                gameTitle.innerHTML = '';
                const mainTitle = document.createElement('span');
                mainTitle.textContent = `🌌 VGAP Starmap - ${playerName}`;
                gameTitle.appendChild(mainTitle);
                gameTitle.appendChild(document.createElement('br'));
                gameTitle.appendChild(subtitle);
                
                // Update player info in the legend
                const playerInfoHtml = `
                    <span>${playerName} (${raceName})</span><br>
                    <span style="font-size: 0.9em; opacity: 0.9;">Player ID: ${playerId} | Race ID: ${playerRaceId}</span>
                `;
                document.getElementById('playerNameDisplay').innerHTML = playerInfoHtml;
            } else {
                // Handle case where player info is not available
                document.getElementById('playerNameDisplay').innerHTML = '<span>Unknown Player</span>';
            }
            
            redrawStarmap();
        }

        function createScalingFunctions(svgWidth, svgHeight, gameData) {
            // Calculate the actual coordinate bounds from planet data
            const planets = gameData.rst?.planets || [];
            let minX = 0, maxX = 2000, minY = 0, maxY = 2000;
            
            if (planets.length > 0) {
                const xCoords = planets.map(p => p.x).filter(x => x !== undefined);
                const yCoords = planets.map(p => p.y).filter(y => y !== undefined);
                
                minX = Math.min(...xCoords);
                maxX = Math.max(...xCoords);
                minY = Math.min(...yCoords);
                maxY = Math.max(...yCoords);
                
                console.log(`Game coordinate bounds: X=${minX}-${maxX}, Y=${minY}-${maxY}`);
            }
            
            // Add padding to the coordinate system
            const padding = 100;
            const gameMinX = minX - padding;
            const gameMaxX = maxX + padding;
            const gameMinY = minY - padding;
            const gameMaxY = maxY + padding;
            const gameWidth = gameMaxX - gameMinX;
            const gameHeight = gameMaxY - gameMinY;
            
            // Calculate scale to fit game coordinates into SVG coordinates
            const scaleFactorX = svgWidth / gameWidth;
            const scaleFactorY = svgHeight / gameHeight;
            const scaleFactor = Math.min(scaleFactorX, scaleFactorY); // Maintain aspect ratio
            
            // Center the game area in the SVG
            const offsetX = (svgWidth - (gameWidth * scaleFactor)) / 2;
            const offsetY = (svgHeight - (gameHeight * scaleFactor)) / 2;
            
            console.log(`Scale factor: ${scaleFactor.toFixed(3)}, offset: (${offsetX.toFixed(1)}, ${offsetY.toFixed(1)})`);
            
            // Transform game coordinates to SVG coordinates
            const scaleX = (x) => {
                const gameX = (x || 0) - gameMinX;
                return gameX * scaleFactor + offsetX;
            };
            
            const scaleY = (y) => {
                const gameY = (y || 0) - gameMinY;
                // Flip Y coordinate: SVG Y=0 is top, VGAP Y=0 is bottom
                return (gameHeight - gameY) * scaleFactor + offsetY;
            };
            
            // Store bounds for viewBox calculation (now in SVG coordinate space)
            window.gameBounds = {
                minX: offsetX,
                maxX: offsetX + (gameWidth * scaleFactor),
                minY: offsetY,
                maxY: offsetY + (gameHeight * scaleFactor),
                width: gameWidth * scaleFactor,
                height: gameHeight * scaleFactor,
                // Store original game coordinates for reference
                gameMinX: gameMinX,
                gameMaxX: gameMaxX,
                gameMinY: gameMinY,
                gameMaxY: gameMaxY,
                gameWidth: gameWidth,
                gameHeight: gameHeight,
                scaleFactor: scaleFactor
            };
            
            console.log(`Set up coordinate system: SVG bounds ${offsetX.toFixed(1)},${offsetY.toFixed(1)} to ${(offsetX + gameWidth * scaleFactor).toFixed(1)},${(offsetY + gameHeight * scaleFactor).toFixed(1)}`);
            
            return { scaleX, scaleY };
        }        function calculateStarmapDimensions() {
            // Use standard VGAP map aspect ratio (typically square maps)
            const gameSettings = currentGameData.rst?.settings;
            const mapWidth = gameSettings?.mapwidth || 2000;
            const mapHeight = gameSettings?.mapheight || 2000;
            const aspectRatio = mapWidth / mapHeight;
            
            // Base dimensions that work well for display
            const baseHeight = 800;
            const baseWidth = Math.max(1200, baseHeight * aspectRatio);
            
            return { 
                width: baseWidth, 
                height: baseHeight
            };
        }

        function redrawStarmap() {
            if (!currentGameData || !svgElement) return;
            
            // Clear existing content
            svgElement.innerHTML = '';

            const { width, height } = calculateStarmapDimensions();
            
            // Extract player information properly
            const playerInfo = currentGameData.rst?.player || {};
            const playerId = parseInt(playerInfo.id, 10) || 0;
            const playerRaceId = parseInt(playerInfo.raceid, 10) || 0;
            
            // Debug: Log the player object structure for verification
            console.log("Player info summary:");
            console.log("- Player ID:", playerId);
            console.log("- Race ID:", playerRaceId);
            console.log("- Username:", playerInfo.username || 'Unknown');
            console.log("- Race name:", playerInfo.racename || 'Unknown');
            
            // Add a fallback for missing player data
            if (playerId === 0) {
                console.warn("Player ID not found in turn data! Using neutral view.");
            }
            
            // Update SVG dimensions and viewBox
            svgElement.setAttribute('width', width);
            svgElement.setAttribute('height', height);
            
            // Only set initial viewBox if it hasn't been set yet (preserve zoom/pan)
            if (!svgElement.getAttribute('viewBox') || svgElement.getAttribute('viewBox') === 'null null null null') {
                svgElement.setAttribute('viewBox', `0 0 ${width} ${height}`);
                console.log(`Initial viewBox: 0 0 ${width} ${height}`);
            } else {
                console.log(`Preserving current viewBox: ${svgElement.getAttribute('viewBox')}`);
            }
            
            // Create scaling functions using authentic Planets.nu coordinate system
            const { scaleX, scaleY } = createScalingFunctions(width, height, currentGameData);
            
            // Add border rect using SVG bounds
            if (window.gameBounds) {
                const bounds = window.gameBounds;
                const borderRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                borderRect.setAttribute("x", bounds.minX);
                borderRect.setAttribute("y", bounds.minY);
                borderRect.setAttribute("width", bounds.width);
                borderRect.setAttribute("height", bounds.height);
                borderRect.setAttribute("fill", "none");
                borderRect.setAttribute("stroke", "#444");
                borderRect.setAttribute("stroke-width", "2");
                svgElement.appendChild(borderRect);
                console.log(`Added border rect: ${bounds.minX.toFixed(1)},${bounds.minY.toFixed(1)} ${bounds.width.toFixed(1)}x${bounds.height.toFixed(1)}`);
            }
            
            // Pass scaling functions to drawing functions
            const drawingContext = { scaleX, scaleY };
            
            // Log checkbox states for debugging
            console.log('Checkbox states:', {
                nebulas: document.getElementById('showNebulas').checked,
                planets: document.getElementById('showPlanets').checked,
                starbases: document.getElementById('showStarbases').checked,
                ships: document.getElementById('showShips').checked,
                notes: document.getElementById('showNotes').checked
            });
            
            // Draw nebulas first (background)
            if (document.getElementById('showNebulas').checked) {
                console.log('Drawing nebulas...');
                drawNebulas(svgElement, drawingContext);
            }
            
            // Draw planets
            if (document.getElementById('showPlanets').checked) {
                console.log('Drawing planets...');
                drawPlanets(svgElement, playerId, drawingContext);
            }
            
            // Draw starbases
            if (document.getElementById('showStarbases').checked) {
                console.log('Drawing starbases...');
                drawStarbases(svgElement, playerId, drawingContext);
            }
            
            // Draw ships
            if (document.getElementById('showShips').checked) {
                console.log('Drawing ships...');
                drawShips(svgElement, playerId, drawingContext);
            }
            
            // Draw strategic notes
            if (document.getElementById('showNotes').checked) {
                console.log('Drawing strategic notes...');
                drawStrategicNotes(svgElement, drawingContext);
            }
        }

        function drawNebulas(parent, drawingContext) {
            const nebulas = currentGameData.rst?.nebulas || [];
            const { scaleX, scaleY } = drawingContext;
            
            // Calculate zoom scale for stroke width (with fallback)
            const currentZoomLevel = getCurrentZoomLevel();
            const zoomScale = 1 / currentZoomLevel;
            
            nebulas.forEach(nebula => {
                const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                circle.setAttribute("cx", scaleX(nebula.x || 0));
                circle.setAttribute("cy", scaleY(nebula.y || 0));
                circle.setAttribute("r", (nebula.radius || 50) * 0.5); // Scale radius down for display
                circle.setAttribute("fill", Colors.NEBULA_FILL);
                circle.setAttribute("stroke", Colors.NEBULA_STROKE);
                circle.setAttribute("stroke-width", 2 * zoomScale);
                circle.setAttribute("stroke-dasharray", `${5 * zoomScale},${5 * zoomScale}`);
                
                addTooltipToElement(circle, {
                    title: `🌫️ ${nebula.name || 'Nebula'}`,
                    data: {
                        'ID': nebula.id,
                        'Location': `(${nebula.x}, ${nebula.y})`,
                        'Radius': `${nebula.radius} ly`,
                        'Intensity': nebula.intensity,
                        'Gas Level': nebula.gas
                    }
                });
                
                parent.appendChild(circle);
            });
        }

        function drawPlanets(parent, playerId, drawingContext) {
            const planets = currentGameData.rst?.planets || [];
            const starbases = currentGameData.rst?.starbases || [];
            const starbaseMap = {};
            const { scaleX, scaleY } = drawingContext;
            
            // Get map settings for wrap-around universe
            const gameSettings = currentGameData.rst?.settings || {};
            const mapWidth = gameSettings.mapwidth || 2000;
            const mapHeight = gameSettings.mapheight || 2000;
            
            console.log(`Drawing ${planets.length} planets with wrap-around universe (${mapWidth}x${mapHeight})`);
            console.log(`Found ${starbases.length} starbases in data`);
            console.log(`First few planets:`, planets.slice(0, 3).map(p => ({ name: p.name, x: p.x, y: p.y })));
            
            if (starbases.length > 0) {
                console.log(`First few starbases:`, starbases.slice(0, 3).map(sb => ({ 
                    id: sb.id, 
                    planetid: sb.planetid,
                    name: sb.name
                })));
            }
            
            // Create starbase lookup
            starbases.forEach(sb => {
                starbaseMap[sb.planetid] = sb;
            });
            
            console.log(`Starbase map created with ${Object.keys(starbaseMap).length} entries`);
            
            let renderCount = 0;
            let errorCount = 0;
            let starbaseCount = 0;
            
            planets.forEach((planet, index) => {
                try {
                    // Check if this planet has a starbase
                    if (starbaseMap[planet.id]) {
                        starbaseCount++;
                        if (index < 5) {
                            console.log(`Planet ${planet.name} (ID: ${planet.id}) has starbase:`, starbaseMap[planet.id]);
                        }
                    }
                    
                    // Draw main planet at its actual position
                    drawSinglePlanet(parent, planet, starbaseMap, scaleX, scaleY, playerId, index < 3);
                    renderCount++;
                    
                    // Draw wrap-around copies for edge planets
                    drawWrapAroundCopies(parent, planet, starbaseMap, scaleX, scaleY, mapWidth, mapHeight, playerId);
                } catch (error) {
                    errorCount++;
                    console.warn(`Error rendering planet ${planet.name || planet.id} at (${planet.x}, ${planet.y}):`, error);
                }
            });
            
            console.log(`Planet rendering complete: ${renderCount} planets rendered, ${starbaseCount} with starbases, ${errorCount} errors`);
        }
        
        function drawSinglePlanet(parent, planet, starbaseMap, scaleX, scaleY, playerId, showDebug = false) {
            if (!planet || (!planet.x && planet.x !== 0) || (!planet.y && planet.y !== 0)) {
                console.warn('Invalid planet data:', planet);
                return;
            }
            
            const cx = scaleX(planet.x);
            const cy = scaleY(planet.y);
            const isOwnedPlanet = parseInt(planet.ownerid, 10) === parseInt(playerId, 10);
            
            if (showDebug) {
                console.log(`Planet ${planet.name}: game coords (${planet.x}, ${planet.y}) -> screen coords (${cx.toFixed(1)}, ${cy.toFixed(1)})`);
            }
            
            // Calculate current zoom level to scale elements consistently (with fallback)
            const currentZoomLevel = getCurrentZoomLevel();
            
            // Scale element sizes inversely with zoom so they stay constant visual size
            const zoomScale = 1 / currentZoomLevel;
            const radiusPx = 7.5 * zoomScale;
            const fontSize = 10 * zoomScale;
            const strokeWidth = 1 * zoomScale;
            
            // Draw starbase highlight if present (like dashboard)
            if (starbaseMap[planet.id]) {
                const square = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                const side = radiusPx * 2.2;
                square.setAttribute("x", cx - side / 2);
                square.setAttribute("y", cy - side / 2);
                square.setAttribute("width", side);
                square.setAttribute("height", side);
                square.setAttribute("fill", "none");
                square.setAttribute("stroke", "#ffeb3b");
                square.setAttribute("stroke-width", 2 * zoomScale);
                parent.appendChild(square);
            }
            
            // Add starbase planning highlights for owned planets without starbases
            if (isOwnedPlanet && !starbaseMap[planet.id]) {
                const starbases = currentGameData.rst?.starbases || [];
                const starbaseBuilds = currentGameData.rst?.starbasebuilds || [];
                const starbaseReq = calculatePlanetStarbaseRequirements(planet, starbases, starbaseBuilds);
                
                if (starbaseReq) {
                    if (starbaseReq.isBuildingStarbase) {
                        // Building starbase - pulsing orange square
                        const buildSquare = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                        const side = radiusPx * 2.5;
                        buildSquare.setAttribute("x", cx - side / 2);
                        buildSquare.setAttribute("y", cy - side / 2);
                        buildSquare.setAttribute("width", side);
                        buildSquare.setAttribute("height", side);
                        buildSquare.setAttribute("fill", "none");
                        buildSquare.setAttribute("stroke", "#ff9800");
                        buildSquare.setAttribute("stroke-width", 3 * zoomScale);
                        buildSquare.setAttribute("stroke-dasharray", "5,3");
                        buildSquare.style.animation = "pulse 2s infinite";
                        parent.appendChild(buildSquare);
                    } else if (starbaseReq.avgCompletion >= 70) {
                        // Close to starbase requirements - multiple rings like note_utils.py
                        const colors = ["#09e4ee", "#0c6ee6", "#09e4ee"];
                        const radii = [14, 15, 16];
                        
                        for (let i = 0; i < 3; i++) {
                            const ring = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                            ring.setAttribute("cx", cx);
                            ring.setAttribute("cy", cy);
                            ring.setAttribute("r", (radii[i] * zoomScale));
                            ring.setAttribute("fill", "none");
                            ring.setAttribute("stroke", colors[i]);
                            ring.setAttribute("stroke-width", (i === 1 ? 3 : 1) * zoomScale);
                            parent.appendChild(ring);
                        }
                    }
                    
                    // Check for connected starbase network
                    const allPlanets = currentGameData.rst?.planets || [];
                    const suppliers = findConnectedResourceSuppliers(planet, allPlanets, playerId);
                    
                    // Check if connected suppliers can provide all missing resources
                    const suppliedResources = new Set();
                    suppliers.forEach(supplier => {
                        supplier.provides.forEach(resource => suppliedResources.add(resource));
                    });
                    
                    const needsResources = [];
                    if (starbaseReq.missing.duranium > 0) needsResources.push('D');
                    if (starbaseReq.missing.tritanium > 0) needsResources.push('T'); 
                    if (starbaseReq.missing.molybdenum > 0) needsResources.push('M');
                    if (starbaseReq.missing.megacredits > 0) needsResources.push('MC');
                    
                    const hasConnectedSupply = needsResources.every(need => 
                        suppliedResources.has(need) || need === 'MC' && suppliedResources.has('MC')
                    );
                    
                    if (hasConnectedSupply && suppliers.length > 0) {
                        // Connected starbase network - draw lines to suppliers
                        suppliers.slice(0, 2).forEach(supplier => {
                            const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
                            line.setAttribute("x1", cx);
                            line.setAttribute("y1", cy);
                            line.setAttribute("x2", scaleX(supplier.planet.x));
                            line.setAttribute("y2", scaleY(supplier.planet.y));
                            line.setAttribute("stroke", "#f204e2");
                            line.setAttribute("stroke-width", 1 * zoomScale);
                            line.setAttribute("stroke-dasharray", "3,3");
                            line.setAttribute("opacity", "0.7");
                            parent.appendChild(line);
                        });
                        
                        // Add connected indicator circle
                        const connectedCircle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                        connectedCircle.setAttribute("cx", cx);
                        connectedCircle.setAttribute("cy", cy);
                        connectedCircle.setAttribute("r", 10 * zoomScale);
                        connectedCircle.setAttribute("fill", "none");
                        connectedCircle.setAttribute("stroke", "#f204e2");
                        connectedCircle.setAttribute("stroke-width", 1 * zoomScale);
                        parent.appendChild(connectedCircle);
                    }
                }
            }

            const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                circle.setAttribute("cx", cx);
                circle.setAttribute("cy", cy);
                circle.setAttribute("r", radiusPx);
                circle.setAttribute("fill", getPlanetColor(planet, playerId));
                circle.setAttribute("stroke", "#ffffff");
                circle.setAttribute("stroke-width", strokeWidth);
                circle.style.cursor = "pointer";
                
            // Add planet name label
            const label = document.createElementNS("http://www.w3.org/2000/svg", "text");
            label.setAttribute("x", cx);
            label.setAttribute("y", cy + radiusPx + (15 * zoomScale));
            label.setAttribute("text-anchor", "middle");
            label.setAttribute("fill", "#ffffff");
            label.setAttribute("font-size", fontSize);
            label.setAttribute("font-weight", "normal");  // Changed from bold to normal
            label.textContent = (planet.name || `Planet ${planet.id}`).substring(0, 12);                // Find ships at this planet
                const ships = currentGameData.rst?.ships || [];
                const shipsAtPlanet = ships.filter(ship => 
                    parseInt(ship.x, 10) === parseInt(planet.x, 10) && 
                    parseInt(ship.y, 10) === parseInt(planet.y, 10)
                );
                
                let tooltipData = {
                    'ID': planet.id,
                    'Owner': getOwnerUsername(planet.ownerid),
                    'Location': `(${planet.x}, ${planet.y})`,
                    'Friendly Code': planet.friendlycode || '',
                    'Temperature': `${planet.temp || 0}°`,
                    'Colonists': `${(planet.clans || 0).toLocaleString()}`,
                    'Natives': `${(planet.nativeclans || 0).toLocaleString()}`,
                    'Native Race': planet.nativeracename || 'None',
                    'Native Government': planet.nativegovernmentname || 'None',
                    'Factories': planet.factories || 0,
                    'Mines': planet.mines || 0,
                    'Defense': planet.defense || 0,
                    'Colonist Happiness': `${planet.colonisthappypoints || 0}%`,
                    'Native Happiness': `${planet.nativehappypoints || 0}%`,
                    'Starbase': starbaseMap[planet.id] ? 'Yes' : 'No',
                    'Minerals': `N:${planet.neutronium || 0} D:${planet.duranium || 0} T:${planet.tritanium || 0} M:${planet.molybdenum || 0}`
                };
                
                // Add starbase requirements for owned planets without starbases
                if (isOwnedPlanet && !starbaseMap[planet.id]) {
                    const starbases = currentGameData.rst?.starbases || [];
                    const starbaseBuilds = currentGameData.rst?.starbasebuilds || [];
                    const starbaseReq = calculatePlanetStarbaseRequirements(planet, starbases, starbaseBuilds);
                    
                    if (starbaseReq) {
                        tooltipData['━━━ Starbase Requirements ━━━'] = '';
                        
                        if (starbaseReq.isBuildingStarbase) {
                            tooltipData['🏗️ Status'] = 'Building Starbase This Turn';
                        } else {
                            tooltipData['📊 Completion'] = `${starbaseReq.avgCompletion.toFixed(1)}%`;
                            tooltipData['🔴 Missing D'] = starbaseReq.missing.duranium > 0 ? starbaseReq.missing.duranium : '✓';
                            tooltipData['🔴 Missing T'] = starbaseReq.missing.tritanium > 0 ? starbaseReq.missing.tritanium : '✓';
                            tooltipData['🔴 Missing M'] = starbaseReq.missing.molybdenum > 0 ? starbaseReq.missing.molybdenum : '✓';
                            tooltipData['🔴 Missing MC'] = starbaseReq.missing.megacredits > 0 ? starbaseReq.missing.megacredits : '✓';
                        }
                        
                        // Find connected resource suppliers
                        const allPlanets = currentGameData.rst?.planets || [];
                        const suppliers = findConnectedResourceSuppliers(planet, allPlanets, playerId);
                        if (suppliers.length > 0) {
                            tooltipData['🤝 Connected Suppliers'] = suppliers.slice(0, 3).map(s => 
                                `${s.planet.name?.substring(0, 8) || 'Planet'} (${s.provides.join(',')}, ${Math.round(s.distance)}ly)`
                            ).join(', ');
                        }
                    }
                }
                
                // Add ships at this location if any
                if (shipsAtPlanet.length > 0) {
                    tooltipData['Ships at Location'] = `${shipsAtPlanet.length} ship(s)`;
                    
                    // Add information about each ship
                    shipsAtPlanet.forEach((ship, index) => {
                        const isMyShip = parseInt(ship.ownerid, 10) === parseInt(playerId, 10);
                        const shipPrefix = isMyShip ? '🟢' : '🔴';
                        const hullInfo = getHullInfo(ship.hullid);
                        const raceInfo = getPlayerRace(ship.ownerid);
                        const hullName = hullInfo ? hullInfo.name : (ship.hullname || 'Unknown Hull');
                        tooltipData[`Ship ${index + 1}`] = `${shipPrefix} ${ship.name || 'Unnamed'} (${hullName})${raceInfo ? ' - ' + raceInfo : ''}`;
                    });
                }
                
                addTooltipToElement(circle, {
                    title: `🪐 ${planet.name || 'Unnamed Planet'}`,
                    data: tooltipData
                });
                
                parent.appendChild(circle);
                parent.appendChild(label);
        }
        
        function drawWrapAroundCopies(parent, planet, starbaseMap, scaleX, scaleY, mapWidth, mapHeight, playerId) {
            const x = planet.x || 0;
            const y = planet.y || 0;
            
            // Get current viewBox to determine which wrap-around copies to draw
            const viewBox = svgElement.getAttribute('viewBox').split(' ').map(parseFloat);
            const [viewLeft, viewTop, viewWidth, viewHeight] = viewBox;
            const viewRight = viewLeft + viewWidth;
            const viewBottom = viewTop + viewHeight;
            
            // Standard VGAP wrap-around: 2000x2000 universe wraps at edges
            const universeWidth = 2000;
            const universeHeight = 2000;
            
            // Check all 8 wrap-around positions (excluding original [0,0])
            const offsets = [
                [-universeWidth, -universeHeight], [0, -universeHeight], [universeWidth, -universeHeight],
                [-universeWidth, 0],                                     [universeWidth, 0],
                [-universeWidth, universeHeight],  [0, universeHeight],  [universeWidth, universeHeight]
            ];
            
            offsets.forEach(([dx, dy]) => {
                const wrappedX = x + dx;
                const wrappedY = y + dy;
                
                // Only draw if the wrapped position would be visible in current view
                if (wrappedX >= viewLeft - 100 && wrappedX <= viewRight + 100 &&
                    wrappedY >= viewTop - 100 && wrappedY <= viewBottom + 100) {
                    
                    // Create a wrapped version of the planet
                    const wrappedPlanet = { ...planet, x: wrappedX, y: wrappedY };
                    drawSinglePlanet(parent, wrappedPlanet, starbaseMap, scaleX, scaleY, playerId, false);
                }
            });
        }

        function drawStarbases(parent, playerId, drawingContext) {
            // Starbases are now drawn as part of drawPlanets function (as highlighted squares)
            // This function is kept for consistency but doesn't need to do anything
            // since we're following the dashboard pattern of showing starbases as planet highlights
        }

        function drawShips(parent, playerId, drawingContext) {
            const ships = currentGameData.rst?.ships || [];
            const planets = currentGameData.rst?.planets || [];
            const { scaleX, scaleY } = drawingContext;
            
            // Safely parse playerId to a number
            const playerIdNum = parseInt(playerId, 10) || 0;
            
            console.log(`Drawing ${ships.length} ships with playerId=${playerIdNum}`);
            
            if (ships.length === 0) {
                console.log("No ships found in game data");
                return;
            }
            
            // Debug: Log the first few ships and directly examine the ship structure
            console.log("First ship raw data:", ships[0]);
            console.log("First few ships:", ships.slice(0, 3).map(s => {
                // Safely parse ownerid to a number
                const ownerIdNum = parseInt(s.ownerid, 10) || 0;
                return { 
                    name: s.name,
                    ownerid: s.ownerid,
                    owneridNum: ownerIdNum,
                    x: s.x,
                    y: s.y,
                    playerId: playerIdNum,
                    isPlayerShip: ownerIdNum === playerIdNum
                };
            }));

            let renderCount = 0;
            let errorCount = 0;

            ships.forEach((ship, index) => {
                try {
                    if (!ship || (!ship.x && ship.x !== 0) || (!ship.y && ship.y !== 0)) {
                        console.warn(`Ship ${index} has invalid coordinates:`, ship);
                        errorCount++;
                        return;
                    }

                    const cx = scaleX(ship.x);
                    const cy = scaleY(ship.y);
                    
                    // Safely parse ship owner ID to ensure proper comparison
                    const shipOwnerIdNum = parseInt(ship.ownerid, 10) || 0;
                    const isMine = shipOwnerIdNum === playerIdNum;
                    
                    // Check if ship is at a planet (like dashboard)
                    const atPlanet = planets.find(p => 
                        Math.abs(p.x - ship.x) < 2 && Math.abs(p.y - ship.y) < 2
                    );
                
                    if (atPlanet) {
                        // Calculate zoom scale for consistent sizing (with fallback)
                        const currentZoomLevel = getCurrentZoomLevel();
                        const zoomScale = 1 / currentZoomLevel;
                        
                        // Ship at planet - draw circle around planet
                        const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                        circle.setAttribute("cx", scaleX(atPlanet.x));
                        circle.setAttribute("cy", scaleY(atPlanet.y));
                        circle.setAttribute("r", 16 * zoomScale);
                        circle.setAttribute("fill", "none");
                        circle.setAttribute("stroke", isMine ? "#00e676" : "#e53935");
                        circle.setAttribute("stroke-width", 2 * zoomScale);
                        circle.style.cursor = "pointer";
                        
                        // Get enhanced hull and race information
                        const hullInfo = getHullInfo(ship.hullid);
                        const raceInfo = getPlayerRace(ship.ownerid);
                        const shipTitle = hullInfo ? `🚢 ${ship.name || 'Unnamed Ship'} (${hullInfo.name})` : `🚢 ${ship.name || 'Unnamed Ship'}`;
                        
                        // Get weapon information
                        const beamInfo = getBeamInfo(ship.beamid);
                        const torpedoInfo = getTorpedoInfo(ship.torpedoid);
                        
                        const tooltipData = {
                            'ID': ship.id,
                            'Owner': getOwnerUsername(ship.ownerid),
                            'Race': raceInfo || 'Unknown',
                            'Hull': hullInfo ? hullInfo.name : (ship.hullname || 'Unknown'),
                            'Hull Mass': hullInfo ? `${hullInfo.mass || 0} kt` : 'Unknown',
                            'Hull Cargo': hullInfo ? `${hullInfo.cargo || 0} kt` : 'Unknown',
                            'Location': `(${ship.x}, ${ship.y})`,
                            'At Planet': atPlanet.name || atPlanet.id,
                            'Mass': `${ship.mass || 0} kt`,
                            'Fuel': `${ship.neutronium || 0} kt`,
                            'Crew': ship.crew || 0,
                            'Damage': `${ship.damage || 0}%`
                        };
                        
                        // Add weapon information if available
                        if (ship.beams > 0) {
                            tooltipData['Beams'] = beamInfo ? 
                                `${ship.beams} ${beamInfo.name} (Dmg: ${beamInfo.damage})` : 
                                `${ship.beams}`;
                        }
                        
                        if (ship.torps > 0) {
                            tooltipData['Torpedoes'] = torpedoInfo ? 
                                `${ship.torps} ${torpedoInfo.name} (Dmg: ${torpedoInfo.damage})` : 
                                `${ship.torps}`;
                        }
                        
                        if (ship.fighters > 0) {
                            tooltipData['Fighters'] = ship.fighters;
                        }
                        
                        addTooltipToElement(circle, {
                            title: shipTitle,
                            data: tooltipData
                        });
                        
                        parent.appendChild(circle);
                    } else {
                        // Calculate zoom scale for consistent sizing (with fallback)
                        const currentZoomLevel = getCurrentZoomLevel();
                        const zoomScale = 1 / currentZoomLevel;
                        
                        // Ship in space - draw small dot
                        const dot = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                        dot.setAttribute("cx", cx);
                        dot.setAttribute("cy", cy);
                        dot.setAttribute("r", 4 * zoomScale);
                        dot.setAttribute("fill", isMine ? "#00e676" : "#e53935");
                        dot.setAttribute("stroke", "#fff");
                        dot.setAttribute("stroke-width", 1 * zoomScale);
                        dot.style.cursor = "pointer";
                        
                        // Get enhanced hull and race information
                        const hullInfo = getHullInfo(ship.hullid);
                        const raceInfo = getPlayerRace(ship.ownerid);
                        const shipTitle = hullInfo ? `🚢 ${ship.name || 'Unnamed Ship'} (${hullInfo.name})` : `🚢 ${ship.name || 'Unnamed Ship'}`;
                        
                        // Get weapon information
                        const beamInfo = getBeamInfo(ship.beamid);
                        const torpedoInfo = getTorpedoInfo(ship.torpedoid);
                        
                        const tooltipData = {
                            'ID': ship.id,
                            'Owner': getOwnerUsername(ship.ownerid),
                            'Race': raceInfo || 'Unknown',
                            'Hull': hullInfo ? hullInfo.name : (ship.hullname || 'Unknown'),
                            'Hull Mass': hullInfo ? `${hullInfo.mass || 0} kt` : 'Unknown',
                            'Hull Cargo': hullInfo ? `${hullInfo.cargo || 0} kt` : 'Unknown',
                            'Hull Tech': hullInfo ? `Level ${hullInfo.techlevel || hullInfo.tech || 0}` : 'Unknown',
                            'Location': `(${ship.x}, ${ship.y})`,
                            'Mass': `${ship.mass || 0} kt`,
                            'Fuel': `${ship.neutronium || 0} kt`,
                            'Crew': ship.crew || 0,
                            'Damage': `${ship.damage || 0}%`
                        };
                        
                        // Add weapon information if available
                        if (ship.beams > 0) {
                            tooltipData['Beams'] = beamInfo ? 
                                `${ship.beams} ${beamInfo.name} (Dmg: ${beamInfo.damage})` : 
                                `${ship.beams}`;
                        }
                        
                        if (ship.torps > 0) {
                            tooltipData['Torpedoes'] = torpedoInfo ? 
                                `${ship.torps} ${torpedoInfo.name} (Dmg: ${torpedoInfo.damage})` : 
                                `${ship.torps}`;
                        }
                        
                        if (ship.fighters > 0) {
                            tooltipData['Fighters'] = ship.fighters;
                        }
                        
                        addTooltipToElement(dot, {
                            title: shipTitle,
                            data: tooltipData
                        });
                        
                        parent.appendChild(dot);
                    }
                    
                    renderCount++;
                } catch (error) {
                    errorCount++;
                    console.warn(`Error rendering ship ${ship.name || ship.id}:`, error);
                }
            });
            
            console.log(`Ship rendering complete: ${renderCount} ships rendered, ${errorCount} errors`);
        }

        function drawStrategicNotes(parent, drawingContext) {
            // This would draw notes from your strategic planning
            // For now, we'll add sample strategic markers
            const strategicPoints = [
                // These would come from your notes/strategy data
                // For demo purposes, showing concept
            ];
            
            const { scaleX, scaleY } = drawingContext;
            
            strategicPoints.forEach(point => {
                const cx = scaleX(point.x);
                const cy = scaleY(point.y);
                
                const marker = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
                marker.setAttribute("points", "0,-8 6,8 -6,8");
                marker.setAttribute("transform", `translate(${cx}, ${cy})`);
                marker.setAttribute("fill", Colors.NOTE_COLOR);
                marker.setAttribute("stroke", "#000000");
                marker.setAttribute("stroke-width", "1");
                marker.style.cursor = "pointer";
                
                addTooltipToElement(marker, {
                    title: `📝 ${point.title}`,
                    data: {
                        'Type': point.type,
                        'Priority': point.priority,
                        'Notes': point.notes
                    }
                });
                
                parent.appendChild(marker);
            });
        }

        // Helper functions
        function getPlayerRaceId() {
            // Safely extract and parse the player race ID from the current game data
            const playerInfo = currentGameData?.rst?.player || {};
            const playerRaceId = playerInfo.raceid;
            
            // Parse the race ID to a number and return 0 if invalid
            const parsedRaceId = parseInt(playerRaceId, 10) || 0;
            
            if (parsedRaceId === 0) {
                console.warn("Warning: Could not determine player race ID from turn data");
            } else {
                console.log(`Player race ID identified: ${parsedRaceId}`);
            }
            
            return parsedRaceId;
        }
        
        function getPlayerId() {
            // Safely extract and parse the player ID from the current game data
            const playerInfo = currentGameData?.rst?.player || {};
            const playerId = playerInfo.id;
            
            // Parse the player ID to a number and return 0 if invalid
            const parsedPlayerId = parseInt(playerId, 10) || 0;
            
            if (parsedPlayerId === 0) {
                console.warn("Warning: Could not determine player ID from turn data");
            } else {
                console.log(`Player ID identified: ${parsedPlayerId}`);
            }
            
            return parsedPlayerId;
        }
        
        function getPlayerInfo() {
            // Get comprehensive player information from turn data
            const playerInfo = currentGameData?.rst?.player || {};
            return {
                id: parseInt(playerInfo.id, 10) || 0,
                raceId: parseInt(playerInfo.raceid, 10) || 0,
                username: playerInfo.username || 'Unknown',
                raceName: playerInfo.racename || 'Unknown Race',
                planetCount: parseInt(playerInfo.planetcount, 10) || 0,
                shipCount: parseInt(playerInfo.shipcount, 10) || 0,
                isAuthenticated: !!playerInfo.authenticated
            };
        }
        
        function getOwnerUsername(ownerId) {
            const players = currentGameData.rst?.players || [];
            const player = players.find(p => parseInt(p.id, 10) === parseInt(ownerId, 10));
            return player ? player.username : `Player ${ownerId}`;
        }

        function getOwnerName(ownerId, playerId) {
            // Safely parse to numbers for proper comparison
            const ownerIdNum = parseInt(ownerId, 10) || 0;
            const playerIdNum = parseInt(playerId, 10) || 0;
            
            if (ownerIdNum === 0) return 'Unowned';
            if (ownerIdNum === playerIdNum) return 'Mine';
            
            // Could add alliance check here
            // if (checkIfAlly(ownerIdNum)) return 'Ally';
            
            return `Player ${ownerIdNum}`;
        }

        function getHullInfo(hullId) {
            if (!hullId) return null;
            const hulls = currentGameData.rst?.hulls || [];
            return hulls.find(hull => parseInt(hull.id, 10) === parseInt(hullId, 10));
        }

        function getRaceInfo(raceId) {
            if (!raceId) return null;
            const races = currentGameData.rst?.races || [];
            return races.find(race => parseInt(race.id, 10) === parseInt(raceId, 10));
        }

        function getPlayerRace(ownerId) {
            // First find the player by ownerId
            const players = currentGameData.rst?.players || [];
            const player = players.find(p => parseInt(p.id, 10) === parseInt(ownerId, 10));
            
            if (!player) return null;
            
            // Then find the race by the player's raceid
            const races = currentGameData.rst?.races || [];
            const race = races.find(r => parseInt(r.id, 10) === parseInt(player.raceid, 10));
            return race ? race.adjective || race.name || race.shortname : null;
        }

        // Get beam weapon information from beam ID
        function getBeamInfo(beamId) {
            if (!beamId || beamId === 0) return null;
            const beams = currentGameData.rst?.beams || [];
            return beams.find(beam => parseInt(beam.id, 10) === parseInt(beamId, 10));
        }

        // Get torpedo weapon information from torpedo ID
        function getTorpedoInfo(torpedoId) {
            if (!torpedoId || torpedoId === 0) return null;
            const torpedos = currentGameData.rst?.torpedos || [];
            return torpedos.find(torpedo => parseInt(torpedo.id, 10) === parseInt(torpedoId, 10));
        }

        // Get beam weapon information from beam ID
        function getBeamInfo(beamId) {
            if (!beamId || beamId === 0) return null;
            const beams = currentGameData.rst?.beams || [];
            return beams.find(beam => parseInt(beam.id, 10) === parseInt(beamId, 10));
        }

        // Get torpedo weapon information from torpedo ID
        function getTorpedoInfo(torpedoId) {
            if (!torpedoId || torpedoId === 0) return null;
            const torpedos = currentGameData.rst?.torpedos || [];
            return torpedos.find(torpedo => parseInt(torpedo.id, 10) === parseInt(torpedoId, 10));
        }

        function getPlanetColor(planet, playerId) {
            // Player ID is now passed directly as a parameter
            // No need to call getPlayerId() again
            
            // Safely access ownerid, ensuring it's properly read as a number
            const ownerId = parseInt(planet.ownerid, 10) || 0;
            
            // Check if the planet is owned by the player (comparing player IDs, not race IDs)
            const isMyPlanet = ownerId === playerId && playerId > 0;
            
            if (ownerId === 0) return Colors.PLANET_NEUTRAL;
            if (!isMyPlanet) {
                // Check if this is an ally (could implement alliance check here if needed)
                // const isAlly = checkIfAlly(ownerId); // Would need to implement this function
                // if (isAlly) return Colors.ALLIED;
                return Colors.PLANET_ENEMY;
            }
            
            // Color by happiness for my planets
            const happiness = parseInt(planet.colonisthappypoints, 10) || 0;
            if (happiness >= 70) return Colors.PLANET_HAPPY;
            if (happiness >= 40) return Colors.PLANET_MODERATE;
            return Colors.PLANET_UNHAPPY;
        }

        function getStarbaseColor(ownerId, playerId) {
            // Player ID is now passed directly as a parameter
            // No need to call getPlayerId() again
            
            // Safely parse values to ensure proper comparison
            const ownerIdNum = parseInt(ownerId, 10) || 0;
            
            const isPlayerStarbase = ownerIdNum === playerId && playerId > 0;
            
            return isPlayerStarbase ? Colors.STARBASE_MINE : Colors.STARBASE_ENEMY;
            
            // Could add alliance check here if needed
            // if (checkIfAlly(ownerIdNum)) return Colors.ALLIED;
        }

        function getShipColor(ownerId, playerId) {
            // Player ID is now passed directly as a parameter
            // No need to call getPlayerId() again
            
            // Safely parse values to ensure proper comparison
            const ownerIdNum = parseInt(ownerId, 10) || 0;
            
            const isPlayerShip = ownerIdNum === playerId && playerId > 0;
            
            return isPlayerShip ? Colors.SHIP_MINE : Colors.SHIP_ENEMY;
            
            // Could add alliance check here if needed
            // if (checkIfAlly(ownerIdNum)) return Colors.ALLIED;
        }

        function getPlanetRadius(planet) {
            // Radius based on development level
            const factories = planet.factories || 0;
            const defense = planet.defense || 0;
            const total = factories + defense;
            
            if (total >= 100) return 12;
            if (total >= 50) return 10;
            if (total >= 20) return 8;
            return 6;
        }

        function getPlayerRadius(planet) {
            // Alias for getPlanetRadius for backward compatibility
            return getPlanetRadius(planet);
        }

        function addTooltipToElement(element, data) {
            element.addEventListener('mouseenter', (e) => {
                showTooltip(e, data);
            });
            
            element.addEventListener('mousemove', (e) => {
                updateTooltipPosition(e);
            });
            
            element.addEventListener('mouseleave', () => {
                hideTooltip();
            });
        }

        function showTooltip(event, data) {
            let html = `<h4>${data.title}</h4>`;
            html += '<div class="tooltip-grid">';
            
            Object.entries(data.data).forEach(([label, value]) => {
                html += `<div class="tooltip-label">${label}:</div><div>${value}</div>`;
            });
            
            html += '</div>';
            
            tooltip.innerHTML = html;
            tooltip.style.display = 'block';
            updateTooltipPosition(event);
        }

        function updateTooltipPosition(event) {
            const rect = document.body.getBoundingClientRect();
            tooltip.style.left = (event.clientX + 10) + 'px';
            tooltip.style.top = (event.clientY - 10) + 'px';
        }

        function hideTooltip() {
            tooltip.style.display = 'none';
        }

        // Pan and zoom functionality
        function startDrag(event) {
            // Prevent dragging on interactive elements
            if (event.target.tagName === 'circle' || event.target.tagName === 'rect') {
                return;
            }
            
            isDragging = true;
            
            // Get current viewBox
            const viewBox = svgElement.getAttribute('viewBox').split(' ').map(parseFloat);
            dragStart = { 
                x: event.clientX,
                y: event.clientY,
                viewBoxX: viewBox[0],
                viewBoxY: viewBox[1]
            };
            
            svgElement.style.cursor = 'grabbing';
            event.preventDefault();
        }

        function drag(event) {
            if (!isDragging) return;
            
            // Calculate drag distance in screen pixels
            const deltaX = event.clientX - dragStart.x;
            const deltaY = event.clientY - dragStart.y;
            
            // Get current viewBox dimensions
            const viewBox = svgElement.getAttribute('viewBox').split(' ').map(parseFloat);
            const [, , vbWidth, vbHeight] = viewBox;
            
            // Convert screen delta to world coordinates
            const rect = svgElement.getBoundingClientRect();
            const worldDeltaX = -(deltaX / rect.width) * vbWidth;
            const worldDeltaY = -(deltaY / rect.height) * vbHeight;
            
            // Update viewBox position
            const newViewBoxX = dragStart.viewBoxX + worldDeltaX;
            const newViewBoxY = dragStart.viewBoxY + worldDeltaY;
            
            svgElement.setAttribute('viewBox', `${newViewBoxX} ${newViewBoxY} ${vbWidth} ${vbHeight}`);
        }

        function endDrag() {
            isDragging = false;
            svgElement.style.cursor = 'move';
        }

        function handleWheel(event) {
            event.preventDefault();
            
            // Get mouse position relative to the SVG
            const rect = svgElement.getBoundingClientRect();
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;
            
            // More fine-grained zoom factors for smoother experience
            const zoomFactor = event.deltaY > 0 ? 0.95 : 1.05;
            zoomStarmapToPoint(zoomFactor, mouseX, mouseY);
        }

        function zoomStarmap(factor) {
            // Legacy function for button clicks - zoom to center
            const rect = svgElement.getBoundingClientRect();
            const centerX = rect.width / 2;
            const centerY = rect.height / 2;
            zoomStarmapToPoint(factor, centerX, centerY);
        }

        function zoomStarmapToPoint(factor, screenX, screenY) {
            if (!svgElement) return;
            
            const rect = svgElement.getBoundingClientRect();
            
            // Get the current viewBox
            const viewBox = svgElement.getAttribute('viewBox').split(' ').map(parseFloat);
            const [vbX, vbY, vbWidth, vbHeight] = viewBox;
            
            // Calculate current and new zoom levels based on SVG dimensions
            const { width, height } = calculateStarmapDimensions();
            const currentActualZoom = width / vbWidth;
            const newActualZoom = currentActualZoom * factor;
            
            // Apply zoom limits
            const clampedZoom = Math.max(0.05, Math.min(20, newActualZoom));
            if (clampedZoom === currentActualZoom) return; // No change
            
            // Calculate the world coordinate that was under the mouse
            const worldX = vbX + (screenX / rect.width) * vbWidth;
            const worldY = vbY + (screenY / rect.height) * vbHeight;
            
            // Calculate new viewBox dimensions
            const newVbWidth = width / clampedZoom;
            const newVbHeight = height / clampedZoom;
            
            // Position the new viewBox so the world coordinate stays under the mouse
            const newVbX = worldX - (screenX / rect.width) * newVbWidth;
            const newVbY = worldY - (screenY / rect.height) * newVbHeight;
            
            svgElement.setAttribute('viewBox', `${newVbX} ${newVbY} ${newVbWidth} ${newVbHeight}`);
            
            updateZoomIndicator();
            
            // Use requestAnimationFrame to ensure viewBox change is processed before redraw
            requestAnimationFrame(() => {
                redrawStarmap();
            });
        }

        function resetView() {
            currentZoom = 1;
            currentPan = { x: 0, y: 0 };
            
            // Reset to initial viewBox showing entire SVG area
            const { width, height } = calculateStarmapDimensions();
            svgElement.setAttribute('viewBox', `0 0 ${width} ${height}`);
            
            updateZoomIndicator();
            
            // Use requestAnimationFrame to ensure viewBox change is processed before redraw
            requestAnimationFrame(() => {
                redrawStarmap();
            });
        }

        function fitToScreen() {
            currentZoom = 1;
            currentPan = { x: 0, y: 0 };
            
            // Same as reset - fits entire SVG area
            const { width, height } = calculateStarmapDimensions();
            svgElement.setAttribute('viewBox', `0 0 ${width} ${height}`);
            
            updateZoomIndicator();
            
            // Use requestAnimationFrame to ensure viewBox change is processed before redraw
            requestAnimationFrame(() => {
                redrawStarmap();
            });
        }

        // Helper function to get current zoom level consistently
        function getCurrentZoomLevel() {
            try {
                if (!svgElement) return 1;
                const viewBox = svgElement.getAttribute('viewBox').split(' ').map(parseFloat);
                const [, , vbWidth] = viewBox;
                const { width } = calculateStarmapDimensions();
                if (width > 0 && vbWidth > 0) {
                    const zoomLevel = width / vbWidth;
                    console.log(`Zoom level calculated: ${zoomLevel.toFixed(2)}, viewBox width: ${vbWidth}, SVG width: ${width}`);
                    return zoomLevel;
                }
            } catch (error) {
                console.log('Error calculating zoom level:', error.message);
            }
            console.log('Using default zoom level: 1');
            return 1;
        }

        function updateZoomIndicator() {
            const indicator = document.getElementById('zoomIndicator');
            if (indicator) {
                // Calculate actual zoom level based on viewBox vs SVG dimensions
                const viewBox = svgElement.getAttribute('viewBox').split(' ').map(parseFloat);
                const [, , vbWidth] = viewBox;
                const { width } = calculateStarmapDimensions();
                const actualZoom = width / vbWidth;
                
                const percentage = Math.round(actualZoom * 100);
                indicator.textContent = `${percentage}%`;
                
                // Add visual feedback for extreme zoom levels
                indicator.className = '';
                if (actualZoom <= 0.1) {
                    indicator.className = 'zoom-min';
                } else if (actualZoom >= 15) {
                    indicator.className = 'zoom-max';
                }
            }
        }

        // Calculate starbase requirements for a single planet
        function calculatePlanetStarbaseRequirements(planet, starbases, starbaseBuilds) {
            // Skip planets that already have a starbase
            const hasStarbase = starbases?.some(sb => sb.planetid === planet.id);
            if (hasStarbase) return null;
            
            // Starbase build requirements (standard cost)
            const required = {
                duranium: 120,
                tritanium: 402,
                molybdenum: 340,
                megacredits: 900
            };
            
            // Check if planet is building a starbase this turn
            const isBuildingStarbase = starbaseBuilds?.some(build => 
                build.planetid === planet.id
            );
            
            // Calculate resource gaps
            const current = {
                duranium: planet.duranium || 0,
                tritanium: planet.tritanium || 0, 
                molybdenum: planet.molybdenum || 0,
                megacredits: planet.megacredits || 0
            };
            
            const missing = {
                duranium: Math.max(0, required.duranium - current.duranium),
                tritanium: Math.max(0, required.tritanium - current.tritanium),
                molybdenum: Math.max(0, required.molybdenum - current.molybdenum),
                megacredits: Math.max(0, required.megacredits - current.megacredits)
            };
            
            // Calculate how close to starbase requirements (0-100%)
            const percentages = {
                duranium: Math.min(100, (current.duranium / required.duranium) * 100),
                tritanium: Math.min(100, (current.tritanium / required.tritanium) * 100),
                molybdenum: Math.min(100, (current.molybdenum / required.molybdenum) * 100),
                megacredits: Math.min(100, (current.megacredits / required.megacredits) * 100)
            };
            
            const avgCompletion = (percentages.duranium + percentages.tritanium + 
                                 percentages.molybdenum + percentages.megacredits) / 4;
            
            return {
                isBuildingStarbase: isBuildingStarbase,
                current: current,
                missing: missing,
                percentages: percentages,
                avgCompletion: avgCompletion
            };
        }

        // Check if planets are connected (within 84LY for resource sharing)
        function areConnectedForStarbase(planet1, planet2, maxDistance = 84) {
            const dx = planet1.x - planet2.x;
            const dy = planet1.y - planet2.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            return distance <= maxDistance;
        }

        // Find planets that can provide resources to support starbase building
        function findConnectedResourceSuppliers(targetPlanet, allPlanets, playerId) {
            const suppliers = [];
            const resourceTargets = {
                megacredits: 2000,
                duranium: 2000,
                tritanium: 2000,
                molybdenum: 2000
            };
            
            for (const planet of allPlanets) {
                if (planet.id === targetPlanet.id) continue;
                if (parseInt(planet.ownerid, 10) !== playerId) continue;
                if (!areConnectedForStarbase(targetPlanet, planet)) continue;
                
                // Check what resources this planet can provide
                const provides = [];
                if ((planet.megacredits || 0) + (planet.supplies || 0) > resourceTargets.megacredits) {
                    provides.push('MC');
                }
                if ((planet.duranium || 0) + (planet.groundduranium || 0) > resourceTargets.duranium) {
                    provides.push('D');
                }
                if ((planet.tritanium || 0) + (planet.groundtritanium || 0) > resourceTargets.tritanium) {
                    provides.push('T');
                }
                if ((planet.molybdenum || 0) + (planet.groundmolybdenum || 0) > resourceTargets.molybdenum) {
                    provides.push('M');
                }
                
                if (provides.length > 0) {
                    const distance = Math.sqrt(
                        (targetPlanet.x - planet.x) ** 2 + 
                        (targetPlanet.y - planet.y) ** 2
                    );
                    suppliers.push({
                        planet: planet,
                        distance: distance,
                        provides: provides
                    });
                }
            }
            
            return suppliers.sort((a, b) => a.distance - b.distance);
        }
    </script>
</body>
</html>