<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VGAP Starmap Visualizer</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%);
            color: #ffffff;
            min-height: 100vh;
            overflow-x: auto;
        }

        .container {
            max-width: 100%;
            margin: 0 auto;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }

        h1 {
            text-align: center;
            margin-bottom: 20px;
            color: #00d4ff;
            text-shadow: 0 0 10px rgba(0, 212, 255, 0.5);
        }

        .navigation {
            text-align: center;
            margin-bottom: 20px;
        }

        .nav-link {
            color: #00d4ff;
            text-decoration: none;
            font-weight: 600;
            padding: 10px 20px;
            border: 2px solid #00d4ff;
            border-radius: 8px;
            display: inline-block;
            margin: 0 10px;
            transition: all 0.3s ease;
        }

        .nav-link:hover {
            background: #00d4ff;
            color: #1e3c72;
            box-shadow: 0 5px 15px rgba(0, 212, 255, 0.4);
        }

        .upload-section {
            background: rgba(255, 255, 255, 0.1);
            padding: 25px;
            border-radius: 10px;
            margin-bottom: 20px;
            backdrop-filter: blur(10px);
            text-align: center;
        }

        .file-input-wrapper {
            position: relative;
            display: inline-block;
            margin-bottom: 15px;
        }

        .file-input {
            position: absolute;
            width: 0.1px;
            height: 0.1px;
            opacity: 0;
            overflow: hidden;
            z-index: -1;
        }

        .file-input-label {
            display: inline-block;
            padding: 15px 30px;
            background: linear-gradient(45deg, #00d4ff, #0099cc);
            border: none;
            border-radius: 8px;
            color: white;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            -webkit-appearance: none;
            appearance: none;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }

        .file-input-label:hover, .file-input-label:focus {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 212, 255, 0.4);
            outline: none;
        }

        .status {
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            font-weight: 600;
            text-align: center;
        }

        .status.loading {
            background: rgba(255, 193, 7, 0.2);
            border: 2px solid #ffc107;
            color: #ffc107;
        }

        .status.success {
            background: rgba(40, 167, 69, 0.2);
            border: 2px solid #28a745;
            color: #28a745;
        }

        .status.error {
            background: rgba(220, 53, 69, 0.2);
            border: 2px solid #dc3545;
            color: #dc3545;
        }

        .status.info {
            background: rgba(0, 212, 255, 0.2);
            border: 2px solid #00d4ff;
            color: #00d4ff;
        }

        .hidden {
            display: none;
        }

        .controls {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            backdrop-filter: blur(10px);
        }

        .control-group {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            align-items: center;
            margin-bottom: 15px;
        }

        .control-group:last-child {
            margin-bottom: 0;
        }

        .control-group label {
            color: #e0e0e0;
            font-weight: 600;
            min-width: 120px;
        }

        .checkbox-group {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
        }

        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .checkbox-item input[type="checkbox"] {
            margin: 0;
        }

        .checkbox-item label {
            min-width: auto;
            font-size: 14px;
        }

        .zoom-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        button {
            padding: 8px 16px;
            background: linear-gradient(45deg, #00d4ff, #0099cc);
            border: none;
            border-radius: 6px;
            color: white;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        button:hover {
            transform: translateY(-1px);
            box-shadow: 0 3px 10px rgba(0, 212, 255, 0.3);
        }

        .starmap-container {
            background: rgba(0, 0, 0, 0.9);
            border-radius: 10px;
            padding: 20px;
            border: 2px solid rgba(0, 212, 255, 0.3);
            overflow: auto;
            max-height: 80vh;
        }

        #starmap {
            background: #000011;
            border: 1px solid #333;
            cursor: move;
        }

        .legend {
            background: rgba(0, 0, 0, 0.8);
            border-radius: 8px;
            padding: 15px;
            margin-top: 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .legend h3 {
            color: #00d4ff;
            margin-bottom: 10px;
        }

        .legend-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .legend-section {
            background: rgba(255, 255, 255, 0.05);
            padding: 10px;
            border-radius: 6px;
        }

        .legend-section h4 {
            color: #00d4ff;
            font-size: 14px;
            margin-bottom: 8px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 5px;
            font-size: 12px;
        }

        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            border: 1px solid #fff;
        }

        .legend-shape {
            width: 16px;
            height: 16px;
            border: 1px solid #fff;
        }
        
        .legend-info {
            background: rgba(0, 21, 25, 0.7);
            padding: 8px 12px;
            border-radius: 6px;
            margin-bottom: 10px;
            color: #00d4ff;
            font-size: 0.9em;
            text-align: center;
        }

        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.95);
            color: #fff;
            padding: 10px 15px;
            border-radius: 6px;
            pointer-events: none;
            font-size: 12px;
            display: none;
            z-index: 1000;
            border: 1px solid #00d4ff;
            max-width: 300px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
        }

        .tooltip h4 {
            color: #00d4ff;
            margin-bottom: 5px;
        }

        .tooltip-grid {
            display: grid;
            grid-template-columns: auto 1fr;
            gap: 5px 10px;
            font-size: 11px;
        }

        .tooltip-label {
            font-weight: bold;
            color: #ccc;
        }

        .build-info {
            text-align: center;
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
            font-size: 12px;
            color: rgba(255, 255, 255, 0.6);
        }

        .build-info a {
            color: #00d4ff;
            text-decoration: none;
        }

        .build-info a:hover {
            text-decoration: underline;
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            .control-group {
                flex-direction: column;
                align-items: flex-start;
            }
            
            .control-group label {
                min-width: auto;
            }
            
            .nav-link {
                display: block;
                margin: 5px 0;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üåå VGAP Starmap Visualizer</h1>
        
        <div class="navigation">
            <a href="mobile_vgap_viewer.html" class="nav-link">üöÄ Live Turn Loader</a>
            <a href="saved_turn_viewer.html" class="nav-link">üìÅ Saved Turn Viewer</a>
            <a href="starmap_visualizer.html" class="nav-link">üåå Starmap Visualizer</a>
        </div>

        <div class="upload-section">
            <h3>Load Turn Data for Starmap Visualization</h3>
            <p>Upload a JSON file exported from VGAP Mobile Turn Viewer to visualize your empire's starmap.</p>
            <div class="file-input-wrapper">
                <input type="file" id="fileInput" class="file-input" accept=".json" />
                <label for="fileInput" class="file-input-label">Choose Turn Data JSON File</label>
            </div>
        </div>

        <div id="status" class="status hidden"></div>

        <div id="controlsSection" class="controls hidden">
            <div class="control-group">
                <label>Display Options:</label>
                <div class="checkbox-group">
                    <div class="checkbox-item">
                        <input type="checkbox" id="showPlanets" checked>
                        <label for="showPlanets">Planets</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="showShips" checked>
                        <label for="showShips">Ships</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="showStarbases" checked>
                        <label for="showStarbases">Starbases</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="showNebulas" checked>
                        <label for="showNebulas">Nebulas</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="showNotes" checked>
                        <label for="showNotes">Strategic Notes</label>
                    </div>
                </div>
            </div>
            
            <div class="control-group">
                <label>Zoom Controls:</label>
                <div class="zoom-controls">
                    <button id="zoomIn">Zoom In</button>
                    <button id="zoomOut">Zoom Out</button>
                    <button id="resetZoom">Reset View</button>
                    <button id="fitToScreen">Fit to Screen</button>
                </div>
            </div>
        </div>

        <div id="starmapContainer" class="starmap-container hidden">
            <svg id="starmap" width="1200" height="800"></svg>
        </div>

        <div id="legend" class="legend hidden">
            <h3>üó∫Ô∏è Starmap Legend</h3>
            <div id="playerInfoLegend" class="legend-info">
                <p id="playerNameDisplay">Loading player information...</p>
                <p style="margin-top: 5px; font-size: 0.8em; font-style: italic;">Ownership is determined by Player ID (not Race ID)</p>
            </div>
            <div class="legend-grid">
                <div class="legend-section">
                    <h4>Planets</h4>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #4caf50;"></div>
                        <span>Your Planets (Happy: >70%)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #8bc34a;"></div>
                        <span>Your Planets (Moderate: 40-70%)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #a5d6a7;"></div>
                        <span>Your Planets (Unhappy: <40%)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #ff5722;"></div>
                        <span>Enemy Planets</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #9e9e9e;"></div>
                        <span>Neutral Planets</span>
                    </div>
                </div>
                
                <div class="legend-section">
                    <h4>Starbases</h4>
                    <div class="legend-item">
                        <div class="legend-shape" style="background: #00d4ff; transform: rotate(45deg);"></div>
                        <span>Your Starbases</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-shape" style="background: #f44336; transform: rotate(45deg);"></div>
                        <span>Enemy Starbases</span>
                    </div>
                </div>
                
                <div class="legend-section">
                    <h4>Ships</h4>
                    <div class="legend-item">
                        <div class="legend-shape" style="background: #00ff00; width: 12px; height: 4px; border-radius: 2px;"></div>
                        <span>Your Ships</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-shape" style="background: #ff4444; width: 12px; height: 4px; border-radius: 2px;"></div>
                        <span>Enemy Ships</span>
                    </div>
                </div>
                
                <div class="legend-section">
                    <h4>Special Features</h4>
                    <div class="legend-item">
                        <div class="legend-color" style="background: rgba(128, 0, 128, 0.3); border: 1px dashed #800080;"></div>
                        <span>Nebulas</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #ffeb3b; border-radius: 2px;"></div>
                        <span>Strategic Notes</span>
                    </div>
                </div>
            </div>
        </div>

        <div class="build-info">
            <div>üåå VGAP Starmap Visualizer</div>
            <div>Built: <span id="buildDate"></span> | <a href="https://github.com/simonclur/VGAP_MobileTurnViewExchange" target="_blank">View on GitHub</a></div>
        </div>
    </div>

    <div id="tooltip" class="tooltip"></div>

    <script>
        let currentGameData = null;
        let svgElement = null;
        let tooltip = null;
        let currentZoom = 1;
        let currentPan = { x: 0, y: 0 };
        let isDragging = false;
        let dragStart = { x: 0, y: 0 };

        // Color schemes
        const Colors = {
            // Planets by happiness - all in shades of green
            PLANET_HAPPY: '#4caf50',      // Bright green (>70%)
            PLANET_MODERATE: '#8bc34a',   // Medium green (40-70%)
            PLANET_UNHAPPY: '#a5d6a7',    // Light green (<40%)
            PLANET_ENEMY: '#ff5722',      // Orange
            PLANET_NEUTRAL: '#9e9e9e',    // Gray
            
            // Starbases
            STARBASE_MINE: '#00d4ff',     // Cyan
            STARBASE_ENEMY: '#f44336',    // Red
            
            // Ships
            SHIP_MINE: '#00ff00',         // Green
            SHIP_ENEMY: '#ff4444',        // Red
            
            // Nebulas
            NEBULA_FILL: 'rgba(128, 0, 128, 0.3)', // Purple transparent
            NEBULA_STROKE: '#800080',     // Purple
            
            // Notes
            NOTE_COLOR: '#ffeb3b',        // Yellow
            
            // Allied objects
            ALLIED: '#4a90e2',           // Blue
        };

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            svgElement = document.getElementById('starmap');
            tooltip = document.getElementById('tooltip');
            
            initializeEventListeners();
            initializePanZoom();
            setBuildDate();
            loadSampleData();
        });

        function initializeEventListeners() {
            // File input
            document.getElementById('fileInput').addEventListener('change', handleFileSelect);
            
            // Display toggles
            ['showPlanets', 'showShips', 'showStarbases', 'showNebulas', 'showNotes'].forEach(id => {
                document.getElementById(id).addEventListener('change', redrawStarmap);
            });
            
            // Zoom controls
            document.getElementById('zoomIn').addEventListener('click', () => zoomStarmap(1.5));
            document.getElementById('zoomOut').addEventListener('click', () => zoomStarmap(0.67));
            document.getElementById('resetZoom').addEventListener('click', resetView);
            document.getElementById('fitToScreen').addEventListener('click', fitToScreen);
        }

        function initializePanZoom() {
            svgElement.addEventListener('mousedown', startDrag);
            svgElement.addEventListener('mousemove', drag);
            svgElement.addEventListener('mouseup', endDrag);
            svgElement.addEventListener('mouseleave', endDrag);
            svgElement.addEventListener('wheel', handleWheel, { passive: false });
        }

        function setBuildDate() {
            const buildDateElement = document.getElementById('buildDate');
            buildDateElement.textContent = 'Loading...';
            
            fetch('https://api.github.com/repos/simonclur/VGAP_MobileTurnViewExchange/commits/main')
                .then(response => response.json())
                .then(data => {
                    const commitDate = new Date(data.commit.author.date);
                    const formattedDate = commitDate.toLocaleString('en-US', {
                        year: 'numeric',
                        month: 'short',
                        day: 'numeric',
                        hour: '2-digit',
                        minute: '2-digit',
                        timeZoneName: 'short'
                    });
                    buildDateElement.innerHTML = `${formattedDate} <span style="opacity: 0.7;">(<a href="https://github.com/simonclur/VGAP_MobileTurnViewExchange/commit/${data.sha}" target="_blank" style="color: #00d4ff; text-decoration: none;">${data.sha.substring(0, 7)}</a>)</span>`;
                })
                .catch(error => {
                    console.error('Failed to fetch commit date:', error);
                    const fallbackDate = new Date().toLocaleString();
                    buildDateElement.textContent = `${fallbackDate} (offline)`;
                });
        }

        function showStatus(message, type = 'loading') {
            const statusElement = document.getElementById('status');
            statusElement.textContent = message;
            statusElement.className = `status ${type}`;
            statusElement.classList.remove('hidden');
        }

        function hideStatus() {
            document.getElementById('status').classList.add('hidden');
        }

        function loadSampleData() {
            showStatus('Loading sample turn data...', 'loading');
            
            fetch('vgap_gameunknown_turn41_20250917T2327.json')
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Sample data file not found');
                    }
                    return response.json();
                })
                .then(jsonData => {
                    if (!jsonData.rst || !jsonData.rst.settings) {
                        throw new Error('Invalid VGAP turn file format');
                    }
                    
                    // Extract player information
                    const playerInfo = jsonData.rst?.player || {};
                    const playerRaceId = parseInt(playerInfo.raceid, 10) || 0;
                    const playerName = playerInfo.username || 'Unknown';
                    
                    console.log(`Sample data loaded successfully:`);
                    console.log(`- Game: ${jsonData.rst?.settings?.name || 'Unknown'}`);
                    console.log(`- Player: ${playerName} (Race ID: ${playerRaceId})`);
                    console.log(`- Planets: ${jsonData.rst?.planets?.length || 0}`);
                    console.log(`- Ships: ${jsonData.rst?.ships?.length || 0}`);

                    currentGameData = jsonData;
                    initializeStarmap();
                    
                    showStatus('Sample turn data loaded! Upload your own turn file to explore different games. üåü', 'success');
                    setTimeout(hideStatus, 4000);
                })
                .catch(error => {
                    console.warn('Could not load sample data:', error);
                    showStatus('Ready to load turn data. Please select a VGAP turn file above.', 'info');
                    setTimeout(hideStatus, 3000);
                });
        }

        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (file) {
                processFile(file);
            }
        }

        function processFile(file) {
            showStatus('Reading turn data...', 'loading');
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const jsonData = JSON.parse(e.target.result);
                    
                    if (!jsonData.rst || !jsonData.rst.settings) {
                        throw new Error('Invalid VGAP turn file format');
                    }
                    
                    // Extract player information
                    const playerInfo = jsonData.rst?.player || {};
                    const playerRaceId = parseInt(playerInfo.raceid, 10) || 0;
                    const playerName = playerInfo.username || 'Unknown';
                    const gameName = jsonData.rst?.settings?.name || 'Unknown Game';
                    
                    console.log(`Turn data loaded successfully:`);
                    console.log(`- Game: ${gameName} (Turn: ${jsonData.rst?.settings?.turn || '?'})`);
                    console.log(`- Player: ${playerName} (Race ID: ${playerRaceId})`);
                    console.log(`- Planets: ${jsonData.rst?.planets?.length || 0}`);
                    console.log(`- Ships: ${jsonData.rst?.ships?.length || 0}`);
                    
                    if (playerRaceId === 0) {
                        console.warn("WARNING: No player race ID detected in turn data!");
                        showStatus('Turn data loaded, but player race ID not found. Ownership detection may be incorrect.', 'info');
                    } else {
                        showStatus(`Turn data for ${gameName} loaded successfully! üéâ`, 'success');
                    }

                    currentGameData = jsonData;
                    initializeStarmap();
                    
                    setTimeout(hideStatus, 4000);

                } catch (error) {
                    showStatus(`Error reading file: ${error.message}`, 'error');
                    console.error('File processing error:', error);
                }
            };

            reader.onerror = function() {
                showStatus('Error reading file', 'error');
            };

            reader.readAsText(file);
        }

        function initializeStarmap() {
            if (!currentGameData) return;
            
            // Show controls and starmap
            document.getElementById('controlsSection').classList.remove('hidden');
            document.getElementById('starmapContainer').classList.remove('hidden');
            document.getElementById('legend').classList.remove('hidden');
            
            // Extract and validate player information
            const playerInfo = currentGameData.rst?.player || {};
            const playerId = parseInt(playerInfo.id, 10) || 0;
            const playerRaceId = parseInt(playerInfo.raceid, 10) || 0;
            const playerName = playerInfo.username || 'Unknown';
            const raceName = playerInfo.racename || 'Unknown Race';
            
            console.log(`Initializing starmap for player: ${playerName} (Player ID: ${playerId}, Race: ${raceName}, Race ID: ${playerRaceId})`);
            
            // Debug: Examine the structure of the game data to ensure we're accessing properties correctly
            console.log("Game data structure check:");
            console.log("- Player information:", currentGameData.rst?.player);
            console.log("- Player ID:", playerId);
            console.log("- Player race ID:", playerRaceId);
            
            // Check a sample planet and ship to verify property access
            const samplePlanet = (currentGameData.rst?.planets || [])[0];
            const sampleShip = (currentGameData.rst?.ships || [])[0];
            
            if (samplePlanet) {
                console.log("- Sample planet structure:", samplePlanet);
                console.log("- Planet owner ID:", samplePlanet.ownerid);
            }
            
            if (sampleShip) {
                console.log("- Sample ship structure:", sampleShip);
                console.log("- Ship owner ID:", sampleShip.ownerid);
            }
            
            // Calculate starmap dimensions based on game data
            const { width, height } = calculateStarmapDimensions();
            svgElement.setAttribute('width', width);
            svgElement.setAttribute('height', height);
            svgElement.setAttribute('viewBox', `0 0 ${width} ${height}`);
            
            // Display player information in UI if available
            const gameTitle = document.querySelector('h1');
            if (gameTitle && playerId > 0) {
                const gameName = currentGameData.rst?.settings?.name || 'Unknown Game';
                const raceName = playerInfo.racename || 'Unknown Race';
                
                // Update the main title
                gameTitle.textContent = `üåå VGAP Starmap - ${playerName}`;
                
                // Add game name as a subtitle
                const subtitle = document.createElement('div');
                subtitle.textContent = `${gameName} - Playing as ${raceName}`;
                subtitle.style.fontSize = '0.7em';
                subtitle.style.opacity = '0.8';
                subtitle.style.marginTop = '5px';
                
                // Clear existing content and add title with subtitle
                gameTitle.innerHTML = '';
                const mainTitle = document.createElement('span');
                mainTitle.textContent = `üåå VGAP Starmap - ${playerName}`;
                gameTitle.appendChild(mainTitle);
                gameTitle.appendChild(document.createElement('br'));
                gameTitle.appendChild(subtitle);
                
                // Update player info in the legend
                const playerInfoHtml = `
                    <span>${playerName} (${raceName})</span><br>
                    <span style="font-size: 0.9em; opacity: 0.9;">Player ID: ${playerId} | Race ID: ${playerRaceId}</span>
                `;
                document.getElementById('playerNameDisplay').innerHTML = playerInfoHtml;
            } else {
                // Handle case where player info is not available
                document.getElementById('playerNameDisplay').innerHTML = '<span>Unknown Player</span>';
            }
            
            redrawStarmap();
        }

        // Authentic Planets.nu coordinate transformation system
        // Based on nu.js ecMap class implementation
        
        const mapCanvas = {
            x: 500,          // bottom left X value in map units (default start position)
            y: 500,          // bottom left Y value in map units (default start position)  
            mapwidth: 2000,  // width of map in map units (standard VGAP map)
            mapheight: 2000, // height of map in map units (standard VGAP map)
            width: 800,      // width of canvas in pixels
            height: 600,     // height of canvas in pixels
            zoom: 1.0        // zoom factor
        };
        
        // Initialize canvas dimensions from actual SVG and game data
        function initializeMapCanvas(svgWidth, svgHeight, gameSettings) {
            mapCanvas.width = svgWidth;
            mapCanvas.height = svgHeight;
            
            // Calculate actual coordinate bounds from planet data
            const planets = currentGameData.rst?.planets || [];
            if (planets.length > 0) {
                const xCoords = planets.map(p => p.x).filter(x => x !== undefined);
                const yCoords = planets.map(p => p.y).filter(y => y !== undefined);
                
                const minX = Math.min(...xCoords);
                const maxX = Math.max(...xCoords);
                const minY = Math.min(...yCoords);
                const maxY = Math.max(...yCoords);
                
                // Use actual data bounds instead of settings
                mapCanvas.mapwidth = maxX - minX + 100;  // Add padding
                mapCanvas.mapheight = maxY - minY + 100; // Add padding
                
                console.log(`Calculated map bounds: X=${minX}-${maxX}, Y=${minY}-${maxY}`);
                console.log(`Map canvas initialized: ${mapCanvas.width}x${mapCanvas.height} pixels, ${mapCanvas.mapwidth}x${mapCanvas.mapheight} map units`);
                
                // Set zoom to fit entire map in view
                const scaleX = mapCanvas.width / mapCanvas.mapwidth;
                const scaleY = mapCanvas.height / mapCanvas.mapheight;
                mapCanvas.zoom = Math.min(scaleX, scaleY) * 0.9; // 90% to leave margin
                
                // Set canvas origin to actual data bounds (bottom-left corner)
                mapCanvas.x = minX - 50; // Bottom-left X with padding
                mapCanvas.y = minY - 50; // Bottom-left Y with padding
                
                console.log(`Map view: zoom=${mapCanvas.zoom.toFixed(3)}, origin=(${mapCanvas.x.toFixed(1)}, ${mapCanvas.y.toFixed(1)})`);
            } else {
                // Fallback to default values if no planets
                console.log(`No planet data found, using defaults`);
                mapCanvas.mapwidth = gameSettings?.mapwidth || 2000;
                mapCanvas.mapheight = gameSettings?.mapheight || 2000;
                mapCanvas.zoom = Math.min(mapCanvas.width / mapCanvas.mapwidth, mapCanvas.height / mapCanvas.mapheight) * 0.9;
                mapCanvas.x = (mapCanvas.mapwidth / 2) - (mapCanvas.width / mapCanvas.zoom / 2);
                mapCanvas.y = (mapCanvas.mapheight / 2) - (mapCanvas.height / mapCanvas.zoom / 2);
            }
        }
        
        // Authentic coordinate transformation functions from nu.js
        function screenX(x) {
            return ((x - mapCanvas.x) * mapCanvas.zoom) + 0.5;
        }
        
        function screenY(y) {
            return mapCanvas.height - (((y - mapCanvas.y) * mapCanvas.zoom) + 0.5);
        }
        
        function createScalingFunctions(svgWidth, svgHeight, gameData) {
            // Initialize the authentic map canvas system
            initializeMapCanvas(svgWidth, svgHeight, gameData.rst?.settings);
            
            // Return scaling functions using authentic coordinate system
            
            const scaleX = (x) => {
                return screenX(x);
            };
            
            const scaleY = (y) => {
                return screenY(y);
            };
            
            return { scaleX, scaleY };
        }

        function calculateStarmapDimensions() {
            // Use standard VGAP map aspect ratio (typically square maps)
            const gameSettings = currentGameData.rst?.settings;
            const mapWidth = gameSettings?.mapwidth || 2000;
            const mapHeight = gameSettings?.mapheight || 2000;
            const aspectRatio = mapWidth / mapHeight;
            
            // Base dimensions that work well for display
            const baseHeight = 800;
            const baseWidth = Math.max(1200, baseHeight * aspectRatio);
            
            return { 
                width: baseWidth, 
                height: baseHeight
            };
        }

        function redrawStarmap() {
            if (!currentGameData || !svgElement) return;
            
            // Clear existing content
            svgElement.innerHTML = '';

            const { width, height } = calculateStarmapDimensions();
            
            // Extract player information properly
            const playerInfo = currentGameData.rst?.player || {};
            const playerId = parseInt(playerInfo.id, 10) || 0;
            const playerRaceId = parseInt(playerInfo.raceid, 10) || 0;
            
            // Debug: Log the player object structure for verification
            console.log("Player info summary:");
            console.log("- Player ID:", playerId);
            console.log("- Race ID:", playerRaceId);
            console.log("- Username:", playerInfo.username || 'Unknown');
            console.log("- Race name:", playerInfo.racename || 'Unknown');
            
            // Add a fallback for missing player data
            if (playerId === 0) {
                console.warn("Player ID not found in turn data! Using neutral view.");
            }
            
            // Update SVG dimensions
            svgElement.setAttribute('width', width);
            svgElement.setAttribute('height', height);
            svgElement.setAttribute('viewBox', `0 0 ${width} ${height}`);
            
            // Create scaling functions using authentic Planets.nu coordinate system
            const { scaleX, scaleY } = createScalingFunctions(width, height, currentGameData);            // Add border rect like the dashboard
            const borderRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
            borderRect.setAttribute("x", "0");
            borderRect.setAttribute("y", "0");
            borderRect.setAttribute("width", width);
            borderRect.setAttribute("height", height);
            borderRect.setAttribute("fill", "none");
            borderRect.setAttribute("stroke", "#444");
            borderRect.setAttribute("stroke-width", "2");
            svgElement.appendChild(borderRect);
            
            // Pass scaling functions to drawing functions
            const drawingContext = { scaleX, scaleY };
            
            // Draw nebulas first (background)
            if (document.getElementById('showNebulas').checked) {
                drawNebulas(svgElement, drawingContext);
            }
            
            // Draw planets
            if (document.getElementById('showPlanets').checked) {
                drawPlanets(svgElement, playerId, drawingContext);
            }
            
            // Draw starbases
            if (document.getElementById('showStarbases').checked) {
                drawStarbases(svgElement, playerId, drawingContext);
            }
            
            // Draw ships
            if (document.getElementById('showShips').checked) {
                drawShips(svgElement, playerId, drawingContext);
            }
            
            // Draw strategic notes
            if (document.getElementById('showNotes').checked) {
                drawStrategicNotes(svgElement, drawingContext);
            }
        }

        function drawNebulas(parent, drawingContext) {
            const nebulas = currentGameData.rst?.nebulas || [];
            const { scaleX, scaleY } = drawingContext;
            
            nebulas.forEach(nebula => {
                const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                circle.setAttribute("cx", scaleX(nebula.x || 0));
                circle.setAttribute("cy", scaleY(nebula.y || 0));
                circle.setAttribute("r", (nebula.radius || 50) * 0.5); // Scale radius down for display
                circle.setAttribute("fill", Colors.NEBULA_FILL);
                circle.setAttribute("stroke", Colors.NEBULA_STROKE);
                circle.setAttribute("stroke-width", "2");
                circle.setAttribute("stroke-dasharray", "5,5");
                
                addTooltipToElement(circle, {
                    title: `üå´Ô∏è ${nebula.name || 'Nebula'}`,
                    data: {
                        'ID': nebula.id,
                        'Location': `(${nebula.x}, ${nebula.y})`,
                        'Radius': `${nebula.radius} ly`,
                        'Intensity': nebula.intensity,
                        'Gas Level': nebula.gas
                    }
                });
                
                parent.appendChild(circle);
            });
        }

        function drawPlanets(parent, playerId, drawingContext) {
            const planets = currentGameData.rst?.planets || [];
            const starbases = currentGameData.rst?.starbases || [];
            const starbaseMap = {};
            const { scaleX, scaleY } = drawingContext;
            
            // Get map settings for wrap-around universe
            const gameSettings = currentGameData.rst?.settings || {};
            const mapWidth = gameSettings.mapwidth || 2000;
            const mapHeight = gameSettings.mapheight || 2000;
            
            console.log(`Drawing ${planets.length} planets with wrap-around universe (${mapWidth}x${mapHeight})`);
            console.log(`First few planets:`, planets.slice(0, 3).map(p => ({ name: p.name, x: p.x, y: p.y })));
            
            // Create starbase lookup
            starbases.forEach(sb => {
                starbaseMap[sb.planetid] = sb;
            });
            
            planets.forEach((planet, index) => {
                // Draw main planet at its actual position
                drawSinglePlanet(parent, planet, starbaseMap, scaleX, scaleY, playerId, index < 3);
                
                // Draw wrap-around copies for edge planets
                drawWrapAroundCopies(parent, planet, starbaseMap, scaleX, scaleY, mapWidth, mapHeight, playerId);
            });
        }
        
        function drawSinglePlanet(parent, planet, starbaseMap, scaleX, scaleY, playerId, showDebug = false) {
            const cx = scaleX(planet.x || 0);
            const cy = scaleY(planet.y || 0);
            
            if (showDebug) {
                console.log(`Planet ${planet.name}: game coords (${planet.x}, ${planet.y}) -> screen coords (${cx.toFixed(1)}, ${cy.toFixed(1)})`);
            }
            
            // Use fixed radius like the dashboard (2mm = ~7.5px)
            const radiusPx = 7.5;
            
            // Draw starbase highlight if present (like dashboard)
            if (starbaseMap[planet.id]) {
                const square = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                const side = radiusPx * 2.2;
                square.setAttribute("x", cx - side / 2);
                square.setAttribute("y", cy - side / 2);
                square.setAttribute("width", side);
                square.setAttribute("height", side);
                square.setAttribute("fill", "none");
                square.setAttribute("stroke", "#ffeb3b");
                square.setAttribute("stroke-width", "2");
                parent.appendChild(square);
            }
            
            const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                circle.setAttribute("cx", cx);
                circle.setAttribute("cy", cy);
                circle.setAttribute("r", radiusPx);
                circle.setAttribute("fill", getPlanetColor(planet, playerId));
                circle.setAttribute("stroke", "#ffffff");
                circle.setAttribute("stroke-width", "1");
                circle.style.cursor = "pointer";
                
                // Add planet name label
                const label = document.createElementNS("http://www.w3.org/2000/svg", "text");
                label.setAttribute("x", cx);
                label.setAttribute("y", cy + radiusPx + 15);
                label.setAttribute("text-anchor", "middle");
                label.setAttribute("fill", "#ffffff");
                label.setAttribute("font-size", "10");
                label.setAttribute("font-weight", "bold");
                label.textContent = (planet.name || `Planet ${planet.id}`).substring(0, 12);
                
                // Find ships at this planet
                const ships = currentGameData.rst?.ships || [];
                const shipsAtPlanet = ships.filter(ship => 
                    parseInt(ship.x, 10) === parseInt(planet.x, 10) && 
                    parseInt(ship.y, 10) === parseInt(planet.y, 10)
                );
                
                let tooltipData = {
                    'ID': planet.id,
                    'Owner': getOwnerName(planet.ownerid, playerId),
                    'Location': `(${planet.x}, ${planet.y})`,
                    'Friendly Code': planet.friendlycode || '',
                    'Temperature': `${planet.temp || 0}¬∞`,
                    'Colonists': `${(planet.clans || 0).toLocaleString()}`,
                    'Natives': `${(planet.nativeclans || 0).toLocaleString()}`,
                    'Native Race': planet.nativeracename || 'None',
                    'Native Government': planet.nativegovernmentname || 'None',
                    'Factories': planet.factories || 0,
                    'Mines': planet.mines || 0,
                    'Defense': planet.defense || 0,
                    'Colonist Happiness': `${planet.colonisthappypoints || 0}%`,
                    'Native Happiness': `${planet.nativehappypoints || 0}%`,
                    'Starbase': starbaseMap[planet.id] ? 'Yes' : 'No',
                    'Minerals': `N:${planet.neutronium || 0} D:${planet.duranium || 0} T:${planet.tritanium || 0} M:${planet.molybdenum || 0}`
                };
                
                // Add ships at this location if any
                if (shipsAtPlanet.length > 0) {
                    tooltipData['Ships at Location'] = `${shipsAtPlanet.length} ship(s)`;
                    
                    // Add information about each ship
                    shipsAtPlanet.forEach((ship, index) => {
                        const isMyShip = parseInt(ship.ownerid, 10) === parseInt(playerId, 10);
                        const shipPrefix = isMyShip ? 'üü¢' : 'üî¥';
                        tooltipData[`Ship ${index + 1}`] = `${shipPrefix} ${ship.name || 'Unnamed'} (${ship.hullname || 'Unknown Hull'})`;
                    });
                }
                
                addTooltipToElement(circle, {
                    title: `ü™ê ${planet.name || 'Unnamed Planet'}`,
                    data: tooltipData
                });
                
                parent.appendChild(circle);
                parent.appendChild(label);
        }
        
        function drawWrapAroundCopies(parent, planet, starbaseMap, scaleX, scaleY, mapWidth, mapHeight, playerId) {
            const x = planet.x || 0;
            const y = planet.y || 0;
            
            // Get current view bounds to determine which wrap-around copies to draw
            const viewLeft = mapCanvas.x;
            const viewRight = mapCanvas.x + (mapCanvas.width / mapCanvas.zoom);
            const viewTop = mapCanvas.y;
            const viewBottom = mapCanvas.y + (mapCanvas.height / mapCanvas.zoom);
            
            // Standard VGAP wrap-around: 2000x2000 universe wraps at edges
            const universeWidth = 2000;
            const universeHeight = 2000;
            
            // Check all 8 wrap-around positions (excluding original [0,0])
            const offsets = [
                [-universeWidth, -universeHeight], [0, -universeHeight], [universeWidth, -universeHeight],
                [-universeWidth, 0],                                     [universeWidth, 0],
                [-universeWidth, universeHeight],  [0, universeHeight],  [universeWidth, universeHeight]
            ];
            
            offsets.forEach(([dx, dy]) => {
                const wrappedX = x + dx;
                const wrappedY = y + dy;
                
                // Only draw if the wrapped position would be visible in current view
                if (wrappedX >= viewLeft - 100 && wrappedX <= viewRight + 100 &&
                    wrappedY >= viewTop - 100 && wrappedY <= viewBottom + 100) {
                    
                    // Create a wrapped version of the planet
                    const wrappedPlanet = { ...planet, x: wrappedX, y: wrappedY };
                    drawSinglePlanet(parent, wrappedPlanet, starbaseMap, scaleX, scaleY, playerId, false);
                }
            });
        }

        function drawStarbases(parent, playerId, drawingContext) {
            // Starbases are now drawn as part of drawPlanets function (as highlighted squares)
            // This function is kept for consistency but doesn't need to do anything
            // since we're following the dashboard pattern of showing starbases as planet highlights
        }

        function drawShips(parent, playerId, drawingContext) {
            const ships = currentGameData.rst?.ships || [];
            const planets = currentGameData.rst?.planets || [];
            const { scaleX, scaleY } = drawingContext;
            
            // Safely parse playerId to a number
            const playerIdNum = parseInt(playerId, 10) || 0;
            
            console.log(`Drawing ${ships.length} ships with playerId=${playerIdNum}`);
            
            // Debug: Log the first few ships and directly examine the ship structure
            if (ships.length > 0) {
                console.log("First ship raw data:", ships[0]);
                console.log("First few ships:", ships.slice(0, 3).map(s => {
                    // Safely parse ownerid to a number
                    const ownerIdNum = parseInt(s.ownerid, 10) || 0;
                    return { 
                        name: s.name,
                        ownerid: s.ownerid,
                        owneridNum: ownerIdNum,
                        playerId: playerIdNum,
                        isPlayerShip: ownerIdNum === playerIdNum
                    };
                }));
            }
            
            ships.forEach(ship => {
                const cx = scaleX(ship.x || 0);
                const cy = scaleY(ship.y || 0);
                
                // Safely parse ship owner ID to ensure proper comparison
                const shipOwnerIdNum = parseInt(ship.ownerid, 10) || 0;
                const isMine = shipOwnerIdNum === playerIdNum;
                
                // Check if ship is at a planet (like dashboard)
                const atPlanet = planets.find(p => 
                    Math.abs(p.x - ship.x) < 2 && Math.abs(p.y - ship.y) < 2
                );
                
                if (atPlanet) {
                    // Ship at planet - draw circle around planet
                    const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                    circle.setAttribute("cx", scaleX(atPlanet.x));
                    circle.setAttribute("cy", scaleY(atPlanet.y));
                    circle.setAttribute("r", 16);
                    circle.setAttribute("fill", "none");
                    circle.setAttribute("stroke", isMine ? "#00e676" : "#e53935");
                    circle.setAttribute("stroke-width", "2");
                    circle.style.cursor = "pointer";
                    
                    addTooltipToElement(circle, {
                        title: `üö¢ ${ship.name || 'Unnamed Ship'}`,
                        data: {
                            'ID': ship.id,
                            'Owner': getOwnerName(ship.ownerid, playerId),
                            'Hull': ship.hullname || 'Unknown',
                            'Location': `(${ship.x}, ${ship.y})`,
                            'At Planet': atPlanet.name || atPlanet.id,
                            'Mass': `${ship.mass || 0} kt`,
                            'Fuel': `${ship.neutronium || 0} kt`,
                            'Crew': ship.crew || 0,
                            'Damage': `${ship.damage || 0}%`
                        }
                    });
                    
                    parent.appendChild(circle);
                } else {
                    // Ship in space - draw small dot
                    const dot = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                    dot.setAttribute("cx", cx);
                    dot.setAttribute("cy", cy);
                    dot.setAttribute("r", 4);
                    dot.setAttribute("fill", isMine ? "#00e676" : "#e53935");
                    dot.setAttribute("stroke", "#fff");
                    dot.setAttribute("stroke-width", "1");
                    dot.style.cursor = "pointer";
                    
                    addTooltipToElement(dot, {
                        title: `üö¢ ${ship.name || 'Unnamed Ship'}`,
                        data: {
                            'ID': ship.id,
                            'Owner': getOwnerName(ship.ownerid, playerId),
                            'Hull': ship.hullname || 'Unknown',
                            'Location': `(${ship.x}, ${ship.y})`,
                            'Mass': `${ship.mass || 0} kt`,
                            'Fuel': `${ship.neutronium || 0} kt`,
                            'Crew': ship.crew || 0,
                            'Damage': `${ship.damage || 0}%`
                        }
                    });
                    
                    parent.appendChild(dot);
                }
            });
        }

        function drawStrategicNotes(parent, drawingContext) {
            // This would draw notes from your strategic planning
            // For now, we'll add sample strategic markers
            const strategicPoints = [
                // These would come from your notes/strategy data
                // For demo purposes, showing concept
            ];
            
            const { scaleX, scaleY } = drawingContext;
            
            strategicPoints.forEach(point => {
                const cx = scaleX(point.x);
                const cy = scaleY(point.y);
                
                const marker = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
                marker.setAttribute("points", "0,-8 6,8 -6,8");
                marker.setAttribute("transform", `translate(${cx}, ${cy})`);
                marker.setAttribute("fill", Colors.NOTE_COLOR);
                marker.setAttribute("stroke", "#000000");
                marker.setAttribute("stroke-width", "1");
                marker.style.cursor = "pointer";
                
                addTooltipToElement(marker, {
                    title: `üìù ${point.title}`,
                    data: {
                        'Type': point.type,
                        'Priority': point.priority,
                        'Notes': point.notes
                    }
                });
                
                parent.appendChild(marker);
            });
        }

        // Helper functions
        function getPlayerRaceId() {
            // Safely extract and parse the player race ID from the current game data
            const playerInfo = currentGameData?.rst?.player || {};
            const playerRaceId = playerInfo.raceid;
            
            // Parse the race ID to a number and return 0 if invalid
            const parsedRaceId = parseInt(playerRaceId, 10) || 0;
            
            if (parsedRaceId === 0) {
                console.warn("Warning: Could not determine player race ID from turn data");
            } else {
                console.log(`Player race ID identified: ${parsedRaceId}`);
            }
            
            return parsedRaceId;
        }
        
        function getPlayerId() {
            // Safely extract and parse the player ID from the current game data
            const playerInfo = currentGameData?.rst?.player || {};
            const playerId = playerInfo.id;
            
            // Parse the player ID to a number and return 0 if invalid
            const parsedPlayerId = parseInt(playerId, 10) || 0;
            
            if (parsedPlayerId === 0) {
                console.warn("Warning: Could not determine player ID from turn data");
            } else {
                console.log(`Player ID identified: ${parsedPlayerId}`);
            }
            
            return parsedPlayerId;
        }
        
        function getPlayerInfo() {
            // Get comprehensive player information from turn data
            const playerInfo = currentGameData?.rst?.player || {};
            return {
                id: parseInt(playerInfo.id, 10) || 0,
                raceId: parseInt(playerInfo.raceid, 10) || 0,
                username: playerInfo.username || 'Unknown',
                raceName: playerInfo.racename || 'Unknown Race',
                planetCount: parseInt(playerInfo.planetcount, 10) || 0,
                shipCount: parseInt(playerInfo.shipcount, 10) || 0,
                isAuthenticated: !!playerInfo.authenticated
            };
        }
        
        function getOwnerName(ownerId, playerId) {
            // Safely parse to numbers for proper comparison
            const ownerIdNum = parseInt(ownerId, 10) || 0;
            const playerIdNum = parseInt(playerId, 10) || 0;
            
            if (ownerIdNum === 0) return 'Unowned';
            if (ownerIdNum === playerIdNum) return 'Mine';
            
            // Could add alliance check here
            // if (checkIfAlly(ownerIdNum)) return 'Ally';
            
            return `Player ${ownerIdNum}`;
        }

        function getPlanetColor(planet, playerId) {
            // Player ID is now passed directly as a parameter
            // No need to call getPlayerId() again
            
            // Safely access ownerid, ensuring it's properly read as a number
            const ownerId = parseInt(planet.ownerid, 10) || 0;
            
            // Check if the planet is owned by the player (comparing player IDs, not race IDs)
            const isMyPlanet = ownerId === playerId && playerId > 0;
            
            if (ownerId === 0) return Colors.PLANET_NEUTRAL;
            if (!isMyPlanet) {
                // Check if this is an ally (could implement alliance check here if needed)
                // const isAlly = checkIfAlly(ownerId); // Would need to implement this function
                // if (isAlly) return Colors.ALLIED;
                return Colors.PLANET_ENEMY;
            }
            
            // Color by happiness for my planets
            const happiness = parseInt(planet.colonisthappypoints, 10) || 0;
            if (happiness >= 70) return Colors.PLANET_HAPPY;
            if (happiness >= 40) return Colors.PLANET_MODERATE;
            return Colors.PLANET_UNHAPPY;
        }

        function getStarbaseColor(ownerId, playerId) {
            // Player ID is now passed directly as a parameter
            // No need to call getPlayerId() again
            
            // Safely parse values to ensure proper comparison
            const ownerIdNum = parseInt(ownerId, 10) || 0;
            
            const isPlayerStarbase = ownerIdNum === playerId && playerId > 0;
            
            return isPlayerStarbase ? Colors.STARBASE_MINE : Colors.STARBASE_ENEMY;
            
            // Could add alliance check here if needed
            // if (checkIfAlly(ownerIdNum)) return Colors.ALLIED;
        }

        function getShipColor(ownerId, playerId) {
            // Player ID is now passed directly as a parameter
            // No need to call getPlayerId() again
            
            // Safely parse values to ensure proper comparison
            const ownerIdNum = parseInt(ownerId, 10) || 0;
            
            const isPlayerShip = ownerIdNum === playerId && playerId > 0;
            
            return isPlayerShip ? Colors.SHIP_MINE : Colors.SHIP_ENEMY;
            
            // Could add alliance check here if needed
            // if (checkIfAlly(ownerIdNum)) return Colors.ALLIED;
        }

        function getPlanetRadius(planet) {
            // Radius based on development level
            const factories = planet.factories || 0;
            const defense = planet.defense || 0;
            const total = factories + defense;
            
            if (total >= 100) return 12;
            if (total >= 50) return 10;
            if (total >= 20) return 8;
            return 6;
        }

        function getPlayerRadius(planet) {
            // Alias for getPlanetRadius for backward compatibility
            return getPlanetRadius(planet);
        }

        function addTooltipToElement(element, data) {
            element.addEventListener('mouseenter', (e) => {
                showTooltip(e, data);
            });
            
            element.addEventListener('mousemove', (e) => {
                updateTooltipPosition(e);
            });
            
            element.addEventListener('mouseleave', () => {
                hideTooltip();
            });
        }

        function showTooltip(event, data) {
            let html = `<h4>${data.title}</h4>`;
            html += '<div class="tooltip-grid">';
            
            Object.entries(data.data).forEach(([label, value]) => {
                html += `<div class="tooltip-label">${label}:</div><div>${value}</div>`;
            });
            
            html += '</div>';
            
            tooltip.innerHTML = html;
            tooltip.style.display = 'block';
            updateTooltipPosition(event);
        }

        function updateTooltipPosition(event) {
            const rect = document.body.getBoundingClientRect();
            tooltip.style.left = (event.clientX + 10) + 'px';
            tooltip.style.top = (event.clientY - 10) + 'px';
        }

        function hideTooltip() {
            tooltip.style.display = 'none';
        }

        // Pan and zoom functionality
        function startDrag(event) {
            isDragging = true;
            dragStart = { x: event.clientX - currentPan.x, y: event.clientY - currentPan.y };
            svgElement.style.cursor = 'grabbing';
        }

        function drag(event) {
            if (!isDragging) return;
            
            currentPan.x = event.clientX - dragStart.x;
            currentPan.y = event.clientY - dragStart.y;
            
            updateTransform();
        }

        function endDrag() {
            isDragging = false;
            svgElement.style.cursor = 'move';
        }

        function handleWheel(event) {
            event.preventDefault();
            
            const zoomFactor = event.deltaY > 0 ? 0.9 : 1.1;
            zoomStarmap(zoomFactor);
        }

        function zoomStarmap(factor) {
            currentZoom *= factor;
            currentZoom = Math.max(0.1, Math.min(10, currentZoom)); // Limit zoom range
            
            updateTransform();
        }

        function resetView() {
            currentZoom = 1;
            currentPan = { x: 0, y: 0 };
            updateTransform();
        }

        function fitToScreen() {
            const containerRect = document.getElementById('starmapContainer').getBoundingClientRect();
            const svgRect = svgElement.getBBox();
            
            const scaleX = containerRect.width / svgRect.width;
            const scaleY = containerRect.height / svgRect.height;
            
            currentZoom = Math.min(scaleX, scaleY) * 0.9; // 90% to add some padding
            currentPan = { x: 0, y: 0 };
            
            updateTransform();
        }

        function updateTransform() {
            // With the new scaling system, we apply zoom and pan to the entire SVG viewBox
            if (!currentGameData || !svgElement) return;
            
            const { width, height } = calculateStarmapDimensions();
            const viewBoxWidth = width / currentZoom;
            const viewBoxHeight = height / currentZoom;
            const viewBoxX = -currentPan.x / currentZoom;
            const viewBoxY = -currentPan.y / currentZoom;
            
            svgElement.setAttribute('viewBox', `${viewBoxX} ${viewBoxY} ${viewBoxWidth} ${viewBoxHeight}`);
        }
    </script>
</body>
</html>